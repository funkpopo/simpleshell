{"version":3,"file":"index.js","mappings":";;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACTA;;AAEA,aAAa,mBAAO,CAAC,uDAAU;AAC/B,YAAY,mBAAO,CAAC,qDAAS;AAC7B,aAAa,mBAAO,CAAC,uDAAU;AAC/B,aAAa,mBAAO,CAAC,uDAAU;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClBA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,wFAA8B;AAC3C,WAAW,mBAAO,CAAC,qDAAS;AAC5B,aAAa,mBAAO,CAAC,uDAAU;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,4CAA4C;AAC5C;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;AC9KA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnCA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,wFAA8B;AAC3C,WAAW,mBAAO,CAAC,qDAAS;AAC5B,aAAa,mBAAO,CAAC,uDAAU;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,GAAG;AACvB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;AC1OA;;AAEA;AACA;;AAEA,UAAU,mBAAO,CAAC,yDAAa;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACba;;AAEb,yBAAyB,wFAA6B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0LAA0L;;AAE1L;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC,gBAAgB,YAAY;AAC5B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5CA,eAAe,mGAAmC;AAClD,eAAe,mBAAO,CAAC,qDAAU;AACjC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC;AACA,WAAW,wFAAgC;AAC3C,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;AChIA,iBAAiB,OAAuB,CAAC,mBAAmB;;;;;;;;;;;ACA/C;;AAEb,gBAAgB,mBAAO,CAAC,qGAAmC;AAC3D;;;;;;;;;;ACHA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,iEAA8B;AAC1C,YAAY,mBAAO,CAAC,uFAAO;AAC3B,UAAU,qDAAuB;AACjC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;;AAEA,UAAU,+HAAmC;AAC7C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;;AAEf;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qBAAqB;AAC3B;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,qHAAgC;;AAEhC;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA,EAAE,aAAa;AACf,EAAE,aAAa;AACf;AACA;AACA,kBAAkB,SAAS;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC7LA;AACA;AACA;AACA;;AAEA;AACA,EAAE,sIAAwC;AAC1C,EAAE;AACF,EAAE,gIAAqC;AACvC;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,UAAU,+HAAmC;AAC7C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;;AAEjB;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,uDAAuD,6DAA6D,oCAAoC;AACxJ;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,cAAI;AAC3B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACpOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9IA;AACA,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE,gHAAiD;AACnD;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1BA,iBAAiB,OAAuB,CAAC,mBAAmB;;;;;;;;;;ACA5D,iBAAiB,OAAuB,CAAC,mBAAmB;;;;;;;;;;;ACA/C;;AAEb;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB;;;;;;;;;;;AChDR;;AAEb;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc,GAAG,YAAY,GAAG,sBAAsB,GAAG,YAAY,GAAG,aAAa;AACrF;AACA;AACA,iBAAiB,gHAA4C;AAC7D,EAAE;AACF,iBAAiB,uGAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc,kCAAkC,mBAAO,CAAC,iFAA2B;;;;;;;;;;;ACnDtE;;AAEb;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;ACZZ;;AAEb;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,gBAAgB,GAAG,oBAAoB,GAAG,oBAAoB;AAC9D,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,sBAAsB,mBAAO,CAAC,qEAAiB;AAC/C,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;;;;;;;;;;;ACpNH;;AAEb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,iBAAiB,mBAAO,CAAC,2DAAY;AACrC,cAAc,mBAAO,CAAC,qDAAS;AAC/B;AACA;AACA;AACA,QAAQ,mBAAO,CAAC,iFAA2B;AAC3C;AACA,EAAE;AACF;AACA,UAAU,mBAAO,CAAC,sJAAyB;AAC3C;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM,WAAW;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;;;;;;;;;;AC9TY;;AAEb;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc;AACd;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,cAAc;;;;;;;;;;;ACtBD;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,wBAAwB;AACxB,uBAAuB,mBAAO,CAAC,sCAAgB;AAC/C,eAAe,mBAAO,CAAC,qEAAiB;AACxC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,sBAAsB,mBAAO,CAAC,qEAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,CAAC;AACD,wBAAwB;;;;;;;;;;;ACnNX;;AAEb;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,yBAAyB,GAAG,uBAAuB;AACnD,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,gBAAK;AACzB,sBAAsB,mBAAO,CAAC,oCAAe;AAC7C,gCAAgC,mBAAO,CAAC,yFAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,uFAA8B;AAC/D,UAAU;AACV;AACA,2BAA2B,mBAAO,CAAC,yJAA4B;AAC/D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,yBAAyB,mBAAO,CAAC,iFAA2B;AAC5D,UAAU;AACV;AACA,2BAA2B,mBAAO,CAAC,sJAAyB;AAC5D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtUa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,uBAAuB;AACvB,iBAAiB,mBAAO,CAAC,2DAAY;AACrC,wBAAwB,mBAAO,CAAC,yEAAmB;AACnD,cAAc,mBAAO,CAAC,qDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD,uBAAuB;;;;;;;;;;;ACzNV;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,EAAE,sCAAsC;AACtE,MAAM;AACN,uBAAuB,OAAO,EAAE,aAAa,KAAK,YAAY;AAC9D,MAAM;AACN,mBAAmB,OAAO,EAAE,YAAY;AACxC;AACA,IAAI;AACJ,iBAAiB,OAAO,EAAE,iBAAiB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM,EAAE,YAAY,EAAE,wBAAwB;AAC/D,IAAI;AACJ;AACA,kBAAkB,KAAK,IAAI,MAAM,EAAE,YAAY,EAAE,wBAAwB;AACzE;AACA,4BAA4B,cAAc;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB;;;;;;;;;;;ACxGpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,kFAAoB;AAC3C,eAAe,mBAAO,CAAC,kFAAoB;AAC3C,mBAAO,CAAC,qDAAU;AAClB;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;AC7HD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;AACA,gBAAgB,mBAAO,CAAC,oFAAqB;AAC7C,mBAAO,CAAC,qDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,0DAA8B;AACvC;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,gGAA2B;AAChD;;AAEA,aAAa,oDAAwB;AACrC,8IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,0GAAgC;AACzD,kBAAkB,mBAAO,CAAC,kGAA4B;AACtD,eAAe,mBAAO,CAAC,8FAA0B;AACjD;AACA,qBAAqB,wFAA0B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAO,CAAC,qDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,mFAAmF;AAC5J;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iHAAwC;AAChF;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,4FAA4F;AAC5F,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iHAAwC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAO,CAAC,gHAAmC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,mDAAmD,+DAA+D;AAClH;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,4FAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;;;;;;;;;;AClgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,qBAAqB,wFAA0B;AAC/C;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,8EAAkB;AACvC,mBAAO,CAAC,qDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,6DAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,gGAA2B;AAChD;;AAEA,aAAa,oDAAwB;AACrC,8IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,kGAA4B;AACtD,eAAe,mBAAO,CAAC,8FAA0B;AACjD;AACA,qBAAqB,wFAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAO,CAAC,qDAAU;AAClB;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sDAAsD;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;;;;;;;;;;AChoBa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,6FAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;AACA,yFAAyF;AACzF;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;AC5Ma;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;ACrPY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/FA;AACA;;AAEa;;AAEb,iCAAiC,8FAAgC;AACjE;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrFa;;AAEb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8FAAgC;AAC3D;AACA;AACA;AACA;AACA,IAAI,iGAAiG,uFAAuF;AAC5L;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3HA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8FAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+BAA+B,mBAAO,CAAC,6FAAiB;AACxD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,aAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;ACrFa;;AAEb,4BAA4B,8FAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrBA,4DAAkC;;;;;;;;;;ACAlC,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA;AACA,EAAE,qBAAqB;AACvB,EAAE;AACF,YAAY,+HAAqD;AACjE,EAAE,cAAc;AAChB,EAAE,gBAAgB;AAClB,EAAE,iIAAuD;AACzD,EAAE,2HAAmD;AACrD,EAAE,oIAAyD;AAC3D,EAAE,0IAA6D;AAC/D,EAAE,6JAAqE;AACvE,EAAE,mJAAgE;AAClE;;;;;;;;;;ACfA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,cAAc;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1DA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8CAAM;AAClB,WAAW,mBAAO,CAAC,wBAAS;AAC5B,eAAe,mBAAO,CAAC,4DAAe;AACtC;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,4BAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAS;AACrB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAa;AACzB;AACA;AACA,0DAA0D,YAAY;AACtE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB,KAAK,KAAK,EAAE,+BAA+B;AACxF,QAAQ;AACR,6BAA6B,gBAAgB,KAAK,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,MAAM;AACN,eAAe,KAAK,IAAI,IAAI;AAC5B;AACA,MAAM;AACN,eAAe,KAAK,IAAI,YAAY;AACpC;AACA,MAAM;AACN;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA,qBAAqB,KAAK,0CAA0C,YAAY;AAChF;AACA;AACA;AACA;AACA,qBAAqB,KAAK,IAAI,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB,GAAG,cAAc;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,oCAAoC,aAAa,EAAE,WAAW;AAC9D;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD,YAAY;AACZ,oCAAoC,aAAa,EAAE,MAAM;AACzD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,aAAa,SAAS;AACtB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,EAAE,WAAW;AAC9D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,yBAAyB;AACtC,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,EAAE,WAAW;AAC5D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA,iEAAiE,IAAI;AACrE;AACA;AACA;AACA,YAAY;AACZ,8CAA8C,IAAI,IAAI,mBAAmB;AACzE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kCAAkC,aAAa,EAAE,2CAA2C;AAC5F,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,UAAU,OAAO,SAAS,MAAM;AACjF;AACA,qBAAqB,OAAO,+BAA+B,MAAM;AACjE,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD,EAAE,WAAW;AACpF;AACA;AACA;AACA;AACA,yCAAyC,UAAU,IAAI,mBAAmB;AAC1E;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,SAAS,OAAO,UAAU,MAAM;AACjF;AACA,qBAAqB,OAAO,+BAA+B,MAAM;AACjE,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,IAAI,mBAAmB;AAC1E,QAAQ;AACR,yCAAyC,WAAW;AACpD;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa,EAAE,MAAM;AAC3E,SAAS;AACT;AACA,6CAA6C,MAAM;AACnD,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,uDAAuD,aAAa,EAAE,+CAA+C;AACrH,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,mBAAmB;AAC1E;AACA;AACA;AACA,MAAM;AACN,uDAAuD,UAAU;AACjE;AACA;;AAEA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,EAAE,MAAM;AACvD,SAAS;AACT;AACA,sCAAsC,MAAM;AAC5C,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD,YAAY;AACZ,8CAA8C,GAAG;AACjD,YAAY;AACZ,oCAAoC,aAAa,EAAE,EAAE;AACrD;AACA,UAAU;AACV,qBAAqB,GAAG;AACxB;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD,QAAQ;AACR,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,2CAA2C,KAAK;AAChD;AACA;AACA;AACA,MAAM;AACN,gDAAgD,aAAa,EAAE,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,6BAA6B,YAAY;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,EAAE,IAAI;AACvD;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK,GAAG,OAAO;AACnD;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,GAAG,OAAO;AAC9C;AACA;AACA;AACA,MAAM;AACN,gDAAgD,aAAa,EAAE,UAAU;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD,YAAY;AACZ,oCAAoC,aAAa,EAAE,WAAW;AAC9D;AACA;AACA,wCAAwC,WAAW;AACnD,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,QAAQ,OAAO,MAAM,MAAM;AAC5E;AACA,0CAA0C,OAAO,KAAK,MAAM;AAC5D,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,QAAQ,OAAO,MAAM,MAAM;AAC5E;AACA,6CAA6C,OAAO,KAAK,MAAM;AAC/D,SAAS;AACT;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,EAAE,MAAM;AACzD;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,GAAG,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,WAAW,EAAE,QAAQ,KAAK,OAAO;AAChE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU,GAAG,OAAO;AAC3C;AACA;AACA,gBAAgB,QAAQ,cAAc,OAAO;AAC7C,MAAM;AACN,gDAAgD,aAAa,EAAE,OAAO;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kDAAkD,OAAO,GAAG,UAAU;AACtE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI,IAAI,mBAAmB;AACtE,UAAU;AACV;AACA;AACA,WAAW;AACX,UAAU;AACV,2CAA2C,OAAO;AAClD;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,GAAG,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,WAAW,EAAE,QAAQ,KAAK,OAAO;AAChE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,GAAG,OAAO;AACxC;AACA;AACA;AACA,gBAAgB,QAAQ,gBAAgB,OAAO;AAC/C,MAAM;AACN,gDAAgD,YAAY,IAAI,OAAO;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,qBAAqB;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa,EAAE,QAAQ;AACvD,OAAO;AACP;AACA,gCAAgC,aAAa,EAAE,QAAQ;AACvD,OAAO;AACP;AACA,mBAAmB,SAAS,YAAY,QAAQ;AAChD,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;ACvzCA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,wBAAS;AACrB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,4BAAW;AACvB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,wEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,YAAY;AAClF;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM,yCAAyC,YAAY;AACpF;AACA;AACA,uBAAuB,MAAM,iCAAiC,YAAY;AAC1E;AACA,kCAAkC,KAAK,IAAI,YAAY;AACvD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,kCAAkC,KAAK;AACvC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,kCAAkC,KAAK;AACvC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,uBAAuB,KAAK,mCAAmC,YAAY;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK,GAAG,eAAe;AACvC,MAAM;AACN;AACA,gBAAgB,KAAK,GAAG,eAAe;AACvC;AACA;AACA,IAAI;AACJ,4CAA4C,YAAY;AACxD;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA,aAAa,SAAS;AACtB,YAAY;AACZ;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxXa;;AAEb;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8EAAyB;AACrC;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA,8BAA8B;;AAE9B;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,uEAAuE;AACrJ;AACA;AACA;AACA;AACA;AACA,sGAAsG,2DAA2D;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mBAAmB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc,GAAG,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,kBAAkB;AAC7F;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA,oEAAoE,kBAAkB;AACtF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,YAAY;AACrF;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA,WAAW;;AAEX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY;AACZ,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,sCAAsC,YAAY;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;;AAE7C;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qGAAqG,KAAK;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,SAAS;AACpF;AACA,QAAQ;AACR,oEAAoE,SAAS;AAC7E,QAAQ;AACR;AACA;AACA,sEAAsE,SAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,2DAA2D,eAAe;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,SAAS;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,kBAAkB;AACzF;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM,UAAU,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,8DAA8D,MAAM,eAAe,KAAK,KAAK,IAAI;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,SAAS,GAAG,SAAS;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS,GAAG,SAAS;AACjD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6EAA6E,SAAS,GAAG,SAAS;AAClG;AACA;AACA,mCAAmC,SAAS,GAAG,SAAS;AACxD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,WAAW;AACtF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM,iCAAiC,wDAAwD,QAAQ,iCAAiC;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,KAAK;AACnF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,GAAG,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,UAAU;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrnDa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kBAAM;AAClB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,oBAAO;AACnB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,gBAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAO,CAAC,sDAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ea;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,oDAAY;AACxB;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,gEAAkB;AAC9B;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8EAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,oEAAoB;AAChC;AACA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,sDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,sDAAa;AAC/B;AACA;AACA,OAAO,mBAAO,CAAC,sDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Ca;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8CAAM;AAClB,qBAAqB,uFAA6B;AAClD;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,wEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAyC;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,yCAAyC;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,wEAAwE;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB,EAAE,IAAI,EAAE,cAAc,QAAQ,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;;;;;;;;;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kBAAM;AAClB;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,+DAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,yDAAU;AACtB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B,yBAAyB,mBAAO,CAAC,mEAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,2DAAW;AACvB,mBAAmB,2FAAqC;AACxD;AACA,+CAA+C,WAAW;AAC1D,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+EAA+E,gBAAgB;AAC/F;;AAEA;AACA;AACA;AACA,+EAA+E,cAAc;AAC7F;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6EAA6E,KAAK,IAAI,OAAO;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,oEAAoE,KAAK,IAAI,QAAQ;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,6EAA6E,KAAK;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO,MAAM,MAAM;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC,4EAA4E,OAAO;AACnF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA,+FAA+F;AAC/F;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC,MAAM;AACN;AACA;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uEAAuE,KAAK,UAAU,IAAI;AAC1F;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,YAAY,OAAO;AAC/F;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uEAAuE,KAAK,SAAS,IAAI,GAAG,IAAI;AAChG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,gDAAgD;AAChD;AACA,uEAAuE,KAAK;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,eAAe,KAAK;AAChG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,iBAAiB,OAAO;AACpG;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0FAA0F,WAAW;AACrG;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,iBAAiB,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACv7Ca;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,WAAW,mBAAO,CAAC,cAAI;AACvB;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kBAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gBAAgB;AAChB,cAAc;AACd,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,wBAAwB,IAAI;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,KAAK;AAC9E;AACA;AACA,gGAAgG,KAAK;AACrG,UAAU;AACV,wEAAwE,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,YAAY,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,uFAAuF,SAAS;;AAEhG;AACA;AACA,gBAAgB;AAChB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,uGAAuG,iBAAiB;AACxH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,iBAAiB;AAC3C;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA,2EAA2E,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAsD;AAChG;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,kDAAkD,qCAAqC;AACvF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qCAAqC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,+CAA+C;AAC/C,6CAA6C;AAC7C,0CAA0C;AAC1C,wCAAwC;AACxC,qCAAqC;AACrC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,SAAS,MAAM;AAChF,QAAQ;AACR,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,MAAM,IAAI,UAAU,IAAI,QAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yEAAyE,MAAM,IAAI,GAAG;AACtF;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,yEAAyE,MAAM,IAAI,YAAY;AAC/F;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,uEAAuE,MAAM,IAAI,GAAG;AACpF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uEAAuE,MAAM,IAAI,aAAa;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,MAAM,IAAI,aAAa;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,MAAM,IAAI,aAAa;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA,+EAA+E,MAAM,IAAI,aAAa;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,MAAM;AAC3F;AACA;AACA;AACA;AACA,QAAQ;AACR,iFAAiF,MAAM;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ,SAAS,MAAM;AAC7E,QAAQ;AACR,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,4EAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0CAA0C;AAC1C;AACA,IAAI,kIAAkI;;AAEtI;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,IAAI,kIAAkI;;AAEtI;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxlGa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA,YAAY,mBAAO,CAAC,8DAAc;AAClC,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,+DAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG,KAAK;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,CAAC,KAAK;;;;;;;;;;;AC3UN;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,mHAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAO,CAAC,iFAAsB;AACnE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;ACxqCA,iBAAiB,OAAuB,CAAC,mBAAmB;;;;;;;;;;ACA5D;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAuB;AAC1C;AACA;AACA,gBAAgB,mBAAO,CAAC,cAAI;AAC5B,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,mBAAO,CAAC,cAAI;AAC5B,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE,gFAAgF;AAChF,2BAA2B,MAAM;AACjC;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,aAAa,aAAa;AAC1B;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,sBAAsB,cAAc;AACpC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,iBAAiB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,gBAAgB;AACrG;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,qFAAqF,qBAAqB;AAC1G;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAyD,kCAAkC,KAAK;;;;;;;;;;;AC5bvF;;AAEb;AACA,CAAC,yFAA4B,EAAE,mBAAO,CAAC,6EAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;ACVa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B;AACA;AACA;AACA,CAAC,KAAK;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO,KAAK,KAAK;AACjF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,MAAM;AAC/E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,WAAW;AACjF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,YAAY;AAClF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA,sDAAsD,4BAA4B;AAClF,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO,IAAI,KAAK;AAC3E;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,UAAU,MAAM,OAAO;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,UAAU;AAC7E;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,WAAW;AAC7F;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU,IAAI,YAAY;AACrF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,YAAY;AAC9F;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,KAAK,IAAI,KAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU,IAAI,KAAK,IAAI,OAAO;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU,IAAI,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU,IAAI,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU,IAAI,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU,IAAI,KAAK,SAAS,KAAK,GAAG,MAAM;AACnG;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,oEAAoE,UAAU,IAAI,KAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,KAAK,IAAI,KAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,KAAK,IAAI,KAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,KAAK,IAAI,KAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,KAAK,IAAI,KAAK;AAChG;AACA;AACA;AACA,uBAAuB;AACvB,oEAAoE,UAAU,IAAI,KAAK;AACvF;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,KAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;;;;;;;;;;;ACjmCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,+DAAa;AACzB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAY;AACxB;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,2DAAW;AACvB;AACA,2BAA2B;AAC3B,2BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,SAAS;AAC5D,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mEAAmE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,gBAAgB;AACxE,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,mEAAmE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;;AAE9D;AACA;AACA,oDAAoD,cAAc;AAClE,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,mEAAmE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;;AAE1D;AACA;AACA,oDAAoD,cAAc;AAClE,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,mEAAmE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;;AAE1D;AACA;AACA,iDAAiD,WAAW;AAC5D,kDAAkD,cAAc;AAChE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;;AAEA;AACA;AACA,iDAAiD,WAAW;AAC5D,kDAAkD,cAAc;AAChE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;;AAEA;AACA;AACA,yDAAyD,gBAAgB;AACzE,0DAA0D,mBAAmB;AAC7E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,mEAAmE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;;AAE/D;AACA;AACA,yDAAyD,gBAAgB;AACzE,0DAA0D,mBAAmB;AAC7E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc,mEAAmE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU,KAAK,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ,mBAAmB,yBAAyB;AAC3H;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,oBAAoB,YAAY,kBAAkB;AAC1J;AACA;AACA;AACA,wGAAwG,oBAAoB;AAC5H;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;;AAEA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM,aAAa,mBAAmB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,qEAAqE,MAAM,aAAa,oBAAoB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM,aAAa,gBAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,MAAM;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM,aAAa,wBAAwB;AAChH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM,aAAa,uBAAuB;AAC/G;AACA;AACA;AACA,YAAY;AACZ,mEAAmE,MAAM,aAAa,wBAAwB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA,kDAAkD,QAAQ;AAC1D;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,oBAAoB,OAAO,GAAG,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ,6CAA6C,KAAK,WAAW,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc;AACjG;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAO,CAAC,mEAAe;AACzE;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAO,CAAC,mEAAe;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;ACr3CA;AACA;AACA;AACA;AACa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8CAAM;AAClB,qBAAqB,uFAA6B;AAClD;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,+DAAa;AACzB;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,qEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,6DAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA,uBAAuB,MAAM,YAAY,UAAU,WAAW,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,MAAM;AAC/F;AACA;AACA,sIAAsI,WAAW;AACjJ;AACA;AACA;AACA;AACA,0FAA0F,QAAQ;AAClG;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,KAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,+BAA+B;AAC/B,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,MAAM;AAC5E;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oKAAoK;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,SAAS;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,6EAA6E;AAC7E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjsCa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kBAAM;;AAElB;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB,kBAAkB,oBAAoB,EAAE,IAAI;AACrE,YAAY,gBAAgB,EAAE,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,EAAE,sCAAsC;AACtE,MAAM;AACN,uBAAuB,OAAO,EAAE,aAAa,KAAK,YAAY;AAC9D;AACA,iBAAiB,OAAO,EAAE,YAAY;AACtC;AACA,eAAe,OAAO,EAAE,iBAAiB;AACzC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,uDAAuD,QAAQ,IAAI,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,0BAA0B,MAAM,aAAa,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,EAAE,YAAY,EAAE,wBAAwB;AACjE,MAAM;AACN;AACA,oBAAoB,KAAK,IAAI,MAAM,EAAE,YAAY,EAAE,wBAAwB;AAC3E;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA,4BAA4B;AAC5B,sBAAsB;AACtB;AACA;;;;;;;;;;;AC7Fa;;AAEb,YAAY,yEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D;AACA,qDAAqD,+BAA+B;AACpF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE,mBAAO,CAAC,qEAAgB;AAChC;AACA;AACA;AACA,+EAA+E;AAC/E,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjSa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sBAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kBAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAA8D;AAClG;AACA;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,gBAAK;AACjB,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8EAAyB;AACrC;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,wEAAsB;AAClC;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kEAAmB;AAC/B;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,8EAAyB;AACrC,iBAAiB,mBAAO,CAAC,4EAAwB;AACjD;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,oEAAoB;AAChC;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,sEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,wDAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,oDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,iHAAiH;AACjH,mFAAmF,mBAAmB;AACtG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA,uBAAuB,YAAY,EAAE,IAAI;AACzC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,UAAU;AACvG;AACA;AACA;AACA;AACA;AACA,yFAAyF,UAAU;AACnG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA,qBAAqB;AACrB,4DAA4D,KAAK,GAAG,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,6EAA6E,KAAK;AAClF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACzkChB;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,oEAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mDAAmD,iBAAiB;AACpE;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,GAAG;AAC1H;AACA;AACA;AACA,uHAAuH,GAAG;AAC1H;AACA;AACA;AACA,uHAAuH,GAAG;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,+FAA+F,YAAY;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA,oGAAoG,OAAO;AAC3G;AACA;AACA,gBAAgB;AAChB,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,qGAAqG,QAAQ;AAC7G;AACA;AACA,gBAAgB;AAChB,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,aAAa,sFAA6B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC3SA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,OAAO;AACP,MAAM,SAAS,IAA8B;AAC7C;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH,CAAC,EAAE,KAA6B,iEAAiE;;;;;;;;;;AC9yEjG,wBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,GAAG;AACrB;AACA;AACA;AACA,kBAAkB,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,GAAG;AAC5B;AACA,gBAAgB,GAAG;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA,EAAE,mBAAmB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,4BAA4B;AACpG;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,4BAA4B;AACpG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA,UAAU;AACV,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,iBAAiB;AACnB,EAAE,kBAAkB;AACpB,EAAE,yBAAyB;AAC3B,EAAE,kBAAkB;AACpB,EAAE,mBAAmB;AACrB,EAAE,kBAAkB;AACpB,EAAE,mBAAmB;AACrB,EAAE,oBAAoB;AACtB,EAAE,oBAAoB;AACtB,CAAC;;AAED;AACA;A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","sources":["webpack://simpleshell/./node_modules/asn1/lib/ber/errors.js","webpack://simpleshell/./node_modules/asn1/lib/ber/index.js","webpack://simpleshell/./node_modules/asn1/lib/ber/reader.js","webpack://simpleshell/./node_modules/asn1/lib/ber/types.js","webpack://simpleshell/./node_modules/asn1/lib/ber/writer.js","webpack://simpleshell/./node_modules/asn1/lib/index.js","webpack://simpleshell/./node_modules/bcrypt-pbkdf/index.js","webpack://simpleshell/./node_modules/buffer-from/index.js","webpack://simpleshell/./node_modules/concat-stream/index.js","webpack://simpleshell/./node_modules/cpu-features/build/Release/cpufeatures.node","webpack://simpleshell/./node_modules/cpu-features/lib/index.js","webpack://simpleshell/./node_modules/electron-squirrel-startup/index.js","webpack://simpleshell/./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js","webpack://simpleshell/./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js","webpack://simpleshell/./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js","webpack://simpleshell/./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js","webpack://simpleshell/./node_modules/electron-squirrel-startup/node_modules/ms/index.js","webpack://simpleshell/./node_modules/inherits/inherits.js","webpack://simpleshell/./node_modules/inherits/inherits_browser.js","webpack://simpleshell/./node_modules/node-pty/build/Release/conpty.node","webpack://simpleshell/./node_modules/node-pty/build/Release/pty.node","webpack://simpleshell/./node_modules/node-pty/lib/eventEmitter2.js","webpack://simpleshell/./node_modules/node-pty/lib/index.js","webpack://simpleshell/./node_modules/node-pty/lib/shared/conout.js","webpack://simpleshell/./node_modules/node-pty/lib/terminal.js","webpack://simpleshell/./node_modules/node-pty/lib/unixTerminal.js","webpack://simpleshell/./node_modules/node-pty/lib/utils.js","webpack://simpleshell/./node_modules/node-pty/lib/windowsConoutConnection.js","webpack://simpleshell/./node_modules/node-pty/lib/windowsPtyAgent.js","webpack://simpleshell/./node_modules/node-pty/lib/windowsTerminal.js","webpack://simpleshell/./node_modules/readable-stream/errors.js","webpack://simpleshell/./node_modules/readable-stream/lib/_stream_duplex.js","webpack://simpleshell/./node_modules/readable-stream/lib/_stream_passthrough.js","webpack://simpleshell/./node_modules/readable-stream/lib/_stream_readable.js","webpack://simpleshell/./node_modules/readable-stream/lib/_stream_transform.js","webpack://simpleshell/./node_modules/readable-stream/lib/_stream_writable.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/async_iterator.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/buffer_list.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/from.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/pipeline.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/state.js","webpack://simpleshell/./node_modules/readable-stream/lib/internal/streams/stream.js","webpack://simpleshell/./node_modules/readable-stream/readable.js","webpack://simpleshell/./node_modules/safe-buffer/index.js","webpack://simpleshell/./node_modules/safer-buffer/safer.js","webpack://simpleshell/./node_modules/ssh2-sftp-client/src/constants.js","webpack://simpleshell/./node_modules/ssh2-sftp-client/src/index.js","webpack://simpleshell/./node_modules/ssh2-sftp-client/src/utils.js","webpack://simpleshell/./node_modules/ssh2/lib/Channel.js","webpack://simpleshell/./node_modules/ssh2/lib/agent.js","webpack://simpleshell/./node_modules/ssh2/lib/client.js","webpack://simpleshell/./node_modules/ssh2/lib/http-agents.js","webpack://simpleshell/./node_modules/ssh2/lib/index.js","webpack://simpleshell/./node_modules/ssh2/lib/keygen.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/Protocol.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/SFTP.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/constants.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/crypto.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node","webpack://simpleshell/./node_modules/ssh2/lib/protocol/crypto/poly1305.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/handlers.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/handlers.misc.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/kex.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/keyParser.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/node-fs-compat.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/utils.js","webpack://simpleshell/./node_modules/ssh2/lib/protocol/zlib.js","webpack://simpleshell/./node_modules/ssh2/lib/server.js","webpack://simpleshell/./node_modules/ssh2/lib/utils.js","webpack://simpleshell/./node_modules/string_decoder/lib/string_decoder.js","webpack://simpleshell/./node_modules/tweetnacl/nacl-fast.js","webpack://simpleshell/./node_modules/typedarray/index.js","webpack://simpleshell/./node_modules/util-deprecate/node.js","webpack://simpleshell/external node-commonjs \"assert\"","webpack://simpleshell/external node-commonjs \"buffer\"","webpack://simpleshell/external node-commonjs \"child_process\"","webpack://simpleshell/external node-commonjs \"crypto\"","webpack://simpleshell/external node-commonjs \"dns\"","webpack://simpleshell/external node-commonjs \"electron\"","webpack://simpleshell/external node-commonjs \"events\"","webpack://simpleshell/external node-commonjs \"fs\"","webpack://simpleshell/external node-commonjs \"http\"","webpack://simpleshell/external node-commonjs \"https\"","webpack://simpleshell/external node-commonjs \"net\"","webpack://simpleshell/external node-commonjs \"node:fs\"","webpack://simpleshell/external node-commonjs \"node:path\"","webpack://simpleshell/external node-commonjs \"os\"","webpack://simpleshell/external node-commonjs \"path\"","webpack://simpleshell/external node-commonjs \"stream\"","webpack://simpleshell/external node-commonjs \"tls\"","webpack://simpleshell/external node-commonjs \"tty\"","webpack://simpleshell/external node-commonjs \"util\"","webpack://simpleshell/external node-commonjs \"worker_threads\"","webpack://simpleshell/external node-commonjs \"zlib\"","webpack://simpleshell/webpack/bootstrap","webpack://simpleshell/./src/main.js"],"sourcesContent":["// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nmodule.exports = {\n  newInvalidAsn1Error: function (msg) {\n    var e = new Error();\n    e.name = 'InvalidAsn1Error';\n    e.message = msg || '';\n    return e;\n  }\n};","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar errors = require('./errors');\nvar types = require('./types');\nvar Reader = require('./reader');\nvar Writer = require('./writer');\n\n// --- Exports\n\nmodule.exports = {\n  Reader: Reader,\n  Writer: Writer\n};\nfor (var t in types) {\n  if (types.hasOwnProperty(t)) module.exports[t] = types[t];\n}\nfor (var e in errors) {\n  if (errors.hasOwnProperty(e)) module.exports[e] = errors[e];\n}","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n// --- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data)) throw new TypeError('data must be a node Buffer');\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n}\nObject.defineProperty(Reader.prototype, 'length', {\n  enumerable: true,\n  get: function () {\n    return this._len;\n  }\n});\nObject.defineProperty(Reader.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    return this._offset;\n  }\n});\nObject.defineProperty(Reader.prototype, 'remain', {\n  get: function () {\n    return this._size - this._offset;\n  }\n});\nObject.defineProperty(Reader.prototype, 'buffer', {\n  get: function () {\n    return this._buf.slice(this._offset);\n  }\n});\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1) return null;\n  var b = this._buf[this._offset] & 0xff;\n  if (!peek) this._offset += 1;\n  return b;\n};\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined) offset = this._offset;\n  if (offset >= this._size) return null;\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null) return null;\n  if ((lenB & 0x80) === 0x80) {\n    lenB &= 0x7f;\n    if (lenB === 0) throw newInvalidAsn1Error('Indefinite length not supported');\n    if (lenB > 4) throw newInvalidAsn1Error('encoding too long');\n    if (this._size - offset < lenB) return null;\n    this._len = 0;\n    for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n  return offset;\n};\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null) return null;\n  if (tag !== undefined && tag !== seq) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + seq.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null) return null;\n  this._offset = o;\n  return seq;\n};\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\nReader.prototype.readBoolean = function () {\n  return this._readTag(ASN1.Boolean) === 0 ? false : true;\n};\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag) tag = ASN1.OctetString;\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null) return null;\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  if (this.length === 0) return retbuf ? Buffer.alloc(0) : '';\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n  return retbuf ? str : str.toString('utf8');\n};\nReader.prototype.readOID = function (tag) {\n  if (!tag) tag = ASN1.OID;\n  var b = this.readString(tag, true);\n  if (b === null) return null;\n  var values = [];\n  var value = 0;\n  for (var i = 0; i < b.length; i++) {\n    var byte = b[i] & 0xff;\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) === 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift(value / 40 >> 0);\n  return values.join('.');\n};\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null) return null;\n  if (this.length > 4) throw newInvalidAsn1Error('Integer too long: ' + this.length);\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  var fb = this._buf[this._offset];\n  var value = 0;\n  for (var i = 0; i < this.length; i++) {\n    value <<= 8;\n    value |= this._buf[this._offset++] & 0xff;\n  }\n  if ((fb & 0x80) === 0x80 && i !== 4) value -= 1 << i * 8;\n  return value >> 0;\n};\n\n// --- Exported API\n\nmodule.exports = Reader;","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nmodule.exports = {\n  EOC: 0,\n  Boolean: 1,\n  Integer: 2,\n  BitString: 3,\n  OctetString: 4,\n  Null: 5,\n  OID: 6,\n  ObjectDescriptor: 7,\n  External: 8,\n  Real: 9,\n  // float\n  Enumeration: 10,\n  PDV: 11,\n  Utf8String: 12,\n  RelativeOID: 13,\n  Sequence: 16,\n  Set: 17,\n  NumericString: 18,\n  PrintableString: 19,\n  T61String: 20,\n  VideotexString: 21,\n  IA5String: 22,\n  UTCTime: 23,\n  GeneralizedTime: 24,\n  GraphicString: 25,\n  VisibleString: 26,\n  GeneralString: 28,\n  UniversalString: 29,\n  CharacterString: 30,\n  BMPString: 31,\n  Constructor: 32,\n  Context: 128\n};","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof from, 'object');\n  assert.ok(to);\n  assert.equal(typeof to, 'object');\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key]) return;\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n  return to;\n}\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length) throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n    return this._buf.slice(0, this._offset);\n  }\n});\nWriter.prototype.writeByte = function (b) {\n  if (typeof b !== 'number') throw new TypeError('argument must be a Number');\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof i !== 'number') throw new TypeError('argument must be a Number');\n  if (typeof tag !== 'number') tag = ASN1.Integer;\n  var sz = 4;\n  while (((i & 0xff800000) === 0 || (i & 0xff800000) === 0xff800000 >> 0) && sz > 1) {\n    sz--;\n    i <<= 8;\n  }\n  if (sz > 4) throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n  while (sz-- > 0) {\n    this._buf[this._offset++] = (i & 0xff000000) >>> 24;\n    i <<= 8;\n  }\n};\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof i !== 'number') throw new TypeError('argument must be a Number');\n  if (typeof tag !== 'number') tag = ASN1.Enumeration;\n  return this.writeInt(i, tag);\n};\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof b !== 'boolean') throw new TypeError('argument must be a Boolean');\n  if (typeof tag !== 'number') tag = ASN1.Boolean;\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof s !== 'string') throw new TypeError('argument must be a string (was: ' + typeof s + ')');\n  if (typeof tag !== 'number') tag = ASN1.OctetString;\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof tag !== 'number') throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf)) throw new TypeError('argument must be a buffer');\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\nWriter.prototype.writeStringArray = function (strings) {\n  if (!strings instanceof Array) throw new TypeError('argument must be an Array[String]');\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof s !== 'string') throw new TypeError('argument must be a string');\n  if (typeof tag !== 'number') tag = ASN1.OID;\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s)) throw new Error('argument is not a valid OID string');\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n      bytes.push(octet);\n    } else if (octet < 16384) {\n      bytes.push(octet >>> 7 | 0x80);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push(octet >>> 14 | 0x80);\n      bytes.push((octet >>> 7 | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push(octet >>> 21 | 0x80);\n      bytes.push((octet >>> 14 | 0x80) & 0xFF);\n      bytes.push((octet >>> 7 | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push((octet >>> 28 | 0x80) & 0xFF);\n      bytes.push((octet >>> 21 | 0x80) & 0xFF);\n      bytes.push((octet >>> 14 | 0x80) & 0xFF);\n      bytes.push((octet >>> 7 | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\nWriter.prototype.writeLength = function (len) {\n  if (typeof len !== 'number') throw new TypeError('argument must be a Number');\n  this._ensure(4);\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\nWriter.prototype.startSequence = function (tag) {\n  if (typeof tag !== 'number') tag = ASN1.Sequence | ASN1.Constructor;\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len) sz += len;\n    var buf = Buffer.alloc(sz);\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n// --- Exported API\n\nmodule.exports = Writer;","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n// If you have no idea what ASN.1 or BER is, see this:\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\n\nvar Ber = require('./ber/index');\n\n// --- Exported API\n\nmodule.exports = {\n  Ber: Ber,\n  BerReader: Ber.Reader,\n  BerWriter: Ber.Writer\n};","'use strict';\n\nvar crypto_hash_sha512 = require('tweetnacl').lowlevel.crypto_hash;\n\n/*\n * This file is a 1:1 port from the OpenBSD blowfish.c and bcrypt_pbkdf.c. As a\n * result, it retains the original copyright and license. The two files are\n * under slightly different (but compatible) licenses, and are here combined in\n * one file.\n *\n * Credit for the actual porting work goes to:\n *  Devi Mandiri <me@devi.web.id>\n */\n\n/*\n * The Blowfish portions are under the following license:\n *\n * Blowfish block cipher for OpenBSD\n * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>\n * All rights reserved.\n *\n * Implementation advice by David Mazieres <dm@lcs.mit.edu>.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * The bcrypt_pbkdf portions are under the following license:\n *\n * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Performance improvements (Javascript-specific):\n *\n * Copyright 2016, Joyent Inc\n * Author: Alex Wilson <alex.wilson@joyent.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n// Ported from OpenBSD bcrypt_pbkdf.c v1.9\n\nvar BLF_J = 0;\nvar Blowfish = function () {\n  this.S = [new Uint32Array([0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463, 0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915, 0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]), new Uint32Array([0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]), new Uint32Array([0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]), new Uint32Array([0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6])];\n  this.P = new Uint32Array([0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b]);\n};\nfunction F(S, x8, i) {\n  return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];\n}\n;\nBlowfish.prototype.encipher = function (x, x8) {\n  if (x8 === undefined) {\n    x8 = new Uint8Array(x.buffer);\n    if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);\n  }\n  x[0] ^= this.P[0];\n  for (var i = 1; i < 16; i += 2) {\n    x[1] ^= F(this.S, x8, 0) ^ this.P[i];\n    x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];\n  }\n  var t = x[0];\n  x[0] = x[1] ^ this.P[17];\n  x[1] = t;\n};\nBlowfish.prototype.decipher = function (x) {\n  var x8 = new Uint8Array(x.buffer);\n  if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);\n  x[0] ^= this.P[17];\n  for (var i = 16; i > 0; i -= 2) {\n    x[1] ^= F(this.S, x8, 0) ^ this.P[i];\n    x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];\n  }\n  var t = x[0];\n  x[0] = x[1] ^ this.P[0];\n  x[1] = t;\n};\nfunction stream2word(data, databytes) {\n  var i,\n    temp = 0;\n  for (i = 0; i < 4; i++, BLF_J++) {\n    if (BLF_J >= databytes) BLF_J = 0;\n    temp = temp << 8 | data[BLF_J];\n  }\n  return temp;\n}\n;\nBlowfish.prototype.expand0state = function (key, keybytes) {\n  var d = new Uint32Array(2),\n    i,\n    k;\n  var d8 = new Uint8Array(d.buffer);\n  for (i = 0, BLF_J = 0; i < 18; i++) {\n    this.P[i] ^= stream2word(key, keybytes);\n  }\n  BLF_J = 0;\n  for (i = 0; i < 18; i += 2) {\n    this.encipher(d, d8);\n    this.P[i] = d[0];\n    this.P[i + 1] = d[1];\n  }\n  for (i = 0; i < 4; i++) {\n    for (k = 0; k < 256; k += 2) {\n      this.encipher(d, d8);\n      this.S[i][k] = d[0];\n      this.S[i][k + 1] = d[1];\n    }\n  }\n};\nBlowfish.prototype.expandstate = function (data, databytes, key, keybytes) {\n  var d = new Uint32Array(2),\n    i,\n    k;\n  for (i = 0, BLF_J = 0; i < 18; i++) {\n    this.P[i] ^= stream2word(key, keybytes);\n  }\n  for (i = 0, BLF_J = 0; i < 18; i += 2) {\n    d[0] ^= stream2word(data, databytes);\n    d[1] ^= stream2word(data, databytes);\n    this.encipher(d);\n    this.P[i] = d[0];\n    this.P[i + 1] = d[1];\n  }\n  for (i = 0; i < 4; i++) {\n    for (k = 0; k < 256; k += 2) {\n      d[0] ^= stream2word(data, databytes);\n      d[1] ^= stream2word(data, databytes);\n      this.encipher(d);\n      this.S[i][k] = d[0];\n      this.S[i][k + 1] = d[1];\n    }\n  }\n  BLF_J = 0;\n};\nBlowfish.prototype.enc = function (data, blocks) {\n  for (var i = 0; i < blocks; i++) {\n    this.encipher(data.subarray(i * 2));\n  }\n};\nBlowfish.prototype.dec = function (data, blocks) {\n  for (var i = 0; i < blocks; i++) {\n    this.decipher(data.subarray(i * 2));\n  }\n};\nvar BCRYPT_BLOCKS = 8,\n  BCRYPT_HASHSIZE = 32;\nfunction bcrypt_hash(sha2pass, sha2salt, out) {\n  var state = new Blowfish(),\n    cdata = new Uint32Array(BCRYPT_BLOCKS),\n    i,\n    ciphertext = new Uint8Array([79, 120, 121, 99, 104, 114, 111, 109, 97, 116, 105, 99, 66, 108, 111, 119, 102, 105, 115, 104, 83, 119, 97, 116, 68, 121, 110, 97, 109, 105, 116, 101]); //\"OxychromaticBlowfishSwatDynamite\"\n\n  state.expandstate(sha2salt, 64, sha2pass, 64);\n  for (i = 0; i < 64; i++) {\n    state.expand0state(sha2salt, 64);\n    state.expand0state(sha2pass, 64);\n  }\n  for (i = 0; i < BCRYPT_BLOCKS; i++) cdata[i] = stream2word(ciphertext, ciphertext.byteLength);\n  for (i = 0; i < 64; i++) state.enc(cdata, cdata.byteLength / 8);\n  for (i = 0; i < BCRYPT_BLOCKS; i++) {\n    out[4 * i + 3] = cdata[i] >>> 24;\n    out[4 * i + 2] = cdata[i] >>> 16;\n    out[4 * i + 1] = cdata[i] >>> 8;\n    out[4 * i + 0] = cdata[i];\n  }\n}\n;\nfunction bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {\n  var sha2pass = new Uint8Array(64),\n    sha2salt = new Uint8Array(64),\n    out = new Uint8Array(BCRYPT_HASHSIZE),\n    tmpout = new Uint8Array(BCRYPT_HASHSIZE),\n    countsalt = new Uint8Array(saltlen + 4),\n    i,\n    j,\n    amt,\n    stride,\n    dest,\n    count,\n    origkeylen = keylen;\n  if (rounds < 1) return -1;\n  if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20) return -1;\n  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);\n  amt = Math.floor((keylen + stride - 1) / stride);\n  for (i = 0; i < saltlen; i++) countsalt[i] = salt[i];\n  crypto_hash_sha512(sha2pass, pass, passlen);\n  for (count = 1; keylen > 0; count++) {\n    countsalt[saltlen + 0] = count >>> 24;\n    countsalt[saltlen + 1] = count >>> 16;\n    countsalt[saltlen + 2] = count >>> 8;\n    countsalt[saltlen + 3] = count;\n    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n    bcrypt_hash(sha2pass, sha2salt, tmpout);\n    for (i = out.byteLength; i--;) out[i] = tmpout[i];\n    for (i = 1; i < rounds; i++) {\n      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);\n      bcrypt_hash(sha2pass, sha2salt, tmpout);\n      for (j = 0; j < out.byteLength; j++) out[j] ^= tmpout[j];\n    }\n    amt = Math.min(amt, keylen);\n    for (i = 0; i < amt; i++) {\n      dest = i * stride + (count - 1);\n      if (dest >= origkeylen) break;\n      key[dest] = out[i];\n    }\n    keylen -= i;\n  }\n  return 0;\n}\n;\nmodule.exports = {\n  BLOCKS: BCRYPT_BLOCKS,\n  HASHSIZE: BCRYPT_HASHSIZE,\n  hash: bcrypt_hash,\n  pbkdf: bcrypt_pbkdf\n};","/* eslint-disable node/no-deprecated-api */\n\nvar toString = Object.prototype.toString;\nvar isModern = typeof Buffer !== 'undefined' && typeof Buffer.alloc === 'function' && typeof Buffer.allocUnsafe === 'function' && typeof Buffer.from === 'function';\nfunction isArrayBuffer(input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer';\n}\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  byteOffset >>>= 0;\n  var maxLength = obj.byteLength - byteOffset;\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\");\n  }\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    length >>>= 0;\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\");\n    }\n  }\n  return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));\n}\nfunction fromString(string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n  return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);\n}\nfunction bufferFrom(value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  }\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset);\n  }\n  return isModern ? Buffer.from(value) : new Buffer(value);\n}\nmodule.exports = bufferFrom;","var Writable = require('readable-stream').Writable;\nvar inherits = require('inherits');\nvar bufferFrom = require('buffer-from');\nif (typeof Uint8Array === 'undefined') {\n  var U8 = require('typedarray').Uint8Array;\n} else {\n  var U8 = Uint8Array;\n}\nfunction ConcatStream(opts, cb) {\n  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb);\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (!opts) opts = {};\n  var encoding = opts.encoding;\n  var shouldInferEncoding = false;\n  if (!encoding) {\n    shouldInferEncoding = true;\n  } else {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'u8' || encoding === 'uint8') {\n      encoding = 'uint8array';\n    }\n  }\n  Writable.call(this, {\n    objectMode: true\n  });\n  this.encoding = encoding;\n  this.shouldInferEncoding = shouldInferEncoding;\n  if (cb) this.on('finish', function () {\n    cb(this.getBody());\n  });\n  this.body = [];\n}\nmodule.exports = ConcatStream;\ninherits(ConcatStream, Writable);\nConcatStream.prototype._write = function (chunk, enc, next) {\n  this.body.push(chunk);\n  next();\n};\nConcatStream.prototype.inferEncoding = function (buff) {\n  var firstBuffer = buff === undefined ? this.body[0] : buff;\n  if (Buffer.isBuffer(firstBuffer)) return 'buffer';\n  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array';\n  if (Array.isArray(firstBuffer)) return 'array';\n  if (typeof firstBuffer === 'string') return 'string';\n  if (Object.prototype.toString.call(firstBuffer) === \"[object Object]\") return 'object';\n  return 'buffer';\n};\nConcatStream.prototype.getBody = function () {\n  if (!this.encoding && this.body.length === 0) return [];\n  if (this.shouldInferEncoding) this.encoding = this.inferEncoding();\n  if (this.encoding === 'array') return arrayConcat(this.body);\n  if (this.encoding === 'string') return stringConcat(this.body);\n  if (this.encoding === 'buffer') return bufferConcat(this.body);\n  if (this.encoding === 'uint8array') return u8Concat(this.body);\n  return this.body;\n};\nvar isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\nfunction isArrayish(arr) {\n  return /Array\\]$/.test(Object.prototype.toString.call(arr));\n}\nfunction isBufferish(p) {\n  return typeof p === 'string' || isArrayish(p) || p && typeof p.subarray === 'function';\n}\nfunction stringConcat(parts) {\n  var strings = [];\n  var needsToString = false;\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i];\n    if (typeof p === 'string') {\n      strings.push(p);\n    } else if (Buffer.isBuffer(p)) {\n      strings.push(p);\n    } else if (isBufferish(p)) {\n      strings.push(bufferFrom(p));\n    } else {\n      strings.push(bufferFrom(String(p)));\n    }\n  }\n  if (Buffer.isBuffer(parts[0])) {\n    strings = Buffer.concat(strings);\n    strings = strings.toString('utf8');\n  } else {\n    strings = strings.join('');\n  }\n  return strings;\n}\nfunction bufferConcat(parts) {\n  var bufs = [];\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i];\n    if (Buffer.isBuffer(p)) {\n      bufs.push(p);\n    } else if (isBufferish(p)) {\n      bufs.push(bufferFrom(p));\n    } else {\n      bufs.push(bufferFrom(String(p)));\n    }\n  }\n  return Buffer.concat(bufs);\n}\nfunction arrayConcat(parts) {\n  var res = [];\n  for (var i = 0; i < parts.length; i++) {\n    res.push.apply(res, parts[i]);\n  }\n  return res;\n}\nfunction u8Concat(parts) {\n  var len = 0;\n  for (var i = 0; i < parts.length; i++) {\n    if (typeof parts[i] === 'string') {\n      parts[i] = bufferFrom(parts[i]);\n    }\n    len += parts[i].length;\n  }\n  var u8 = new U8(len);\n  for (var i = 0, offset = 0; i < parts.length; i++) {\n    var part = parts[i];\n    for (var j = 0; j < part.length; j++) {\n      u8[offset++] = part[j];\n    }\n  }\n  return u8;\n}","module.exports = __non_webpack_require__(__webpack_require__.ab + \"build/Release/cpufeatures.node\")","'use strict';\n\nconst binding = require('../build/Release/cpufeatures.node');\nmodule.exports = binding.getCPUInfo;","var path = require('path');\nvar spawn = require('child_process').spawn;\nvar debug = require('debug')('electron-squirrel-startup');\nvar app = require('electron').app;\nvar run = function (args, done) {\n  var updateExe = path.resolve(path.dirname(process.execPath), '..', 'Update.exe');\n  debug('Spawning `%s` with args `%s`', updateExe, args);\n  spawn(updateExe, args, {\n    detached: true\n  }).on('close', done);\n};\nvar check = function () {\n  if (process.platform === 'win32') {\n    var cmd = process.argv[1];\n    debug('processing squirrel command `%s`', cmd);\n    var target = path.basename(process.execPath);\n    if (cmd === '--squirrel-install' || cmd === '--squirrel-updated') {\n      run(['--createShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-uninstall') {\n      run(['--removeShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-obsolete') {\n      app.quit();\n      return true;\n    }\n  }\n  return false;\n};\nmodule.exports = check();","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n  if (!useColors) return;\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}","/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n    i;\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    args[0] = exports.coerce(args[0]);\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n  exports.names = [];\n  exports.skips = [];\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();\n}\nvar stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts).split('\\n').map(function (str) {\n    return str.trim();\n  }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream(fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, {\n        autoClose: false\n      });\n      stream._type = 'fs';\n      break;\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n  stream._isStdio = true;\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}","module.exports = __non_webpack_require__(__webpack_require__.ab + \"build/Release/conpty.node\")","module.exports = __non_webpack_require__(__webpack_require__.ab + \"build/Release/pty.node\")","\"use strict\";\n\n/**\n * Copyright (c) 2019, Microsoft Corporation (MIT License).\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventEmitter2 = void 0;\nvar EventEmitter2 = /** @class */function () {\n  function EventEmitter2() {\n    this._listeners = [];\n  }\n  Object.defineProperty(EventEmitter2.prototype, \"event\", {\n    get: function () {\n      var _this = this;\n      if (!this._event) {\n        this._event = function (listener) {\n          _this._listeners.push(listener);\n          var disposable = {\n            dispose: function () {\n              for (var i = 0; i < _this._listeners.length; i++) {\n                if (_this._listeners[i] === listener) {\n                  _this._listeners.splice(i, 1);\n                  return;\n                }\n              }\n            }\n          };\n          return disposable;\n        };\n      }\n      return this._event;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  EventEmitter2.prototype.fire = function (data) {\n    var queue = [];\n    for (var i = 0; i < this._listeners.length; i++) {\n      queue.push(this._listeners[i]);\n    }\n    for (var i = 0; i < queue.length; i++) {\n      queue[i].call(undefined, data);\n    }\n  };\n  return EventEmitter2;\n}();\nexports.EventEmitter2 = EventEmitter2;","\"use strict\";\n\n/**\n * Copyright (c) 2012-2015, Christopher Jeffrey, Peter Sunde (MIT License)\n * Copyright (c) 2016, Daniel Imms (MIT License).\n * Copyright (c) 2018, Microsoft Corporation (MIT License).\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.native = exports.open = exports.createTerminal = exports.fork = exports.spawn = void 0;\nvar terminalCtor;\nif (process.platform === 'win32') {\n  terminalCtor = require('./windowsTerminal').WindowsTerminal;\n} else {\n  terminalCtor = require('./unixTerminal').UnixTerminal;\n}\n/**\n * Forks a process as a pseudoterminal.\n * @param file The file to launch.\n * @param args The file's arguments as argv (string[]) or in a pre-escaped\n * CommandLine format (string). Note that the CommandLine option is only\n * available on Windows and is expected to be escaped properly.\n * @param options The options of the terminal.\n * @throws When the file passed to spawn with does not exists.\n * @see CommandLineToArgvW https://msdn.microsoft.com/en-us/library/windows/desktop/bb776391(v=vs.85).aspx\n * @see Parsing C++ Comamnd-Line Arguments https://msdn.microsoft.com/en-us/library/17w5ykft.aspx\n * @see GetCommandLine https://msdn.microsoft.com/en-us/library/windows/desktop/ms683156.aspx\n */\nfunction spawn(file, args, opt) {\n  return new terminalCtor(file, args, opt);\n}\nexports.spawn = spawn;\n/** @deprecated */\nfunction fork(file, args, opt) {\n  return new terminalCtor(file, args, opt);\n}\nexports.fork = fork;\n/** @deprecated */\nfunction createTerminal(file, args, opt) {\n  return new terminalCtor(file, args, opt);\n}\nexports.createTerminal = createTerminal;\nfunction open(options) {\n  return terminalCtor.open(options);\n}\nexports.open = open;\n/**\n * Expose the native API when not Windows, note that this is not public API and\n * could be removed at any time.\n */\nexports.native = process.platform !== 'win32' ? require('../build/Release/pty.node') : null;","\"use strict\";\n\n/**\n * Copyright (c) 2020, Microsoft Corporation (MIT License).\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWorkerPipeName = void 0;\nfunction getWorkerPipeName(conoutPipeName) {\n  return conoutPipeName + \"-worker\";\n}\nexports.getWorkerPipeName = getWorkerPipeName;","\"use strict\";\n\n/**\n * Copyright (c) 2012-2015, Christopher Jeffrey (MIT License)\n * Copyright (c) 2016, Daniel Imms (MIT License).\n * Copyright (c) 2018, Microsoft Corporation (MIT License).\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Terminal = exports.DEFAULT_ROWS = exports.DEFAULT_COLS = void 0;\nvar events_1 = require(\"events\");\nvar eventEmitter2_1 = require(\"./eventEmitter2\");\nexports.DEFAULT_COLS = 80;\nexports.DEFAULT_ROWS = 24;\n/**\n * Default messages to indicate PAUSE/RESUME for automatic flow control.\n * To avoid conflicts with rebound XON/XOFF control codes (such as on-my-zsh),\n * the sequences can be customized in `IPtyForkOptions`.\n */\nvar FLOW_CONTROL_PAUSE = '\\x13'; // defaults to XOFF\nvar FLOW_CONTROL_RESUME = '\\x11'; // defaults to XON\nvar Terminal = /** @class */function () {\n  function Terminal(opt) {\n    this._pid = 0;\n    this._fd = 0;\n    this._cols = 0;\n    this._rows = 0;\n    this._readable = false;\n    this._writable = false;\n    this._onData = new eventEmitter2_1.EventEmitter2();\n    this._onExit = new eventEmitter2_1.EventEmitter2();\n    // for 'close'\n    this._internalee = new events_1.EventEmitter();\n    // setup flow control handling\n    this.handleFlowControl = !!(opt === null || opt === void 0 ? void 0 : opt.handleFlowControl);\n    this._flowControlPause = (opt === null || opt === void 0 ? void 0 : opt.flowControlPause) || FLOW_CONTROL_PAUSE;\n    this._flowControlResume = (opt === null || opt === void 0 ? void 0 : opt.flowControlResume) || FLOW_CONTROL_RESUME;\n    if (!opt) {\n      return;\n    }\n    // Do basic type checks here in case node-pty is being used within JavaScript. If the wrong\n    // types go through to the C++ side it can lead to hard to diagnose exceptions.\n    this._checkType('name', opt.name ? opt.name : undefined, 'string');\n    this._checkType('cols', opt.cols ? opt.cols : undefined, 'number');\n    this._checkType('rows', opt.rows ? opt.rows : undefined, 'number');\n    this._checkType('cwd', opt.cwd ? opt.cwd : undefined, 'string');\n    this._checkType('env', opt.env ? opt.env : undefined, 'object');\n    this._checkType('uid', opt.uid ? opt.uid : undefined, 'number');\n    this._checkType('gid', opt.gid ? opt.gid : undefined, 'number');\n    this._checkType('encoding', opt.encoding ? opt.encoding : undefined, 'string');\n  }\n  Object.defineProperty(Terminal.prototype, \"onData\", {\n    get: function () {\n      return this._onData.event;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Terminal.prototype, \"onExit\", {\n    get: function () {\n      return this._onExit.event;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Terminal.prototype, \"pid\", {\n    get: function () {\n      return this._pid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Terminal.prototype, \"cols\", {\n    get: function () {\n      return this._cols;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Terminal.prototype, \"rows\", {\n    get: function () {\n      return this._rows;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Terminal.prototype.write = function (data) {\n    if (this.handleFlowControl) {\n      // PAUSE/RESUME messages are not forwarded to the pty\n      if (data === this._flowControlPause) {\n        this.pause();\n        return;\n      }\n      if (data === this._flowControlResume) {\n        this.resume();\n        return;\n      }\n    }\n    // everything else goes to the real pty\n    this._write(data);\n  };\n  Terminal.prototype._forwardEvents = function () {\n    var _this = this;\n    this.on('data', function (e) {\n      return _this._onData.fire(e);\n    });\n    this.on('exit', function (exitCode, signal) {\n      return _this._onExit.fire({\n        exitCode: exitCode,\n        signal: signal\n      });\n    });\n  };\n  Terminal.prototype._checkType = function (name, value, type, allowArray) {\n    if (allowArray === void 0) {\n      allowArray = false;\n    }\n    if (value === undefined) {\n      return;\n    }\n    if (allowArray) {\n      if (Array.isArray(value)) {\n        value.forEach(function (v, i) {\n          if (typeof v !== type) {\n            throw new Error(name + \"[\" + i + \"] must be a \" + type + \" (not a \" + typeof v[i] + \")\");\n          }\n        });\n        return;\n      }\n    }\n    if (typeof value !== type) {\n      throw new Error(name + \" must be a \" + type + \" (not a \" + typeof value + \")\");\n    }\n  };\n  /** See net.Socket.end */\n  Terminal.prototype.end = function (data) {\n    this._socket.end(data);\n  };\n  /** See stream.Readable.pipe */\n  Terminal.prototype.pipe = function (dest, options) {\n    return this._socket.pipe(dest, options);\n  };\n  /** See net.Socket.pause */\n  Terminal.prototype.pause = function () {\n    return this._socket.pause();\n  };\n  /** See net.Socket.resume */\n  Terminal.prototype.resume = function () {\n    return this._socket.resume();\n  };\n  /** See net.Socket.setEncoding */\n  Terminal.prototype.setEncoding = function (encoding) {\n    if (this._socket._decoder) {\n      delete this._socket._decoder;\n    }\n    if (encoding) {\n      this._socket.setEncoding(encoding);\n    }\n  };\n  Terminal.prototype.addListener = function (eventName, listener) {\n    this.on(eventName, listener);\n  };\n  Terminal.prototype.on = function (eventName, listener) {\n    if (eventName === 'close') {\n      this._internalee.on('close', listener);\n      return;\n    }\n    this._socket.on(eventName, listener);\n  };\n  Terminal.prototype.emit = function (eventName) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    if (eventName === 'close') {\n      return this._internalee.emit.apply(this._internalee, arguments);\n    }\n    return this._socket.emit.apply(this._socket, arguments);\n  };\n  Terminal.prototype.listeners = function (eventName) {\n    return this._socket.listeners(eventName);\n  };\n  Terminal.prototype.removeListener = function (eventName, listener) {\n    this._socket.removeListener(eventName, listener);\n  };\n  Terminal.prototype.removeAllListeners = function (eventName) {\n    this._socket.removeAllListeners(eventName);\n  };\n  Terminal.prototype.once = function (eventName, listener) {\n    this._socket.once(eventName, listener);\n  };\n  Terminal.prototype._close = function () {\n    this._socket.readable = false;\n    this.write = function () {};\n    this.end = function () {};\n    this._writable = false;\n    this._readable = false;\n  };\n  Terminal.prototype._parseEnv = function (env) {\n    var keys = Object.keys(env || {});\n    var pairs = [];\n    for (var i = 0; i < keys.length; i++) {\n      if (keys[i] === undefined) {\n        continue;\n      }\n      pairs.push(keys[i] + '=' + env[keys[i]]);\n    }\n    return pairs;\n  };\n  return Terminal;\n}();\nexports.Terminal = Terminal;","\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnixTerminal = void 0;\n/**\n * Copyright (c) 2012-2015, Christopher Jeffrey (MIT License)\n * Copyright (c) 2016, Daniel Imms (MIT License).\n * Copyright (c) 2018, Microsoft Corporation (MIT License).\n */\nvar net = require(\"net\");\nvar path = require(\"path\");\nvar terminal_1 = require(\"./terminal\");\nvar utils_1 = require(\"./utils\");\nvar pty;\nvar helperPath;\ntry {\n  pty = require('../build/Release/pty.node');\n  helperPath = '../build/Release/spawn-helper';\n} catch (outerError) {\n  try {\n    pty = require('../build/Debug/pty.node');\n    helperPath = '../build/Debug/spawn-helper';\n  } catch (innerError) {\n    console.error('innerError', innerError);\n    // Re-throw the exception from the Release require if the Debug require fails as well\n    throw outerError;\n  }\n}\nhelperPath = path.resolve(__dirname, helperPath);\nhelperPath = helperPath.replace('app.asar', 'app.asar.unpacked');\nhelperPath = helperPath.replace('node_modules.asar', 'node_modules.asar.unpacked');\nvar DEFAULT_FILE = 'sh';\nvar DEFAULT_NAME = 'xterm';\nvar DESTROY_SOCKET_TIMEOUT_MS = 200;\nvar UnixTerminal = /** @class */function (_super) {\n  __extends(UnixTerminal, _super);\n  function UnixTerminal(file, args, opt) {\n    var _a, _b;\n    var _this = _super.call(this, opt) || this;\n    _this._boundClose = false;\n    _this._emittedClose = false;\n    if (typeof args === 'string') {\n      throw new Error('args as a string is not supported on unix.');\n    }\n    // Initialize arguments\n    args = args || [];\n    file = file || DEFAULT_FILE;\n    opt = opt || {};\n    opt.env = opt.env || process.env;\n    _this._cols = opt.cols || terminal_1.DEFAULT_COLS;\n    _this._rows = opt.rows || terminal_1.DEFAULT_ROWS;\n    var uid = (_a = opt.uid) !== null && _a !== void 0 ? _a : -1;\n    var gid = (_b = opt.gid) !== null && _b !== void 0 ? _b : -1;\n    var env = utils_1.assign({}, opt.env);\n    if (opt.env === process.env) {\n      _this._sanitizeEnv(env);\n    }\n    var cwd = opt.cwd || process.cwd();\n    env.PWD = cwd;\n    var name = opt.name || env.TERM || DEFAULT_NAME;\n    env.TERM = name;\n    var parsedEnv = _this._parseEnv(env);\n    var encoding = opt.encoding === undefined ? 'utf8' : opt.encoding;\n    var onexit = function (code, signal) {\n      // XXX Sometimes a data event is emitted after exit. Wait til socket is\n      // destroyed.\n      if (!_this._emittedClose) {\n        if (_this._boundClose) {\n          return;\n        }\n        _this._boundClose = true;\n        // From macOS High Sierra 10.13.2 sometimes the socket never gets\n        // closed. A timeout is applied here to avoid the terminal never being\n        // destroyed when this occurs.\n        var timeout_1 = setTimeout(function () {\n          timeout_1 = null;\n          // Destroying the socket now will cause the close event to fire\n          _this._socket.destroy();\n        }, DESTROY_SOCKET_TIMEOUT_MS);\n        _this.once('close', function () {\n          if (timeout_1 !== null) {\n            clearTimeout(timeout_1);\n          }\n          _this.emit('exit', code, signal);\n        });\n        return;\n      }\n      _this.emit('exit', code, signal);\n    };\n    // fork\n    var term = pty.fork(file, args, parsedEnv, cwd, _this._cols, _this._rows, uid, gid, encoding === 'utf8', helperPath, onexit);\n    _this._socket = new PipeSocket(term.fd);\n    if (encoding !== null) {\n      _this._socket.setEncoding(encoding);\n    }\n    // setup\n    _this._socket.on('error', function (err) {\n      // NOTE: fs.ReadStream gets EAGAIN twice at first:\n      if (err.code) {\n        if (~err.code.indexOf('EAGAIN')) {\n          return;\n        }\n      }\n      // close\n      _this._close();\n      // EIO on exit from fs.ReadStream:\n      if (!_this._emittedClose) {\n        _this._emittedClose = true;\n        _this.emit('close');\n      }\n      // EIO, happens when someone closes our child process: the only process in\n      // the terminal.\n      // node < 0.6.14: errno 5\n      // node >= 0.6.14: read EIO\n      if (err.code) {\n        if (~err.code.indexOf('errno 5') || ~err.code.indexOf('EIO')) {\n          return;\n        }\n      }\n      // throw anything else\n      if (_this.listeners('error').length < 2) {\n        throw err;\n      }\n    });\n    _this._pid = term.pid;\n    _this._fd = term.fd;\n    _this._pty = term.pty;\n    _this._file = file;\n    _this._name = name;\n    _this._readable = true;\n    _this._writable = true;\n    _this._socket.on('close', function () {\n      if (_this._emittedClose) {\n        return;\n      }\n      _this._emittedClose = true;\n      _this._close();\n      _this.emit('close');\n    });\n    _this._forwardEvents();\n    return _this;\n  }\n  Object.defineProperty(UnixTerminal.prototype, \"master\", {\n    get: function () {\n      return this._master;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UnixTerminal.prototype, \"slave\", {\n    get: function () {\n      return this._slave;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  UnixTerminal.prototype._write = function (data) {\n    this._socket.write(data);\n  };\n  Object.defineProperty(UnixTerminal.prototype, \"fd\", {\n    /* Accessors */\n    get: function () {\n      return this._fd;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UnixTerminal.prototype, \"ptsName\", {\n    get: function () {\n      return this._pty;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * openpty\n   */\n  UnixTerminal.open = function (opt) {\n    var self = Object.create(UnixTerminal.prototype);\n    opt = opt || {};\n    if (arguments.length > 1) {\n      opt = {\n        cols: arguments[1],\n        rows: arguments[2]\n      };\n    }\n    var cols = opt.cols || terminal_1.DEFAULT_COLS;\n    var rows = opt.rows || terminal_1.DEFAULT_ROWS;\n    var encoding = opt.encoding === undefined ? 'utf8' : opt.encoding;\n    // open\n    var term = pty.open(cols, rows);\n    self._master = new PipeSocket(term.master);\n    if (encoding !== null) {\n      self._master.setEncoding(encoding);\n    }\n    self._master.resume();\n    self._slave = new PipeSocket(term.slave);\n    if (encoding !== null) {\n      self._slave.setEncoding(encoding);\n    }\n    self._slave.resume();\n    self._socket = self._master;\n    self._pid = -1;\n    self._fd = term.master;\n    self._pty = term.pty;\n    self._file = process.argv[0] || 'node';\n    self._name = process.env.TERM || '';\n    self._readable = true;\n    self._writable = true;\n    self._socket.on('error', function (err) {\n      self._close();\n      if (self.listeners('error').length < 2) {\n        throw err;\n      }\n    });\n    self._socket.on('close', function () {\n      self._close();\n    });\n    return self;\n  };\n  UnixTerminal.prototype.destroy = function () {\n    var _this = this;\n    this._close();\n    // Need to close the read stream so node stops reading a dead file\n    // descriptor. Then we can safely SIGHUP the shell.\n    this._socket.once('close', function () {\n      _this.kill('SIGHUP');\n    });\n    this._socket.destroy();\n  };\n  UnixTerminal.prototype.kill = function (signal) {\n    try {\n      process.kill(this.pid, signal || 'SIGHUP');\n    } catch (e) {/* swallow */}\n  };\n  Object.defineProperty(UnixTerminal.prototype, \"process\", {\n    /**\n     * Gets the name of the process.\n     */\n    get: function () {\n      if (process.platform === 'darwin') {\n        var title = pty.process(this._fd);\n        return title !== 'kernel_task' ? title : this._file;\n      }\n      return pty.process(this._fd, this._pty) || this._file;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * TTY\n   */\n  UnixTerminal.prototype.resize = function (cols, rows) {\n    if (cols <= 0 || rows <= 0 || isNaN(cols) || isNaN(rows) || cols === Infinity || rows === Infinity) {\n      throw new Error('resizing must be done using positive cols and rows');\n    }\n    pty.resize(this._fd, cols, rows);\n    this._cols = cols;\n    this._rows = rows;\n  };\n  UnixTerminal.prototype.clear = function () {};\n  UnixTerminal.prototype._sanitizeEnv = function (env) {\n    // Make sure we didn't start our server from inside tmux.\n    delete env['TMUX'];\n    delete env['TMUX_PANE'];\n    // Make sure we didn't start our server from inside screen.\n    // http://web.mit.edu/gnu/doc/html/screen_20.html\n    delete env['STY'];\n    delete env['WINDOW'];\n    // Delete some variables that might confuse our terminal.\n    delete env['WINDOWID'];\n    delete env['TERMCAP'];\n    delete env['COLUMNS'];\n    delete env['LINES'];\n  };\n  return UnixTerminal;\n}(terminal_1.Terminal);\nexports.UnixTerminal = UnixTerminal;\n/**\n * Wraps net.Socket to force the handle type \"PIPE\" by temporarily overwriting\n * tty_wrap.guessHandleType.\n * See: https://github.com/chjj/pty.js/issues/103\n */\nvar PipeSocket = /** @class */function (_super) {\n  __extends(PipeSocket, _super);\n  function PipeSocket(fd) {\n    var _this = this;\n    var pipeWrap = process.binding('pipe_wrap'); // tslint:disable-line\n    // @types/node has fd as string? https://github.com/DefinitelyTyped/DefinitelyTyped/pull/18275\n    var handle = new pipeWrap.Pipe(pipeWrap.constants.SOCKET);\n    handle.open(fd);\n    _this = _super.call(this, {\n      handle: handle\n    }) || this;\n    return _this;\n  }\n  return PipeSocket;\n}(net.Socket);","\"use strict\";\n\n/**\n * Copyright (c) 2017, Daniel Imms (MIT License).\n * Copyright (c) 2018, Microsoft Corporation (MIT License).\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assign = void 0;\nfunction assign(target) {\n  var sources = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n  sources.forEach(function (source) {\n    return Object.keys(source).forEach(function (key) {\n      return target[key] = source[key];\n    });\n  });\n  return target;\n}\nexports.assign = assign;","\"use strict\";\n\n/**\n * Copyright (c) 2020, Microsoft Corporation (MIT License).\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConoutConnection = void 0;\nvar worker_threads_1 = require(\"worker_threads\");\nvar conout_1 = require(\"./shared/conout\");\nvar path_1 = require(\"path\");\nvar eventEmitter2_1 = require(\"./eventEmitter2\");\n/**\n * The amount of time to wait for additional data after the conpty shell process has exited before\n * shutting down the worker and sockets. The timer will be reset if a new data event comes in after\n * the timer has started.\n */\nvar FLUSH_DATA_INTERVAL = 1000;\n/**\n * Connects to and manages the lifecycle of the conout socket. This socket must be drained on\n * another thread in order to avoid deadlocks where Conpty waits for the out socket to drain\n * when `ClosePseudoConsole` is called. This happens when data is being written to the terminal when\n * the pty is closed.\n *\n * See also:\n * - https://github.com/microsoft/node-pty/issues/375\n * - https://github.com/microsoft/vscode/issues/76548\n * - https://github.com/microsoft/terminal/issues/1810\n * - https://docs.microsoft.com/en-us/windows/console/closepseudoconsole\n */\nvar ConoutConnection = /** @class */function () {\n  function ConoutConnection(_conoutPipeName) {\n    var _this = this;\n    this._conoutPipeName = _conoutPipeName;\n    this._isDisposed = false;\n    this._onReady = new eventEmitter2_1.EventEmitter2();\n    var workerData = {\n      conoutPipeName: _conoutPipeName\n    };\n    var scriptPath = __dirname.replace('node_modules.asar', 'node_modules.asar.unpacked');\n    this._worker = new worker_threads_1.Worker(path_1.join(scriptPath, 'worker/conoutSocketWorker.js'), {\n      workerData: workerData\n    });\n    this._worker.on('message', function (message) {\n      switch (message) {\n        case 1 /* READY */:\n          _this._onReady.fire();\n          return;\n        default:\n          console.warn('Unexpected ConoutWorkerMessage', message);\n      }\n    });\n  }\n  Object.defineProperty(ConoutConnection.prototype, \"onReady\", {\n    get: function () {\n      return this._onReady.event;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ConoutConnection.prototype.dispose = function () {\n    if (this._isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    // Drain all data from the socket before closing\n    this._drainDataAndClose();\n  };\n  ConoutConnection.prototype.connectSocket = function (socket) {\n    socket.connect(conout_1.getWorkerPipeName(this._conoutPipeName));\n  };\n  ConoutConnection.prototype._drainDataAndClose = function () {\n    var _this = this;\n    if (this._drainTimeout) {\n      clearTimeout(this._drainTimeout);\n    }\n    this._drainTimeout = setTimeout(function () {\n      return _this._destroySocket();\n    }, FLUSH_DATA_INTERVAL);\n  };\n  ConoutConnection.prototype._destroySocket = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this._worker.terminate()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  return ConoutConnection;\n}();\nexports.ConoutConnection = ConoutConnection;","\"use strict\";\n\n/**\n * Copyright (c) 2012-2015, Christopher Jeffrey, Peter Sunde (MIT License)\n * Copyright (c) 2016, Daniel Imms (MIT License).\n * Copyright (c) 2018, Microsoft Corporation (MIT License).\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.argsToCommandLine = exports.WindowsPtyAgent = void 0;\nvar fs = require(\"fs\");\nvar os = require(\"os\");\nvar path = require(\"path\");\nvar net_1 = require(\"net\");\nvar child_process_1 = require(\"child_process\");\nvar windowsConoutConnection_1 = require(\"./windowsConoutConnection\");\nvar conptyNative;\nvar winptyNative;\n/**\n * The amount of time to wait for additional data after the conpty shell process has exited before\n * shutting down the socket. The timer will be reset if a new data event comes in after the timer\n * has started.\n */\nvar FLUSH_DATA_INTERVAL = 1000;\n/**\n * This agent sits between the WindowsTerminal class and provides a common interface for both conpty\n * and winpty.\n */\nvar WindowsPtyAgent = /** @class */function () {\n  function WindowsPtyAgent(file, args, env, cwd, cols, rows, debug, _useConpty, conptyInheritCursor) {\n    var _this = this;\n    if (conptyInheritCursor === void 0) {\n      conptyInheritCursor = false;\n    }\n    this._useConpty = _useConpty;\n    this._pid = 0;\n    this._innerPid = 0;\n    if (this._useConpty === undefined || this._useConpty === true) {\n      this._useConpty = this._getWindowsBuildNumber() >= 18309;\n    }\n    if (this._useConpty) {\n      if (!conptyNative) {\n        try {\n          conptyNative = require('../build/Release/conpty.node');\n        } catch (outerError) {\n          try {\n            conptyNative = require('../build/Debug/conpty.node');\n          } catch (innerError) {\n            console.error('innerError', innerError);\n            // Re-throw the exception from the Release require if the Debug require fails as well\n            throw outerError;\n          }\n        }\n      }\n    } else {\n      if (!winptyNative) {\n        try {\n          winptyNative = require('../build/Release/pty.node');\n        } catch (outerError) {\n          try {\n            winptyNative = require('../build/Debug/pty.node');\n          } catch (innerError) {\n            console.error('innerError', innerError);\n            // Re-throw the exception from the Release require if the Debug require fails as well\n            throw outerError;\n          }\n        }\n      }\n    }\n    this._ptyNative = this._useConpty ? conptyNative : winptyNative;\n    // Sanitize input variable.\n    cwd = path.resolve(cwd);\n    // Compose command line\n    var commandLine = argsToCommandLine(file, args);\n    // Open pty session.\n    var term;\n    if (this._useConpty) {\n      term = this._ptyNative.startProcess(file, cols, rows, debug, this._generatePipeName(), conptyInheritCursor);\n    } else {\n      term = this._ptyNative.startProcess(file, commandLine, env, cwd, cols, rows, debug);\n      this._pid = term.pid;\n      this._innerPid = term.innerPid;\n    }\n    // Not available on windows.\n    this._fd = term.fd;\n    // Generated incremental number that has no real purpose besides  using it\n    // as a terminal id.\n    this._pty = term.pty;\n    // Create terminal pipe IPC channel and forward to a local unix socket.\n    this._outSocket = new net_1.Socket();\n    this._outSocket.setEncoding('utf8');\n    // The conout socket must be ready out on another thread to avoid deadlocks\n    this._conoutSocketWorker = new windowsConoutConnection_1.ConoutConnection(term.conout);\n    this._conoutSocketWorker.onReady(function () {\n      _this._conoutSocketWorker.connectSocket(_this._outSocket);\n    });\n    this._outSocket.on('connect', function () {\n      _this._outSocket.emit('ready_datapipe');\n    });\n    var inSocketFD = fs.openSync(term.conin, 'w');\n    this._inSocket = new net_1.Socket({\n      fd: inSocketFD,\n      readable: false,\n      writable: true\n    });\n    this._inSocket.setEncoding('utf8');\n    if (this._useConpty) {\n      var connect = this._ptyNative.connect(this._pty, commandLine, cwd, env, function (c) {\n        return _this._$onProcessExit(c);\n      });\n      this._innerPid = connect.pid;\n    }\n  }\n  Object.defineProperty(WindowsPtyAgent.prototype, \"inSocket\", {\n    get: function () {\n      return this._inSocket;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsPtyAgent.prototype, \"outSocket\", {\n    get: function () {\n      return this._outSocket;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsPtyAgent.prototype, \"fd\", {\n    get: function () {\n      return this._fd;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsPtyAgent.prototype, \"innerPid\", {\n    get: function () {\n      return this._innerPid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsPtyAgent.prototype, \"pty\", {\n    get: function () {\n      return this._pty;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WindowsPtyAgent.prototype.resize = function (cols, rows) {\n    if (this._useConpty) {\n      if (this._exitCode !== undefined) {\n        throw new Error('Cannot resize a pty that has already exited');\n      }\n      this._ptyNative.resize(this._pty, cols, rows);\n      return;\n    }\n    this._ptyNative.resize(this._pid, cols, rows);\n  };\n  WindowsPtyAgent.prototype.clear = function () {\n    if (this._useConpty) {\n      this._ptyNative.clear(this._pty);\n    }\n  };\n  WindowsPtyAgent.prototype.kill = function () {\n    var _this = this;\n    this._inSocket.readable = false;\n    this._outSocket.readable = false;\n    // Tell the agent to kill the pty, this releases handles to the process\n    if (this._useConpty) {\n      this._getConsoleProcessList().then(function (consoleProcessList) {\n        consoleProcessList.forEach(function (pid) {\n          try {\n            process.kill(pid);\n          } catch (e) {\n            // Ignore if process cannot be found (kill ESRCH error)\n          }\n        });\n        _this._ptyNative.kill(_this._pty);\n      });\n    } else {\n      // Because pty.kill closes the handle, it will kill most processes by itself.\n      // Process IDs can be reused as soon as all handles to them are\n      // dropped, so we want to immediately kill the entire console process list.\n      // If we do not force kill all processes here, node servers in particular\n      // seem to become detached and remain running (see\n      // Microsoft/vscode#26807).\n      var processList = this._ptyNative.getProcessList(this._pid);\n      this._ptyNative.kill(this._pid, this._innerPid);\n      processList.forEach(function (pid) {\n        try {\n          process.kill(pid);\n        } catch (e) {\n          // Ignore if process cannot be found (kill ESRCH error)\n        }\n      });\n    }\n    this._conoutSocketWorker.dispose();\n  };\n  WindowsPtyAgent.prototype._getConsoleProcessList = function () {\n    var _this = this;\n    return new Promise(function (resolve) {\n      var agent = child_process_1.fork(path.join(__dirname, 'conpty_console_list_agent'), [_this._innerPid.toString()]);\n      agent.on('message', function (message) {\n        clearTimeout(timeout);\n        resolve(message.consoleProcessList);\n      });\n      var timeout = setTimeout(function () {\n        // Something went wrong, just send back the shell PID\n        agent.kill();\n        resolve([_this._innerPid]);\n      }, 5000);\n    });\n  };\n  Object.defineProperty(WindowsPtyAgent.prototype, \"exitCode\", {\n    get: function () {\n      if (this._useConpty) {\n        return this._exitCode;\n      }\n      var winptyExitCode = this._ptyNative.getExitCode(this._innerPid);\n      return winptyExitCode === -1 ? undefined : winptyExitCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WindowsPtyAgent.prototype._getWindowsBuildNumber = function () {\n    var osVersion = /(\\d+)\\.(\\d+)\\.(\\d+)/g.exec(os.release());\n    var buildNumber = 0;\n    if (osVersion && osVersion.length === 4) {\n      buildNumber = parseInt(osVersion[3]);\n    }\n    return buildNumber;\n  };\n  WindowsPtyAgent.prototype._generatePipeName = function () {\n    return \"conpty-\" + Math.random() * 10000000;\n  };\n  /**\n   * Triggered from the native side when a contpy process exits.\n   */\n  WindowsPtyAgent.prototype._$onProcessExit = function (exitCode) {\n    var _this = this;\n    this._exitCode = exitCode;\n    this._flushDataAndCleanUp();\n    this._outSocket.on('data', function () {\n      return _this._flushDataAndCleanUp();\n    });\n  };\n  WindowsPtyAgent.prototype._flushDataAndCleanUp = function () {\n    var _this = this;\n    if (this._closeTimeout) {\n      clearTimeout(this._closeTimeout);\n    }\n    this._closeTimeout = setTimeout(function () {\n      return _this._cleanUpProcess();\n    }, FLUSH_DATA_INTERVAL);\n  };\n  WindowsPtyAgent.prototype._cleanUpProcess = function () {\n    this._inSocket.readable = false;\n    this._outSocket.readable = false;\n    this._outSocket.destroy();\n  };\n  return WindowsPtyAgent;\n}();\nexports.WindowsPtyAgent = WindowsPtyAgent;\n// Convert argc/argv into a Win32 command-line following the escaping convention\n// documented on MSDN (e.g. see CommandLineToArgvW documentation). Copied from\n// winpty project.\nfunction argsToCommandLine(file, args) {\n  if (isCommandLine(args)) {\n    if (args.length === 0) {\n      return file;\n    }\n    return argsToCommandLine(file, []) + \" \" + args;\n  }\n  var argv = [file];\n  Array.prototype.push.apply(argv, args);\n  var result = '';\n  for (var argIndex = 0; argIndex < argv.length; argIndex++) {\n    if (argIndex > 0) {\n      result += ' ';\n    }\n    var arg = argv[argIndex];\n    // if it is empty or it contains whitespace and is not already quoted\n    var hasLopsidedEnclosingQuote = xOr(arg[0] !== '\"', arg[arg.length - 1] !== '\"');\n    var hasNoEnclosingQuotes = arg[0] !== '\"' && arg[arg.length - 1] !== '\"';\n    var quote = arg === '' || (arg.indexOf(' ') !== -1 || arg.indexOf('\\t') !== -1) && arg.length > 1 && (hasLopsidedEnclosingQuote || hasNoEnclosingQuotes);\n    if (quote) {\n      result += '\\\"';\n    }\n    var bsCount = 0;\n    for (var i = 0; i < arg.length; i++) {\n      var p = arg[i];\n      if (p === '\\\\') {\n        bsCount++;\n      } else if (p === '\"') {\n        result += repeatText('\\\\', bsCount * 2 + 1);\n        result += '\"';\n        bsCount = 0;\n      } else {\n        result += repeatText('\\\\', bsCount);\n        bsCount = 0;\n        result += p;\n      }\n    }\n    if (quote) {\n      result += repeatText('\\\\', bsCount * 2);\n      result += '\\\"';\n    } else {\n      result += repeatText('\\\\', bsCount);\n    }\n  }\n  return result;\n}\nexports.argsToCommandLine = argsToCommandLine;\nfunction isCommandLine(args) {\n  return typeof args === 'string';\n}\nfunction repeatText(text, count) {\n  var result = '';\n  for (var i = 0; i < count; i++) {\n    result += text;\n  }\n  return result;\n}\nfunction xOr(arg1, arg2) {\n  return arg1 && !arg2 || !arg1 && arg2;\n}","\"use strict\";\n\n/**\n * Copyright (c) 2012-2015, Christopher Jeffrey, Peter Sunde (MIT License)\n * Copyright (c) 2016, Daniel Imms (MIT License).\n * Copyright (c) 2018, Microsoft Corporation (MIT License).\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WindowsTerminal = void 0;\nvar terminal_1 = require(\"./terminal\");\nvar windowsPtyAgent_1 = require(\"./windowsPtyAgent\");\nvar utils_1 = require(\"./utils\");\nvar DEFAULT_FILE = 'cmd.exe';\nvar DEFAULT_NAME = 'Windows Shell';\nvar WindowsTerminal = /** @class */function (_super) {\n  __extends(WindowsTerminal, _super);\n  function WindowsTerminal(file, args, opt) {\n    var _this = _super.call(this, opt) || this;\n    _this._checkType('args', args, 'string', true);\n    // Initialize arguments\n    args = args || [];\n    file = file || DEFAULT_FILE;\n    opt = opt || {};\n    opt.env = opt.env || process.env;\n    if (opt.encoding) {\n      console.warn('Setting encoding on Windows is not supported');\n    }\n    var env = utils_1.assign({}, opt.env);\n    _this._cols = opt.cols || terminal_1.DEFAULT_COLS;\n    _this._rows = opt.rows || terminal_1.DEFAULT_ROWS;\n    var cwd = opt.cwd || process.cwd();\n    var name = opt.name || env.TERM || DEFAULT_NAME;\n    var parsedEnv = _this._parseEnv(env);\n    // If the terminal is ready\n    _this._isReady = false;\n    // Functions that need to run after `ready` event is emitted.\n    _this._deferreds = [];\n    // Create new termal.\n    _this._agent = new windowsPtyAgent_1.WindowsPtyAgent(file, args, parsedEnv, cwd, _this._cols, _this._rows, false, opt.useConpty, opt.conptyInheritCursor);\n    _this._socket = _this._agent.outSocket;\n    // Not available until `ready` event emitted.\n    _this._pid = _this._agent.innerPid;\n    _this._fd = _this._agent.fd;\n    _this._pty = _this._agent.pty;\n    // The forked windows terminal is not available until `ready` event is\n    // emitted.\n    _this._socket.on('ready_datapipe', function () {\n      // These events needs to be forwarded.\n      ['connect', 'data', 'end', 'timeout', 'drain'].forEach(function (event) {\n        _this._socket.on(event, function () {\n          // Wait until the first data event is fired then we can run deferreds.\n          if (!_this._isReady && event === 'data') {\n            // Terminal is now ready and we can avoid having to defer method\n            // calls.\n            _this._isReady = true;\n            // Execute all deferred methods\n            _this._deferreds.forEach(function (fn) {\n              // NB! In order to ensure that `this` has all its references\n              // updated any variable that need to be available in `this` before\n              // the deferred is run has to be declared above this forEach\n              // statement.\n              fn.run();\n            });\n            // Reset\n            _this._deferreds = [];\n          }\n        });\n      });\n      // Shutdown if `error` event is emitted.\n      _this._socket.on('error', function (err) {\n        // Close terminal session.\n        _this._close();\n        // EIO, happens when someone closes our child process: the only process\n        // in the terminal.\n        // node < 0.6.14: errno 5\n        // node >= 0.6.14: read EIO\n        if (err.code) {\n          if (~err.code.indexOf('errno 5') || ~err.code.indexOf('EIO')) return;\n        }\n        // Throw anything else.\n        if (_this.listeners('error').length < 2) {\n          throw err;\n        }\n      });\n      // Cleanup after the socket is closed.\n      _this._socket.on('close', function () {\n        _this.emit('exit', _this._agent.exitCode);\n        _this._close();\n      });\n    });\n    _this._file = file;\n    _this._name = name;\n    _this._readable = true;\n    _this._writable = true;\n    _this._forwardEvents();\n    return _this;\n  }\n  WindowsTerminal.prototype._write = function (data) {\n    this._defer(this._doWrite, data);\n  };\n  WindowsTerminal.prototype._doWrite = function (data) {\n    this._agent.inSocket.write(data);\n  };\n  /**\n   * openpty\n   */\n  WindowsTerminal.open = function (options) {\n    throw new Error('open() not supported on windows, use Fork() instead.');\n  };\n  /**\n   * TTY\n   */\n  WindowsTerminal.prototype.resize = function (cols, rows) {\n    var _this = this;\n    if (cols <= 0 || rows <= 0 || isNaN(cols) || isNaN(rows) || cols === Infinity || rows === Infinity) {\n      throw new Error('resizing must be done using positive cols and rows');\n    }\n    this._deferNoArgs(function () {\n      _this._agent.resize(cols, rows);\n      _this._cols = cols;\n      _this._rows = rows;\n    });\n  };\n  WindowsTerminal.prototype.clear = function () {\n    var _this = this;\n    this._deferNoArgs(function () {\n      _this._agent.clear();\n    });\n  };\n  WindowsTerminal.prototype.destroy = function () {\n    var _this = this;\n    this._deferNoArgs(function () {\n      _this.kill();\n    });\n  };\n  WindowsTerminal.prototype.kill = function (signal) {\n    var _this = this;\n    this._deferNoArgs(function () {\n      if (signal) {\n        throw new Error('Signals not supported on windows.');\n      }\n      _this._close();\n      _this._agent.kill();\n    });\n  };\n  WindowsTerminal.prototype._deferNoArgs = function (deferredFn) {\n    var _this = this;\n    // If the terminal is ready, execute.\n    if (this._isReady) {\n      deferredFn.call(this);\n      return;\n    }\n    // Queue until terminal is ready.\n    this._deferreds.push({\n      run: function () {\n        return deferredFn.call(_this);\n      }\n    });\n  };\n  WindowsTerminal.prototype._defer = function (deferredFn, arg) {\n    var _this = this;\n    // If the terminal is ready, execute.\n    if (this._isReady) {\n      deferredFn.call(this, arg);\n      return;\n    }\n    // Queue until terminal is ready.\n    this._deferreds.push({\n      run: function () {\n        return deferredFn.call(_this, arg);\n      }\n    });\n  };\n  Object.defineProperty(WindowsTerminal.prototype, \"process\", {\n    get: function () {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsTerminal.prototype, \"master\", {\n    get: function () {\n      throw new Error('master is not supported on Windows');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsTerminal.prototype, \"slave\", {\n    get: function () {\n      throw new Error('slave is not supported on Windows');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return WindowsTerminal;\n}(terminal_1.Terminal);\nexports.WindowsTerminal = WindowsTerminal;","'use strict';\n\nconst codes = {};\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n  class NodeError extends Base {\n    constructor(arg1, arg2, arg3) {\n      super(getMessage(arg1, arg2, arg3));\n    }\n  }\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    expected = expected.map(i => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n  return str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n  let msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = includes(name, '.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","'use strict';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nvar ERR_INVALID_ARG_TYPE = require('../../../errors').codes.ERR_INVALID_ARG_TYPE;\nfunction from(Readable, iterable, opts) {\n  var iterator;\n  if (iterable && typeof iterable.next === 'function') {\n    iterator = iterable;\n  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);\n  var readable = new Readable(_objectSpread({\n    objectMode: true\n  }, opts));\n  // Reading boolean to protect against _read\n  // being called before last iteration completion.\n  var reading = false;\n  readable._read = function () {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n  function next() {\n    return _next2.apply(this, arguments);\n  }\n  function _next2() {\n    _next2 = _asyncToGenerator(function* () {\n      try {\n        var _yield$iterator$next = yield iterator.next(),\n          value = _yield$iterator$next.value,\n          done = _yield$iterator$next.done;\n        if (done) {\n          readable.push(null);\n        } else if (readable.push(yield value)) {\n          next();\n        } else {\n          reading = false;\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n    });\n    return _next2.apply(this, arguments);\n  }\n  return readable;\n}\nmodule.exports = from;","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","module.exports = require('stream');","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream.Readable;\n  Object.assign(module.exports, Stream);\n  module.exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n  exports.finished = require('./lib/internal/streams/end-of-stream.js');\n  exports.pipeline = require('./lib/internal/streams/pipeline.js');\n}","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer');\nvar Buffer = buffer.Buffer;\n\n// alternative to using Object.keys for old browsers\nfunction copyProps(src, dst) {\n  for (var key in src) {\n    dst[key] = src[key];\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer;\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports);\n  exports.Buffer = SafeBuffer;\n}\nfunction SafeBuffer(arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length);\n}\nSafeBuffer.prototype = Object.create(Buffer.prototype);\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer);\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number');\n  }\n  return Buffer(arg, encodingOrOffset, length);\n};\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n  var buf = Buffer(size);\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n  } else {\n    buf.fill(0);\n  }\n  return buf;\n};\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n  return Buffer(size);\n};\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number');\n  }\n  return buffer.SlowBuffer(size);\n};","/* eslint-disable node/no-deprecated-api */\n\n'use strict';\n\nvar buffer = require('buffer');\nvar Buffer = buffer.Buffer;\nvar safer = {};\nvar key;\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue;\n  if (key === 'SlowBuffer' || key === 'Buffer') continue;\n  safer[key] = buffer[key];\n}\nvar Safer = safer.Buffer = {};\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue;\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;\n  Safer[key] = Buffer[key];\n}\nsafer.Buffer.prototype = Buffer.prototype;\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value);\n    }\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);\n    }\n    return Buffer(value, encodingOrOffset, length);\n  };\n}\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size);\n    }\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n    var buf = Buffer(size);\n    if (!fill || fill.length === 0) {\n      buf.fill(0);\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n    return buf;\n  };\n}\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;\n  } catch (e) {\n    // we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  };\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;\n  }\n}\nmodule.exports = safer;","const errorCode = {\n  generic: 'ERR_GENERIC_CLIENT',\n  connect: 'ERR_NOT_CONNECTED',\n  badPath: 'ERR_BAD_PATH',\n  permission: 'EACCES',\n  notexist: 'ENOENT',\n  notdir: 'ENOTDIR',\n  badAuth: 'ERR_BAD_AUTH'\n};\nconst targetType = {\n  writeFile: 1,\n  readFile: 2,\n  writeDir: 3,\n  readDir: 4,\n  readObj: 5,\n  writeObj: 6\n};\nmodule.exports = {\n  errorCode,\n  targetType\n};","'use strict';\n\nconst {\n  Client\n} = require('ssh2');\nconst fs = require('node:fs');\nconst concat = require('concat-stream');\nconst {\n  join,\n  parse\n} = require('node:path');\nconst {\n  globalListener,\n  addTempListeners,\n  removeTempListeners,\n  haveConnection,\n  normalizeRemotePath,\n  localExists,\n  haveLocalAccess,\n  haveLocalCreate,\n  partition\n} = require('./utils');\nconst {\n  errorCode\n} = require('./constants');\nclass SftpClient {\n  constructor(clientName = 'sftp', callbacks = {\n    error: err => console.error(`Global error listener: ${err.message}`),\n    end: () => console.log('Global end listener: end event raised'),\n    close: () => console.log('Global close listener: close event raised')\n  }) {\n    this.version = '12.0.0';\n    this.client = new Client();\n    this.sftp = undefined;\n    this.clientName = clientName;\n    this.endCalled = false;\n    this.errorHandled = false;\n    this.closeHandled = false;\n    this.endHandled = false;\n    this.remotePlatform = 'unix';\n    this.debug = undefined;\n    this.promiseLimit = 10;\n    this.eventCallbacks = callbacks;\n    this.client.on('close', globalListener(this, 'close', this.eventCallbacks));\n    this.client.on('end', globalListener(this, 'end', this.eventCallbacks));\n    this.client.on('error', globalListener(this, 'error', this.eventCallbacks));\n  }\n  debugMsg(msg, obj) {\n    if (this.debug) {\n      if (obj) {\n        this.debug(`CLIENT[${this.clientName}]: ${msg} ${JSON.stringify(obj, null, ' ')}`);\n      } else {\n        this.debug(`CLIENT[${this.clientName}]: ${msg}`);\n      }\n    }\n  }\n  fmtError(err, name = 'sftp', eCode, retryCount) {\n    let msg = '';\n    let code = '';\n    if (err === undefined) {\n      msg = `${name}: Undefined error - probably a bug!`;\n      code = errorCode.generic;\n    } else if (typeof err === 'string') {\n      msg = `${name}: ${err}`;\n      code = eCode || errorCode.generic;\n    } else if (err.custom) {\n      msg = `${name}->${err.message}`;\n      code = err.code;\n    } else {\n      switch (err.code) {\n        case 'ENOTFOUND':\n          {\n            msg = `${name}: Address lookup failed for host`;\n            break;\n          }\n        case 'ECONNREFUSED':\n          {\n            msg = `${name}: Remote host refused connection`;\n            break;\n          }\n        case 'ECONNRESET':\n          {\n            msg = `${name}: Remote host has reset the connection: ${err.message}`;\n            break;\n          }\n        default:\n          {\n            msg = `${name}: ${err.message}`;\n          }\n      }\n      code = err.code || errorCode.generic;\n    }\n    const newError = new Error(msg);\n    newError.code = code;\n    newError.custom = true;\n    this.debugMsg(`${newError.message} (${newError.code})`);\n    return newError;\n  }\n\n  /**\n   * Add a listner to the client object. This is rarely necessary and can be\n   * the source of errors. It is the client's responsibility to remove the\n   * listeners when no longer required. Failure to do so can result in memory\n   * leaks.\n   *\n   * @param {string} eventType - one of the supported event types\n   * @param {function} callback - function called when event triggers\n   */\n  on(eventType, callback) {\n    this.client.prependListener(eventType, callback);\n  }\n  removeListener(eventType, callback) {\n    this.client.removeListener(eventType, callback);\n  }\n  _resetEventFlags() {\n    this.closeHandled = false;\n    this.endHandled = false;\n    this.errorHandled = false;\n  }\n\n  /**\n   *\n   * Create a new SFTP connection to a remote SFTP server.\n   * The connection options are the same as those offered\n   * by the underlying SSH2 module.\n   *\n   * @param {Object} config - an SFTP configuration object\n   *\n   * @return {Promise<Object>} which will resolve to an sftp client object\n   */\n  connect(config) {\n    let doReady, listeners;\n    return new Promise((resolve, reject) => {\n      listeners = addTempListeners(this, 'getConnection', reject);\n      if (config.debug) {\n        this.debug = config.debug;\n        this.debugMsg('connect: Debugging turned on');\n        this.debugMsg(`ssh2-sftp-client Version: ${this.version} `, process.versions);\n      }\n      this.promiseLimit = config.promiseLimit ?? 10;\n      doReady = () => {\n        this.client.sftp((err, sftp) => {\n          if (err) {\n            reject(this.fmtError(err));\n          } else {\n            this.sftp = sftp;\n            resolve(sftp);\n          }\n        });\n      };\n      this.on('ready', doReady);\n      try {\n        if (this.sftp) {\n          reject(this.fmtError('An existing SFTP connection is already defined', 'connect', errorCode.connect));\n        } else {\n          this.client.connect(config);\n        }\n      } catch (err) {\n        this.end();\n        reject(err);\n      }\n    }).finally(() => {\n      this.removeListener('ready', doReady);\n      removeTempListeners(this, listeners, 'getConnection');\n    });\n  }\n\n  /**\n   * @async\n   *\n   * Returns the real absolute path on the remote server. Is able to handle\n   * both '.' and '..' in path names, but not '~'. If the path is relative\n   * then the current working directory is prepended to create an absolute path.\n   * Returns undefined if the path does not exists.\n   *\n   * @param {String} remotePath - remote path, may be relative\n   * @param {Boolean} addListeners - (Optional) add event listeners. Default = true\n   * @returns {Promise<String>} - remote absolute path or ''\n   */\n  realPath(remotePath, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'realPath', reject);\n      }\n      this.sftp.realpath(remotePath, (err, absPath) => {\n        if (err) {\n          if (err.code === 2) {\n            resolve('');\n          } else {\n            reject(this.fmtError(`${err.message} ${remotePath}`, 'realPath', err.code));\n          }\n        }\n        resolve(absPath);\n      });\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, 'realPath');\n      }\n    });\n  }\n\n  /**\n   * @async\n   *\n   * Return the current workding directory path\n   *\n   * @returns {Promise<String>} - current remote working directory\n   */\n  cwd() {\n    return this.realPath('.');\n  }\n\n  /**\n   * Retrieves attributes for path using cmd, which is either\n   * this.sftp.stat or this.sftp.lstat\n   *\n   * @param {Function} cmd - either this.sftp.stat or this.sftp.lstat\n   * @param {String} remotePath - a string containing the path to a file\n   * @param {Boolean} addListeners - (Optional) if true add event listeners. Default true.\n   * @return {Promise<Object>} stats - attributes info\n   */\n  _xstat(cmd, aPath, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      const cb = (err, stats) => {\n        if (err) {\n          if (err.code === 2 || err.code === 4) {\n            reject(this.fmtError(`No such file: ${aPath}`, '_xstat', errorCode.notexist));\n          } else {\n            reject(this.fmtError(`${err.message} ${aPath}`, '_xstat', err.code));\n          }\n        } else {\n          const result = {\n            mode: stats.mode,\n            uid: stats.uid,\n            gid: stats.gid,\n            size: stats.size,\n            accessTime: stats.atime * 1000,\n            modifyTime: stats.mtime * 1000,\n            isDirectory: stats.isDirectory(),\n            isFile: stats.isFile(),\n            isBlockDevice: stats.isBlockDevice(),\n            isCharacterDevice: stats.isCharacterDevice(),\n            isSymbolicLink: stats.isSymbolicLink(),\n            isFIFO: stats.isFIFO(),\n            isSocket: stats.isSocket()\n          };\n          resolve(result);\n        }\n      };\n      if (addListeners) {\n        listeners = addTempListeners(this, '_xstat', reject);\n      }\n      if (cmd === 'stat') {\n        this.sftp.stat(aPath, cb);\n      } else {\n        this.sftp.lstat(aPath, cb);\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, '_xstat');\n      }\n    });\n  }\n\n  /*\n   * Use the stat command to obtain attributes associated with a remote path.\n   * THe difference between stat and lstat is that stat, in the case of symbolic\n   * links, will return the attributes associated with the target of the link. With\n   * lstat, attributes associated with the symbolic link rather than the target are\n   * returned.\n   *\n   * @param {String} remotePath - path to an object on the remote server\n   * @return {Promise<Object>} stats - attributes info\n   */\n  async stat(remotePath) {\n    try {\n      haveConnection(this, 'stat');\n      return await this._xstat('stat', remotePath);\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(err, 'stat', err.code);\n    }\n  }\n\n  /*\n   * Use the lstat command to obtain attributes associated with a remote path.\n   * THe difference between stat and lstat is that stat, in the case of symbolic\n   * links, will return the attributes associated with the target of the link. With\n   * lstat, attributes associated with the symbolic link rather than the target are\n   * returned.\n   *\n   * @param {String} remotePath - path to an object on the remote server\n   * @return {Promise<Object>} stats - attributes info\n   */\n  async lstat(remotePath) {\n    try {\n      haveConnection(this, 'lstat');\n      return await this._xstat('lstat', remotePath);\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(err, 'lstat', err.code);\n    }\n  }\n\n  /**\n   * @async\n   *\n   * Tests to see if an object exists. If it does, return the type of that object\n   * (in the format returned by list). If it does not exist, return false.\n   *\n   * @param {string} remotePath - path to the object on the sftp server.\n   *\n   * @return {Promise<Boolean|String>} returns false if object does not exist. Returns type of\n   *                   object if it does\n   */\n  async exists(remotePath) {\n    try {\n      if (remotePath === '.') {\n        return 'd';\n      }\n      const info = await this.lstat(remotePath);\n      if (info.isDirectory) {\n        return 'd';\n      } else if (info.isSymbolicLink) {\n        return 'l';\n      } else if (info.isFile) {\n        return '-';\n      } else {\n        return false;\n      }\n    } catch (err) {\n      if (err.code === errorCode.notexist) {\n        return false;\n      }\n      throw err.custom ? err : this.fmtError(err.message, 'exists', err.code);\n    }\n  }\n\n  /**\n   * @async\n   *\n   * List contents of a remote directory. If a pattern is provided,\n   * filter the results to only include files with names that match\n   * the supplied pattern. Return value is an array of file entry\n   * objects that include properties for type, name, size, modifyTime,\n   * accessTime, rights {user, group other}, owner and group.\n   *\n   * @param {String} remotePath - path to remote directory\n   * @param {function} filter - a filter function used to select return entries\n   * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true\n   * @returns {Promise<Array>} array of file description objects\n   */\n  list(remotePath, filter, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'list', reject);\n      }\n      if (haveConnection(this, 'list', reject)) {\n        this.sftp.readdir(remotePath, (err, fileList) => {\n          if (err) {\n            reject(this.fmtError(`${err.message} ${remotePath}`, 'list', err.code));\n          } else {\n            const reg = /-/gi;\n            const newList = fileList.map(item => {\n              return {\n                type: item.longname.slice(0, 1),\n                name: item.filename,\n                size: item.attrs.size,\n                modifyTime: item.attrs.mtime * 1000,\n                accessTime: item.attrs.atime * 1000,\n                rights: {\n                  user: item.longname.slice(1, 4).replaceAll(reg, ''),\n                  group: item.longname.slice(4, 7).replaceAll(reg, ''),\n                  other: item.longname.slice(7, 10).replaceAll(reg, '')\n                },\n                owner: item.attrs.uid,\n                group: item.attrs.gid,\n                longname: item.longname\n              };\n            });\n            if (filter) {\n              resolve(newList.filter(item => filter(item)));\n            } else {\n              resolve(newList);\n            }\n          }\n        });\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, 'list');\n      }\n    });\n  }\n\n  /**\n   * get file\n   *\n   * If a dst argument is provided, it must be either a string, representing the\n   * local path to where the data will be put, a stream, in which case data is\n   * piped into the stream or undefined, in which case the data is returned as\n   * a Buffer object.\n   *\n   * @param {String} remotePath - remote file path\n   * @param {string|stream|undefined} dst - data destination\n   * @param {Object} options - options object with supported properties of readStreamOptions,\n   *                          writeStreamOptions and pipeOptions.\n   * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true\n   *\n   * *Important Note*: The ability to set ''autoClose' on read/write streams and 'end' on pipe() calls\n   * is no longer supported. New methods 'createReadStream()' and 'createWriteStream()' have been\n   * added to support low-level access to stream objects.\n   *\n   * @return {Promise<String|Stream|Buffer>}\n   */\n  get(remotePath, dst, options, addListeners = true) {\n    let listeners, rdr, wtr;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'get', reject);\n      }\n      if (haveConnection(this, 'get', reject)) {\n        options = {\n          readStreamOptions: {\n            ...options?.readStreamOptions,\n            autoClose: true\n          },\n          writeStreamOptions: {\n            ...options?.writeStreamOptions,\n            autoClose: true\n          },\n          pipeOptions: {\n            ...options?.pipeOptions,\n            end: true\n          }\n        };\n        rdr = this.sftp.createReadStream(remotePath, options.readStreamOptions);\n        rdr.once('error', err => {\n          if (dst && typeof dst === 'string' && wtr && !wtr.destroyed) {\n            wtr.destroy();\n          }\n          reject(this.fmtError(`${err.message} ${remotePath}`, 'get', err.code));\n        });\n        if (dst === undefined) {\n          // no dst specified, return buffer of data\n          this.debugMsg('get resolving with buffer of data');\n          wtr = concat(buff => {\n            resolve(buff);\n          });\n        } else if (typeof dst === 'string') {\n          // dst local file path\n          this.debugMsg(`get called with file path destination ${dst}`);\n          const localCheck = haveLocalCreate(dst);\n          if (localCheck.status) {\n            wtr = fs.createWriteStream(dst, options.writeStreamOptions);\n          } else {\n            reject(this.fmtError(`Bad path: ${dst}: ${localCheck.details}`, 'get', localCheck.code));\n          }\n        } else {\n          this.debugMsg('get called with stream destination');\n          wtr = dst;\n        }\n        wtr.once('error', err => {\n          reject(this.fmtError(`${err.message} ${typeof dst === 'string' ? dst : '<stream>'}`, 'get', err.code));\n        });\n        rdr.once('end', () => {\n          if (typeof dst === 'string') {\n            resolve(dst);\n          } else if (dst !== undefined) {\n            resolve(wtr);\n          }\n        });\n        rdr.pipe(wtr, options.pipeOptions);\n      }\n    }).finally(() => {\n      if (rdr && !rdr.destroyed) {\n        rdr.destroy();\n      }\n      if (addListeners) {\n        removeTempListeners(this, listeners, 'get');\n      }\n    });\n  }\n\n  /**\n   * Use SSH2 fastGet for downloading the file.\n   * Downloads a file at remotePath to localPath using parallel reads\n   * for faster throughput.\n   *\n   * WARNING: The functionality of fastGet is heavily dependent on the capabilities\n   * of the remote SFTP server. Not all sftp server support or fully support this\n   * functionality. See the Platform Quirks & Warnings section of the README.\n   *\n   * @param {String} remotePath\n   * @param {String} localPath\n   * @param {Object} options\n   * @return {Promise<String>} the result of downloading the file\n   */\n  _fastGet(rPath, lPath, opts, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, '_fastGet', reject);\n      }\n      if (haveConnection(this, '_fastGet', reject)) {\n        this.sftp.fastGet(rPath, lPath, opts, err => {\n          if (err) {\n            reject(this.fmtError(`${err.message} Remote: ${rPath} Local: ${lPath}`));\n          }\n          resolve(`${rPath} was successfully download to ${lPath}!`);\n        });\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, '_fastGet');\n      }\n    });\n  }\n  async fastGet(remotePath, localPath, options) {\n    try {\n      const ftype = await this.exists(remotePath);\n      if (ftype !== '-') {\n        const msg = `${ftype ? 'Not a regular file' : 'No such file '} ${remotePath}`;\n        throw this.fmtError(msg, 'fastGet', errorCode.badPath);\n      }\n      const localCheck = haveLocalCreate(localPath);\n      if (!localCheck.status) {\n        throw this.fmtError(`Bad path: ${localPath}: ${localCheck.details}`, 'fastGet', errorCode.badPath);\n      }\n      return await this._fastGet(remotePath, localPath, options);\n    } catch (err) {\n      throw this.fmtError(err, 'fastGet');\n    }\n  }\n\n  /**\n   * Use SSH2 fastPut for uploading the file.\n   * Uploads a file from localPath to remotePath using parallel reads\n   * for faster throughput.\n   *\n   * See 'fastPut' at\n   * https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md\n   *\n   * WARNING: The fastPut functionality is heavily dependent on the capabilities of\n   * the remote sftp server. Many sftp servers do not support or do not fully support this\n   * functionality. See the Platform Quirks & Warnings section of the README for more details.\n   *\n   * @param {String} localPath - path to local file to put\n   * @param {String} remotePath - destination path for put file\n   * @param {Object} options - additonal fastPut options\n   * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true.\n   * @return {Promise<String>} the result of downloading the file\n   */\n  _fastPut(lPath, rPath, opts, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, '_fastPut', reject);\n      }\n      if (haveConnection(this, '_fastPut', reject)) {\n        this.sftp.fastPut(lPath, rPath, opts, err => {\n          if (err) {\n            reject(this.fmtError(`${err.message} Local: ${lPath} Remote: ${rPath}`, 'fastPut', err.code));\n          }\n          resolve(`${lPath} was successfully uploaded to ${rPath}!`);\n        });\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, '_fastPut');\n      }\n    });\n  }\n  async fastPut(localPath, remotePath, options) {\n    try {\n      const localCheck = haveLocalAccess(localPath);\n      if (!localCheck.status) {\n        throw this.fmtError(`Bad path: ${localPath}: ${localCheck.details}`, 'fastPut', localCheck.code);\n      } else if (localCheck.status && localExists(localPath) === 'd') {\n        throw this.fmtError(`Bad path: ${localPath} not a regular file`, 'fastgPut', errorCode.badPath);\n      }\n      return await this._fastPut(localPath, remotePath, options);\n    } catch (e) {\n      throw e.custom ? e : this.fmtError(e.message, 'fastPut', e.code);\n    }\n  }\n\n  /**\n   * Create a file on the remote server. The 'src' argument\n   * can be a buffer, string or read stream. If 'src' is a string, it\n   * should be the path to a local file.\n   *\n   * @param  {String|Buffer|stream} localSrc - source data to use\n   * @param  {String} remotePath - path to remote file\n   * @param  {Object} options - options used for read, write stream and pipe configuration\n   *                            value supported by node. Allowed properties are readStreamOptions,\n   *                            writeStreamOptions and pipeOptions.\n   *\n   * *Important Note*: The ability to set ''autoClose' on read/write streams and 'end' on pipe() calls\n   * is no longer supported. New methods 'createReadStream()' and 'createWriteStream()' have been\n   * added to support low-level access to stream objects.\n   *\n   * @return {Promise<String>}\n   */\n  _put(lPath, rPath, opts, addListeners = true) {\n    let listeners, wtr, rdr;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, '_put', reject);\n      }\n      opts = {\n        readStreamOptions: {\n          ...opts?.readStreamOptions,\n          autoClose: true\n        },\n        writeStreamOptions: {\n          ...opts?.writeStreamOptions,\n          autoClose: true\n        },\n        pipeOptions: {\n          ...opts?.pipeOptions,\n          end: true\n        }\n      };\n      if (haveConnection(this, '_put', reject)) {\n        wtr = this.sftp.createWriteStream(rPath, opts.writeStreamOptions);\n        wtr.once('error', err => {\n          if (typeof lPath === 'string' && rdr && !rdr.destroyed) {\n            rdr.destroy();\n          }\n          reject(this.fmtError(`Write stream error: ${err.message} ${rPath}`, '_put', err.code));\n        });\n        wtr.once('close', () => {\n          resolve(`Uploaded data stream to ${rPath}`);\n        });\n        if (lPath instanceof Buffer) {\n          this.debugMsg('put source is a buffer');\n          wtr.end(lPath);\n        } else {\n          if (typeof lPath === 'string') {\n            this.debugMsg('put source is string path');\n            rdr = fs.createReadStream(lPath, opts.readStreamOptions);\n          } else {\n            this.debugMsg('put source is a stream');\n            rdr = lPath;\n          }\n          rdr.once('error', err => {\n            reject(this.fmtError(`Read stream error: ${err.message} ${typeof lPath === 'string' ? lPath : '<stream>'}`, '_put', err.code));\n          });\n          rdr.pipe(wtr, opts.pipeOptions);\n        }\n      }\n    }).finally(() => {\n      if (wtr && !wtr.destroyed) {\n        wtr.destroy();\n      }\n      if (addListeners) {\n        removeTempListeners(this, listeners, '_put');\n      }\n    });\n  }\n  async put(localSrc, remotePath, options) {\n    try {\n      if (typeof localSrc === 'string') {\n        const localCheck = haveLocalAccess(localSrc);\n        if (!localCheck.status) {\n          throw this.fmtError(`Bad path: ${localSrc} ${localCheck.details}`, 'put', localCheck.code);\n        }\n      }\n      return await this._put(localSrc, remotePath, options);\n    } catch (e) {\n      throw e.custom ? e : this.fmtError(`Re-thrown: ${e.message}`, 'put', e.code);\n    }\n  }\n\n  /**\n   * Append to an existing remote file\n   *\n   * @param  {Buffer|stream} input\n   * @param  {String} remotePath\n   * @param  {Object} options\n   * @return {Promise<String>}\n   */\n  _append(input, rPath, opts, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, '_append', reject);\n      }\n      if (haveConnection(this, '_append', reject)) {\n        opts.flags = 'a';\n        const stream = this.sftp.createWriteStream(rPath, opts);\n        stream.on('error', err => {\n          reject(this.fmtError(`${err.message} ${rPath}`, 'append', err.code));\n        });\n        stream.on('close', () => {\n          resolve(`Appended data to ${rPath}`);\n        });\n        if (input instanceof Buffer) {\n          stream.write(input);\n          stream.end();\n        } else {\n          input.pipe(stream);\n        }\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, '_append');\n      }\n    });\n  }\n  async append(input, remotePath, options = {}) {\n    try {\n      if (typeof input === 'string') {\n        throw this.fmtError('Cannot append one file to another', 'append', errorCode.badPath);\n      }\n      const fileType = await this.exists(remotePath);\n      if (fileType && fileType === 'd') {\n        throw this.fmtError(`Bad path: ${remotePath}: cannot append to a directory`, 'append', errorCode.badPath);\n      }\n      return await this._append(input, remotePath, options);\n    } catch (e) {\n      throw e.custom ? e : this.fmtError(e.message, 'append', e.code);\n    }\n  }\n\n  /**\n   * @async\n   *\n   * Make a directory on remote server\n   *\n   * @param {string} remotePath - remote directory path.\n   * @param {boolean} recursive - if true, recursively create directories\n   * @return {Promise<String>}\n   */\n  _doMkdir(p, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, '_doMkdir', reject);\n      }\n      this.sftp.mkdir(p, err => {\n        if (err) {\n          if (err.code === 4) {\n            //fix for windows dodgy error messages\n            reject(this.fmtError(`Bad path: ${p} permission denied`, '_doMkdir', errorCode.badPath));\n          } else if (err.code === 2) {\n            reject(this.fmtError(`Bad path: ${p} parent not a directory or not exist`, '_doMkdir', errorCode.badPath));\n          } else {\n            reject(this.fmtError(`${err.message} ${p}`, '_doMkdir', err.code));\n          }\n        } else {\n          resolve(`${p} directory created`);\n        }\n      });\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, '_doMkdir');\n      }\n    });\n  }\n  async _mkdir(remotePath, recursive) {\n    try {\n      const rPath = await normalizeRemotePath(this, remotePath);\n      const targetExists = await this.exists(rPath);\n      if (targetExists && targetExists !== 'd') {\n        throw this.fmtError(`Bad path: ${rPath} already exists as a file`, '_mkdir', errorCode.badPath);\n      } else if (targetExists) {\n        return `${rPath} already exists`;\n      }\n      if (!recursive) {\n        return await this._doMkdir(rPath);\n      }\n      const dir = parse(rPath).dir;\n      if (dir) {\n        const dirExists = await this.exists(dir);\n        if (!dirExists) {\n          await this._mkdir(dir, true);\n        } else if (dirExists !== 'd') {\n          throw this.fmtError(`Bad path: ${dir} not a directory`, '_mkdir', errorCode.badPath);\n        }\n      }\n      return await this._doMkdir(rPath);\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(`${err.message} ${remotePath}`, '_mkdir', err.code);\n    }\n  }\n  async mkdir(remotePath, recursive = false) {\n    try {\n      haveConnection(this, 'mkdir');\n      return await this._mkdir(remotePath, recursive);\n    } catch (err) {\n      throw this.fmtError(`${err.message}`, 'mkdir', err.code);\n    }\n  }\n\n  /**\n   * @async\n   *\n   * Remove directory on remote server\n   *\n   * @param {string} remotePath - path to directory to be removed\n   * @param {boolean} recursive - if true, remove directories/files in target\n   *                             directory\n   * @return {Promise<String>}\n   */\n  async rmdir(remoteDir, recursive = false) {\n    const _rmdir = dir => {\n      let listeners;\n      return new Promise((resolve, reject) => {\n        listeners = addTempListeners(this, '_rmdir', reject);\n        this.sftp.rmdir(dir, err => {\n          if (err) {\n            reject(this.fmtError(`${err.message} ${dir}`, 'rmdir', err.code));\n          }\n          resolve('Successfully removed directory');\n        });\n      }).finally(() => {\n        removeTempListeners(this, listeners, '_rmdir');\n      });\n    };\n    const _delFiles = (path, fileList) => {\n      let listeners;\n      return new Promise((resolve, reject) => {\n        listeners = addTempListeners(this, '_delFiles', reject);\n        const pList = [];\n        for (const f of fileList) {\n          pList.push(this.delete(`${path}/${f.name}`, true, false));\n        }\n        resolve(pList);\n      }).then(p => {\n        return Promise.all(p);\n      }).finally(() => {\n        removeTempListeners(this, listeners, '_delFiles');\n      });\n    };\n    try {\n      const absPath = await normalizeRemotePath(this, remoteDir);\n      const existStatus = await this.exists(absPath);\n      if (!existStatus) {\n        throw this.fmtError(`Bad Path: ${remoteDir}: No such directory`, 'rmdir', errorCode.badPath);\n      }\n      if (existStatus !== 'd') {\n        throw this.fmtError(`Bad Path: ${remoteDir}: Not a directory`, 'rmdir', errorCode.badPath);\n      }\n      if (!recursive) {\n        return await _rmdir(absPath);\n      }\n      const listing = await this.list(absPath);\n      if (!listing.length) {\n        return await _rmdir(absPath);\n      }\n      const fileList = listing.filter(i => i.type !== 'd');\n      const dirList = listing.filter(i => i.type === 'd');\n      await _delFiles(absPath, fileList);\n      for (const d of dirList) {\n        await this.rmdir(`${absPath}/${d.name}`, true);\n      }\n      await _rmdir(absPath);\n      return 'Successfully removed directory';\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(`${err.message} ${remoteDir}`, 'rmdir', err.code);\n    }\n  }\n\n  /**\n   * @async\n   *\n   * Delete a file on the remote SFTP server\n   *\n   * @param {string} remotePath - path to the file to delete\n   * @param {boolean} notFoundOK - if true, ignore errors for missing target.\n   *                               Default is false.\n   * @return {Promise<String>} with string 'Successfully deleted file' once resolved\n   */\n  delete(remotePath, notFoundOK = false, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'delete', reject);\n      }\n      this.sftp.unlink(remotePath, err => {\n        if (err) {\n          if (notFoundOK && err.code === 2) {\n            resolve(`Successfully deleted ${remotePath}`);\n          } else {\n            reject(this.fmtError(`${err.message} ${remotePath}`, 'delete', err.code));\n          }\n        }\n        resolve(`Successfully deleted ${remotePath}`);\n      });\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, 'delete');\n      }\n    });\n  }\n\n  /**\n   * @async\n   *\n   * Rename a file on the remote SFTP repository\n   *\n   * @param {string} fromPath - path to the file to be renamed.\n   * @param {string} toPath - path to the new name.\n   * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true\n   *\n   * @return {Promise<String>}\n   */\n  rename(fPath, tPath, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'rename', reject);\n      }\n      if (haveConnection(this, 'rename', reject)) {\n        this.sftp.rename(fPath, tPath, err => {\n          if (err) {\n            reject(this.fmtError(`${err.message} From: ${fPath} To: ${tPath}`, '_rename', err.code));\n          }\n          resolve(`Successfully renamed ${fPath} to ${tPath}`);\n        });\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, 'rename');\n      }\n    });\n  }\n\n  /**\n   * @async\n   *\n   * Rename a file on the remote SFTP repository using the SSH extension\n   * posix-rename@openssh.com using POSIX atomic rename. (Introduced in SSH 4.8)\n   *\n   * @param {string} fromPath - path to the file to be renamed.\n   * @param {string} toPath - path  the new name.\n   * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true\n   *\n   * @return {Promise<String>}\n   */\n  posixRename(fPath, tPath, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'posixRename', reject);\n      }\n      if (haveConnection(this, 'posixRename', reject)) {\n        this.sftp.ext_openssh_rename(fPath, tPath, err => {\n          if (err) {\n            reject(this.fmtError(`${err.message} From: ${fPath} To: ${tPath}`, '_posixRename', err.code));\n          }\n          resolve(`Successful POSIX rename ${fPath} to ${tPath}`);\n        });\n      }\n    }).finally(() => {\n      removeTempListeners(this, listeners, 'posixRename');\n    });\n  }\n\n  /**\n   * @async\n   *\n   * Change the mode of a remote file on the SFTP repository\n   *\n   * @param {string} remotePath - path to the remote target object.\n   * @param {number | string} mode - the new octal mode to set\n   * @param {boolean} addListeners - (Optional) if true, add listeners. Default true.\n   *\n   * @return {Promise<String>}\n   */\n  chmod(rPath, mode, addListeners = true) {\n    let listeners;\n    return new Promise((resolve, reject) => {\n      if (addListeners) {\n        listeners = addTempListeners(this, 'chmod', reject);\n      }\n      if (haveConnection(this, 'chmod', reject)) {\n        this.sftp.chmod(rPath, mode, err => {\n          if (err) {\n            reject(this.fmtError(`${err.message} ${rPath}`, '_chmod', err.code));\n          }\n          resolve('Successfully change file mode');\n        });\n      }\n    }).finally(() => {\n      if (addListeners) {\n        removeTempListeners(this, listeners, 'chmod');\n      }\n    });\n  }\n\n  /**\n   * @async\n   *\n   * Upload the specified source directory to the specified destination\n   * directory. All regular files and sub-directories are uploaded to the remote\n   * server.\n   * @param {String} srcDir - local source directory\n   * @param {String} dstDir - remote destination directory\n   * @param {Object} options - (Optional) An object with 2 supported properties,\n   * 'filter' and 'useFastput'. Filter is a function of two arguments.\n   * The first argument is the full path of a directory entry from the directory\n   * to be uploaded and the second argument is a boolean, which will be true if\n   * the target path is for a directory. If the function returns true, this item\n   * will be uploaded and excluded when it returns false. The 'useFastput' property is a\n   * boolean value. When true, the 'fastPut()' method will be used to upload files. Default\n   * is to use the slower, but more supported 'put()' method.\n   *\n   * @returns {Promise<Array>}\n   */\n  async uploadDir(srcDir, dstDir, options) {\n    const getRemoteStatus = async dstDir => {\n      const absDstDir = await normalizeRemotePath(this, dstDir);\n      const status = await this.exists(absDstDir);\n      if (status && status !== 'd') {\n        throw this.fmtError(`Bad path ${absDstDir} Not a directory`, 'getRemoteStatus', errorCode.badPath);\n      }\n      return {\n        remoteDir: absDstDir,\n        remoteStatus: status\n      };\n    };\n    const checkLocalStatus = srcDir => {\n      const srcType = localExists(srcDir);\n      if (!srcType) {\n        throw this.fmtError(`Bad path: ${srcDir} not exist`, 'getLocalStatus', errorCode.badPath);\n      }\n      if (srcType !== 'd') {\n        throw this.fmtError(`Bad path: ${srcDir}: not a directory`, 'getLocalStatus', errorCode.badPath);\n      }\n      return srcType;\n    };\n    const uploadFiles = async (srcDir, dstDir, fileList, useFastput) => {\n      let listeners = addTempListeners(this, 'uploadFiles');\n      try {\n        const uploadList = [];\n        for (const f of fileList) {\n          const src = join(srcDir, f.name);\n          const dst = `${dstDir}/${f.name}`;\n          uploadList.push([src, dst]);\n        }\n        const uploadGroups = partition(uploadList, this.promiseLimit);\n        const func = useFastput ? this._fastPut.bind(this) : this._put.bind(this);\n        const uploadResults = [];\n        for (const group of uploadGroups) {\n          const pList = [];\n          for (const [src, dst] of group) {\n            pList.push(func(src, dst, null, false));\n            this.client.emit('upload', {\n              source: src,\n              destination: dst\n            });\n          }\n          const groupResults = await Promise.all(pList);\n          for (const r of groupResults) {\n            uploadResults.push(r);\n          }\n        }\n        return uploadResults;\n      } catch (e) {\n        throw this.fmtError(`${e.message} ${srcDir} to ${dstDir}`, 'uploadFiles', e.code);\n      } finally {\n        removeTempListeners(this, listeners, uploadFiles);\n      }\n    };\n    try {\n      haveConnection(this, 'uploadDir');\n      const {\n        remoteDir,\n        remoteStatus\n      } = await getRemoteStatus(dstDir);\n      checkLocalStatus(srcDir);\n      if (!remoteStatus) {\n        await this._mkdir(remoteDir, true);\n      }\n      let dirEntries = fs.readdirSync(srcDir, {\n        encoding: 'utf8',\n        withFileTypes: true\n      });\n      if (options?.filter) {\n        dirEntries = dirEntries.filter(item => options.filter(join(srcDir, item.name), item.isDirectory()));\n      }\n      const dirUploads = dirEntries.filter(item => item.isDirectory());\n      const fileUploads = dirEntries.filter(item => !item.isDirectory());\n      await uploadFiles(srcDir, remoteDir, fileUploads, options?.useFastput);\n      for (const d of dirUploads) {\n        const src = join(srcDir, d.name);\n        const dst = `${remoteDir}/${d.name}`;\n        await this.uploadDir(src, dst, options);\n      }\n      return `${srcDir} uploaded to ${dstDir}`;\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(`${err.message} ${srcDir}`, 'uploadDir', err.code);\n    }\n  }\n\n  /**\n   * @async\n   *\n   * Download the specified source directory to the specified destination\n   * directory. All regular files and sub-directories are downloaded to the local\n   * file system.\n   * @param {String} srcDir - remote source directory\n   * @param {String} dstDir - local destination directory\n   * @param {Object} options - (Optional) Object with 2 supported properties,\n   * 'filter' and 'useFastget'. The filter property is a function of two\n   * arguments. The first argument is the full path of the item to be downloaded\n   * and the second argument is a boolean, which will be true if the target path\n   * is for a directory. If the function returns true, the item will be\n   * downloaded and excluded if teh function returns false.\n   *\n   * @returns {Promise<Array>}\n   */\n  async downloadDir(srcDir, dstDir, options = {\n    filter: null,\n    useFastget: false\n  }) {\n    const getDownloadList = async (srcDir, filter) => {\n      try {\n        const listing = await this.list(srcDir);\n        if (filter) {\n          return listing.filter(item => filter(`${srcDir}/${item.name}`, item.type === 'd'));\n        }\n        return listing;\n      } catch (err) {\n        throw err.custom ? err : this.fmtError(err.message, '_getDownloadList', err.code);\n      }\n    };\n    const prepareDestination = dst => {\n      try {\n        const localCheck = haveLocalCreate(dst);\n        if (!localCheck.status && localCheck.details === 'permission denied') {\n          throw this.fmtError(`Bad path: ${dst}: ${localCheck.details}`, 'prepareDestination', localCheck.code);\n        } else if (localCheck.status && !localCheck.type) {\n          fs.mkdirSync(dst, {\n            recursive: true\n          });\n        } else if (localCheck.status && localCheck.type !== 'd') {\n          throw this.fmtError(`Bad path: ${dstDir}: not a directory`, '_prepareDestination', errorCode.badPath);\n        }\n      } catch (err) {\n        throw err.custom ? err : this.fmtError(err.message, '_prepareDestination', err.code);\n      }\n    };\n    const downloadFiles = async (remotePath, localPath, fileList, useFastget) => {\n      let listeners = addTempListeners(this, 'downloadFIles');\n      try {\n        const downloadList = [];\n        for (const f of fileList) {\n          const src = `${remotePath}/${f.name}`;\n          const dst = join(localPath, f.name);\n          downloadList.push([src, dst]);\n        }\n        const downloadGroups = partition(downloadList, this.promiseLimit);\n        const func = useFastget ? this._fastGet.bind(this) : this.get.bind(this);\n        const downloadResults = [];\n        for (const group of downloadGroups) {\n          const pList = [];\n          for (const [src, dst] of group) {\n            pList.push(func(src, dst, null, false));\n            this.client.emit('download', {\n              source: src,\n              destination: dst\n            });\n          }\n          const groupResults = await Promise.all(pList);\n          for (const r of groupResults) {\n            downloadResults.push(r);\n          }\n        }\n        return downloadResults;\n      } catch (e) {\n        throw this.fmtError(`${e.message} ${srcDir} to ${dstDir}`, 'downloadFiles', e.code);\n      } finally {\n        removeTempListeners(this, listeners, 'downloadFiles');\n      }\n    };\n    try {\n      haveConnection(this, 'downloadDir');\n      const downloadList = await getDownloadList(srcDir, options.filter);\n      prepareDestination(dstDir);\n      const fileDownloads = downloadList.filter(i => i.type !== 'd');\n      if (fileDownloads.length) {\n        await downloadFiles(srcDir, dstDir, fileDownloads, options.useFastget);\n      }\n      const dirDownloads = downloadList.filter(i => i.type === 'd');\n      for (const d of dirDownloads) {\n        const src = `${srcDir}/${d.name}`;\n        const dst = join(dstDir, d.name);\n        await this.downloadDir(src, dst, options);\n      }\n      return `${srcDir} downloaded to ${dstDir}`;\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(`${err.message}: ${srcDir}`, 'downloadDir', err.code);\n    }\n  }\n\n  /**\n   * Returns a read stream object. This is a low level method which will return a read stream\n   * connected to the remote file object specified as an argument. Client code is fully responsible\n   * for managing this stream object i.e. adding any necessary listeners and disposing of the object etc.\n   * See the SSH2 sftp documentation for details on possible options which can be used.\n   *\n   * @param {String} remotePath - path to remote file to attach stream to\n   * @param {Object} options - options to pass to the create stream process\n   *\n   * @returns {Object} a read stream object\n   */\n  createReadStream(remotePath, options) {\n    let listeners;\n    try {\n      listeners = addTempListeners(this, 'createReadStream');\n      haveConnection(this, 'createReadStream');\n      const stream = this.sftp.createReadStream(remotePath, options);\n      return stream;\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(err.message, 'createReadStream', err.code);\n    } finally {\n      removeTempListeners(this, listeners, 'createReadStream');\n    }\n  }\n\n  /**\n   * Create a write stream object connected to a file on the remote sftp server.\n   * This is a low level method which will return a write stream for the remote file specified\n   * in the 'remotePath' argument. Client code to responsible for managing this object once created.\n   * This includes disposing of file handles, setting up any necessary event listeners etc.\n   *\n   * @param {String} remotePath - path to the remote file on the sftp server\n   * @param (Object} options - options to pass to the create write stream process)\n   *\n   * @returns {Object} a stream object\n   */\n  createWriteStream(remotePath, options) {\n    let listeners;\n    try {\n      listeners = addTempListeners(this, 'createWriteStream');\n      haveConnection(this, 'createWriteStream');\n      const stream = this.sftp.createWriteStream(remotePath, options);\n      return stream;\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(err.message, 'createWriteStream', err.code);\n    } finally {\n      removeTempListeners(this, listeners, 'createWriteStream');\n    }\n  }\n\n  /**\n   * @async\n   *\n   * Make a remote copy of a remote file. Create a copy of a remote file on the remote\n   * server. It is assumed the directory where the copy will be placed already exists.\n   * The destination file must not already exist.\n   *\n   * @param {String} srcPath - path to the remote file to be copied\n   * @param {String} dstPath - destination path for the copy.\n   *\n   * @returns {String}.\n   */\n  _rcopy(srcPath, dstPath) {\n    return new Promise((resolve, reject) => {\n      const ws = this.sftp.createWriteStream(dstPath);\n      const rs = this.sftp.createReadStream(srcPath);\n      ws.on('error', err => {\n        reject(this.fmtError(`${err.message} ${dstPath}`, '_rcopy'));\n      });\n      rs.on('error', err => {\n        reject(this.fmtError(`${err.message} ${srcPath}`, '_rcopy'));\n      });\n      ws.on('close', () => {\n        resolve(`${srcPath} copied to ${dstPath}`);\n      });\n      rs.pipe(ws);\n    });\n  }\n  async rcopy(src, dst) {\n    let listeners;\n    try {\n      listeners = addTempListeners(this, 'rcopy');\n      haveConnection(this, 'rcopy');\n      const srcPath = await normalizeRemotePath(this, src);\n      const srcExists = await this.exists(srcPath);\n      if (!srcExists) {\n        throw this.fmtError(`Source does not exist ${srcPath}`, 'rcopy', errorCode.badPath);\n      }\n      if (srcExists !== '-') {\n        throw this.fmtError(`Source not a file ${srcPath}`, 'rcopy', errorCode.badPath);\n      }\n      const dstPath = await normalizeRemotePath(this, dst);\n      const dstExists = await this.exists(dstPath);\n      if (dstExists) {\n        throw this.fmtError(`Destination already exists ${dstPath}`, 'rcopy', errorCode.badPath);\n      }\n      return this._rcopy(srcPath, dstPath);\n    } catch (err) {\n      throw err.custom ? err : this.fmtError(err, 'rcopy');\n    } finally {\n      removeTempListeners(this, listeners, 'rcopy');\n    }\n  }\n  /**\n   * @async\n   *\n   * End the SFTP connection\n   *\n   * @returns {Promise<Boolean>}\n   */\n  end() {\n    let endCloseHandler, listeners;\n    return new Promise((resolve, reject) => {\n      listeners = addTempListeners(this, 'end', reject);\n      this.endCalled = true;\n      endCloseHandler = () => {\n        this.sftp = undefined;\n        this.debugMsg('end: Connection closed');\n        resolve(true);\n      };\n      this.on('close', endCloseHandler);\n      if (this.sftp) {\n        this.debugMsg('end: Ending SFTP connection');\n        this.client.end();\n      } else {\n        // no actual connection exists - just resolve\n        this.debugMsg('end: Called when no connection active');\n        resolve(true);\n      }\n    }).finally(() => {\n      removeTempListeners(this, listeners, 'end');\n      this.removeListener('close', endCloseHandler);\n    });\n  }\n}\nmodule.exports = SftpClient;","const {\n  statSync,\n  constants,\n  accessSync\n} = require('node:fs');\nconst {\n  dirname\n} = require('node:path');\nconst {\n  errorCode\n} = require('./constants.js');\nfunction eventHandled(client) {\n  if (client.errorHandled || client.endHandled || client.closeHandled) {\n    return true;\n  }\n  return false;\n}\nfunction globalListener(client, evt, eventCallbacks) {\n  if (evt === 'error') {\n    return err => {\n      if (client.errorHandled) {\n        client.debugMsg(`Global error event: Ignoring handled error ${err.message}`);\n        return;\n      }\n      client.debugMsg(`Global error event: ${err.message}`);\n      client.errorHandled = true;\n      if (eventCallbacks?.error) {\n        eventCallbacks.error(err);\n      }\n    };\n  }\n  if (evt === 'end') {\n    return () => {\n      if (client.endCalled || client.endHandled) {\n        client.debugMsg('Global end event: Ignoring handled end event');\n        return;\n      }\n      client.debugMsg('Global end event: Handling end event');\n      client.endHandled = true;\n      if (eventCallbacks?.end) {\n        eventCallbacks.end();\n      }\n    };\n  }\n  return () => {\n    if (client.endCalled || client.closeHandled) {\n      client.debugMsg('Global close event: Ignoring handled close event');\n    } else {\n      client.debugMsg('Global close event: Handling close event');\n      client.closeHandled = true;\n      client.sftp = undefined;\n      if (eventCallbacks?.close) {\n        eventCallbacks.close();\n      }\n    }\n  };\n}\n\n/**\n * Simple default error listener. Will reformat the error message and\n * throw a new error.\n *\n * @param {Error} err - source for defining new error\n * @throws {Error} Throws new error\n */\nfunction errorListener(client, name, reject) {\n  const fn = function (err) {\n    if (eventHandled(client)) {\n      // error already handled or expected - ignore\n      client.debugMsg(`${name} errorListener - ignoring handled error ${err.message}`);\n      return;\n    }\n    client.debugMsg(`${name} errorListener - handling error ${err.message}`);\n    client.errorHandled = true;\n    const newError = new Error(`${name}: ${err.message}`);\n    newError.code = err.code;\n    if (reject) {\n      reject(newError);\n    } else {\n      throw newError;\n    }\n  };\n  return fn;\n}\nfunction endListener(client, name, reject) {\n  const fn = function () {\n    client.sftp = undefined;\n    if (client.endCalled || eventHandled(client)) {\n      // end event already handled - ignore\n      client.debugMsg(`${name} endListener - ignoring handled end event`);\n      return;\n    }\n    client.endHandled = true;\n    client.debugMsg(`${name} endListener - handling unexpected end event`);\n    const newError = new Error(`${name}: Unexpected end event`);\n    newError.code = errorCode.ERR_GENERIC_CLIENT;\n    if (reject) {\n      reject(newError);\n    } else {\n      throw newError;\n    }\n  };\n  return fn;\n}\nfunction closeListener(client, name, reject) {\n  const fn = function () {\n    client.sftp = undefined;\n    if (client.endCalled || eventHandled(client)) {\n      // handled or expected close event - ignore\n      client.debugMsg(`${name} closeListener - ignoring handled close event`);\n      return;\n    }\n    client.closeHandled = true;\n    client.debugMsg(`${name} closeListener - handling unexpected close event`);\n    const newError = new Error(`${name}: Unexpected close event`);\n    newError.code = errorCode.ERR_GENERIC_CLIENT;\n    if (reject) {\n      reject(newError);\n    } else {\n      throw newError;\n    }\n  };\n  return fn;\n}\nfunction addTempListeners(client, name, reject) {\n  const listeners = {\n    end: endListener(client, name, reject),\n    close: closeListener(client, name, reject),\n    error: errorListener(client, name, reject)\n  };\n  client.on('end', listeners.end);\n  client.on('close', listeners.close);\n  client.on('error', listeners.error);\n  client._resetEventFlags();\n  return listeners;\n}\nfunction removeTempListeners(client, listeners, name) {\n  try {\n    client.removeListener('end', listeners.end);\n    client.removeListener('close', listeners.close);\n    client.removeListener('error', listeners.error);\n  } catch (err) {\n    throw new Error(`${name}: Error removing temp listeners: ${err.message}`);\n  }\n}\n\n/**\n * Checks to verify local object exists. Returns a character string representing the type\n * type of local object if it exists, false if it doesn't.\n *\n * Return codes: l = symbolic link\n *               - = regular file\n *               d = directory\n *               s = socket\n *\n * @param {string} filePath - path to local object\n * @returns {string | boolean} returns a string for object type if it exists, false otherwise\n */\nfunction localExists(filePath) {\n  const stats = statSync(filePath, {\n    throwIfNoEntry: false\n  });\n  if (!stats) {\n    return false;\n  } else if (stats.isDirectory()) {\n    return 'd';\n  } else if (stats.isFile()) {\n    return '-';\n  } else {\n    const err = new Error(`Bad path: ${filePath}: target must be a file or directory`);\n    err.code = errorCode.badPath;\n    throw err;\n  }\n}\n\n/**\n * Verify access to local object. Returns an object with properties for status, type,\n * details and code.\n *\n * return object {\n *                 status: true if exists and can be accessed, false otherwise\n *                 type: type of object '-' = file, 'd' = dir, 'l' = link, 's' = socket\n *                 details: 'access ok' if object can be accessed, 'not found' if\n *                          object does not exist, 'permission denied' if access denied\n *                 code: error code if object does not exist or permission denied\n *              }\n *\n * @param {string} filePath = path to local object\n * @param {string} mode = access mode - either 'r' or 'w'. Defaults to 'r'\n * @returns {Object} with properties status, type, details and code\n */\nfunction haveLocalAccess(filePath, mode = 'r') {\n  const accessMode = constants.F_OK | mode === 'w' ? constants.W_OK : constants.R_OK;\n  try {\n    accessSync(filePath, accessMode);\n    const type = localExists(filePath);\n    return {\n      status: true,\n      type: type,\n      details: 'access OK',\n      code: 0\n    };\n  } catch (err) {\n    switch (err.errno) {\n      case -2:\n        {\n          return {\n            status: false,\n            type: null,\n            details: 'not exist',\n            code: -2\n          };\n        }\n      case -13:\n        {\n          return {\n            status: false,\n            type: localExists(filePath),\n            details: 'permission denied',\n            code: -13\n          };\n        }\n      case -20:\n        {\n          return {\n            status: false,\n            type: null,\n            details: 'parent not a directory'\n          };\n        }\n      default:\n        {\n          return {\n            status: false,\n            type: null,\n            details: err.message\n          };\n        }\n    }\n  }\n}\n\n/**\n * Checks to verify the object specified by filePath can either be written to or created\n * if it doens't already exist. If it does not exist, checks to see if the parent entry in the\n * path is a directory and can be written to. Returns an object with the same format as the object\n * returned by 'haveLocalAccess'.\n *\n * @param {string} filePath - path to object to be created or written t\n * @returns {Object} Object with properties status, type, destils and code\n */\nfunction haveLocalCreate(filePath) {\n  const {\n    status,\n    details,\n    type\n  } = haveLocalAccess(filePath, 'w');\n  if (!status) {\n    // filePath does not exist. Can we create it?\n    if (details === 'permission denied') {\n      // don't have permission\n      return {\n        status,\n        details,\n        type\n      };\n    }\n    // to create it, parent must be directory and writeable\n    const dirPath = dirname(filePath);\n    const localCheck = haveLocalAccess(dirPath, 'w');\n    if (!localCheck.status) {\n      // no access to parent directory\n      return {\n        status: localCheck.status,\n        details: `${dirPath}: ${localCheck.details}`,\n        type: null\n      };\n    }\n    // exists, is it a directory?\n    if (localCheck.type !== 'd') {\n      return {\n        status: false,\n        details: `${dirPath}: not a directory`,\n        type: null\n      };\n    }\n    return {\n      status: true,\n      details: 'access OK',\n      type: null,\n      code: 0\n    };\n  }\n  return {\n    status,\n    details,\n    type\n  };\n}\nasync function normalizeRemotePath(client, aPath) {\n  try {\n    if (aPath.startsWith('..')) {\n      const root = await client.realPath('..');\n      return `${root}/${aPath.slice(3)}`;\n    } else if (aPath.startsWith('.')) {\n      const root = await client.realPath('.');\n      return `${root}/${aPath.slice(2)}`;\n    }\n    return aPath;\n  } catch (err) {\n    throw new Error(`normalizeRemotePath: ${err.message}`);\n  }\n}\n\n/**\n * Check to see if there is an active sftp connection\n *\n * @param {Object} client - current sftp object\n * @param {String} name - name given to this connection\n * @param {Function} reject - if defined, call this rather than throw\n *                            an error\n * @returns {Boolean} True if connection OK\n * @throws {Error}\n */\nfunction haveConnection(client, name, reject) {\n  if (!client.sftp) {\n    const newError = new Error(`${name}: No SFTP connection available`);\n    newError.code = errorCode.connect;\n    if (reject) {\n      reject(newError);\n      return false;\n    } else {\n      throw newError;\n    }\n  }\n  return true;\n}\nfunction sleep(ms) {\n  return new Promise((resolve, reject) => {\n    try {\n      if (Number.isNaN(Number.parseInt(ms)) || ms < 0) {\n        reject('Argument must be a number >= 0');\n      } else {\n        setTimeout(() => {\n          resolve(true);\n        }, ms);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\nfunction partition(input, size) {\n  let output = [];\n  if (size < 1) {\n    throw new Error('Partition size must be greater than zero');\n  }\n  for (let i = 0; i < input.length; i += size) {\n    output[output.length] = input.slice(i, i + size);\n  }\n  return output;\n}\nmodule.exports = {\n  globalListener,\n  errorListener,\n  endListener,\n  closeListener,\n  addTempListeners,\n  removeTempListeners,\n  haveLocalAccess,\n  haveLocalCreate,\n  normalizeRemotePath,\n  localExists,\n  haveConnection,\n  sleep,\n  partition\n};","'use strict';\n\nconst {\n  Duplex: DuplexStream,\n  Readable: ReadableStream,\n  Writable: WritableStream\n} = require('stream');\nconst {\n  CHANNEL_EXTENDED_DATATYPE: {\n    STDERR\n  }\n} = require('./protocol/constants.js');\nconst {\n  bufferSlice\n} = require('./protocol/utils.js');\nconst PACKET_SIZE = 32 * 1024;\nconst MAX_WINDOW = 2 * 1024 * 1024;\nconst WINDOW_THRESHOLD = MAX_WINDOW / 2;\nclass ClientStderr extends ReadableStream {\n  constructor(channel, streamOpts) {\n    super(streamOpts);\n    this._channel = channel;\n  }\n  _read(n) {\n    if (this._channel._waitChanDrain) {\n      this._channel._waitChanDrain = false;\n      if (this._channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(this._channel);\n    }\n  }\n}\nclass ServerStderr extends WritableStream {\n  constructor(channel) {\n    super({\n      highWaterMark: MAX_WINDOW\n    });\n    this._channel = channel;\n  }\n  _write(data, encoding, cb) {\n    const channel = this._channel;\n    const protocol = channel._client._protocol;\n    const outgoing = channel.outgoing;\n    const packetSize = outgoing.packetSize;\n    const id = outgoing.id;\n    let window = outgoing.window;\n    const len = data.length;\n    let p = 0;\n    if (outgoing.state !== 'open') return;\n    while (len - p > 0 && window > 0) {\n      let sliceLen = len - p;\n      if (sliceLen > window) sliceLen = window;\n      if (sliceLen > packetSize) sliceLen = packetSize;\n      if (p === 0 && sliceLen === len) protocol.channelExtData(id, data, STDERR);else protocol.channelExtData(id, bufferSlice(data, p, p + sliceLen), STDERR);\n      p += sliceLen;\n      window -= sliceLen;\n    }\n    outgoing.window = window;\n    if (len - p > 0) {\n      if (window === 0) channel._waitWindow = true;\n      if (p > 0) channel._chunkErr = bufferSlice(data, p, len);else channel._chunkErr = data;\n      channel._chunkcbErr = cb;\n      return;\n    }\n    cb();\n  }\n}\nclass Channel extends DuplexStream {\n  constructor(client, info, opts) {\n    const streamOpts = {\n      highWaterMark: MAX_WINDOW,\n      allowHalfOpen: !opts || opts && opts.allowHalfOpen !== false,\n      emitClose: false\n    };\n    super(streamOpts);\n    this.allowHalfOpen = streamOpts.allowHalfOpen;\n    const server = !!(opts && opts.server);\n    this.server = server;\n    this.type = info.type;\n    this.subtype = undefined;\n\n    /*\n      incoming and outgoing contain these properties:\n      {\n        id: undefined,\n        window: undefined,\n        packetSize: undefined,\n        state: 'closed'\n      }\n    */\n    this.incoming = info.incoming;\n    this.outgoing = info.outgoing;\n    this._callbacks = [];\n    this._client = client;\n    this._hasX11 = false;\n    this._exit = {\n      code: undefined,\n      signal: undefined,\n      dump: undefined,\n      desc: undefined\n    };\n    this.stdin = this.stdout = this;\n    if (server) this.stderr = new ServerStderr(this);else this.stderr = new ClientStderr(this, streamOpts);\n\n    // Outgoing data\n    this._waitWindow = false; // SSH-level backpressure\n\n    // Incoming data\n    this._waitChanDrain = false; // Channel Readable side backpressure\n\n    this._chunk = undefined;\n    this._chunkcb = undefined;\n    this._chunkErr = undefined;\n    this._chunkcbErr = undefined;\n    this.on('finish', onFinish).on('prefinish', onFinish); // For node v0.11+\n\n    this.on('end', onEnd).on('close', onEnd);\n  }\n  _read(n) {\n    if (this._waitChanDrain) {\n      this._waitChanDrain = false;\n      if (this.incoming.window <= WINDOW_THRESHOLD) windowAdjust(this);\n    }\n  }\n  _write(data, encoding, cb) {\n    const protocol = this._client._protocol;\n    const outgoing = this.outgoing;\n    const packetSize = outgoing.packetSize;\n    const id = outgoing.id;\n    let window = outgoing.window;\n    const len = data.length;\n    let p = 0;\n    if (outgoing.state !== 'open') return;\n    while (len - p > 0 && window > 0) {\n      let sliceLen = len - p;\n      if (sliceLen > window) sliceLen = window;\n      if (sliceLen > packetSize) sliceLen = packetSize;\n      if (p === 0 && sliceLen === len) protocol.channelData(id, data);else protocol.channelData(id, bufferSlice(data, p, p + sliceLen));\n      p += sliceLen;\n      window -= sliceLen;\n    }\n    outgoing.window = window;\n    if (len - p > 0) {\n      if (window === 0) this._waitWindow = true;\n      if (p > 0) this._chunk = bufferSlice(data, p, len);else this._chunk = data;\n      this._chunkcb = cb;\n      return;\n    }\n    cb();\n  }\n  eof() {\n    if (this.outgoing.state === 'open') {\n      this.outgoing.state = 'eof';\n      this._client._protocol.channelEOF(this.outgoing.id);\n    }\n  }\n  close() {\n    if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {\n      this.outgoing.state = 'closing';\n      this._client._protocol.channelClose(this.outgoing.id);\n    }\n  }\n  destroy() {\n    this.end();\n    this.close();\n    return this;\n  }\n\n  // Session type-specific methods =============================================\n  setWindow(rows, cols, height, width) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (this.type === 'session' && (this.subtype === 'shell' || this.subtype === 'exec') && this.writable && this.outgoing.state === 'open') {\n      this._client._protocol.windowChange(this.outgoing.id, rows, cols, height, width);\n    }\n  }\n  signal(signalName) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (this.type === 'session' && this.writable && this.outgoing.state === 'open') {\n      this._client._protocol.signal(this.outgoing.id, signalName);\n    }\n  }\n  exit(statusOrSignal, coreDumped, msg) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (this.type === 'session' && this.writable && this.outgoing.state === 'open') {\n      if (typeof statusOrSignal === 'number') {\n        this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);\n      } else {\n        this._client._protocol.exitSignal(this.outgoing.id, statusOrSignal, coreDumped, msg);\n      }\n    }\n  }\n}\nfunction onFinish() {\n  this.eof();\n  if (this.server || !this.allowHalfOpen) this.close();\n  this.writable = false;\n}\nfunction onEnd() {\n  this.readable = false;\n}\nfunction windowAdjust(self) {\n  if (self.outgoing.state === 'closed') return;\n  const amt = MAX_WINDOW - self.incoming.window;\n  if (amt <= 0) return;\n  self.incoming.window += amt;\n  self._client._protocol.channelWindowAdjust(self.outgoing.id, amt);\n}\nmodule.exports = {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n};",null,"// TODO:\n//    * add `.connected` or similar property to allow immediate connection\n//      status checking\n//    * add/improve debug output during user authentication phase\n'use strict';\n\nconst {\n  createHash,\n  getHashes,\n  randomFillSync\n} = require('crypto');\nconst {\n  Socket\n} = require('net');\nconst {\n  lookup: dnsLookup\n} = require('dns');\nconst EventEmitter = require('events');\nconst HASHES = getHashes();\nconst {\n  COMPAT,\n  CHANNEL_EXTENDED_DATATYPE: {\n    STDERR\n  },\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst {\n  bufferCopy,\n  makeBufferParser,\n  makeError,\n  readUInt32BE,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./protocol/utils.js');\nconst {\n  AgentContext,\n  createAgent,\n  isAgent\n} = require('./agent.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\nconst bufferParser = makeBufferParser();\nconst sigParser = makeBufferParser();\nconst RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nconst noop = err => {};\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n    this.config = {\n      host: undefined,\n      port: undefined,\n      localAddress: undefined,\n      localPort: undefined,\n      forceIPv4: undefined,\n      forceIPv6: undefined,\n      keepaliveCountMax: undefined,\n      keepaliveInterval: undefined,\n      readyTimeout: undefined,\n      ident: undefined,\n      username: undefined,\n      password: undefined,\n      privateKey: undefined,\n      tryKeyboard: undefined,\n      agent: undefined,\n      allowAgentFwd: undefined,\n      authHandler: undefined,\n      hostHashAlgo: undefined,\n      hostHashCb: undefined,\n      strictVendor: undefined,\n      debug: undefined\n    };\n    this._agent = undefined;\n    this._readyTimeout = undefined;\n    this._chanMgr = undefined;\n    this._callbacks = undefined;\n    this._forwarding = undefined;\n    this._forwardingUnix = undefined;\n    this._acceptX11 = undefined;\n    this._agentFwdEnabled = undefined;\n    this._remoteVer = undefined;\n    this._protocol = undefined;\n    this._sock = undefined;\n    this._resetKA = undefined;\n  }\n  connect(cfg) {\n    if (this._sock && isWritable(this._sock)) {\n      this.once('close', () => {\n        this.connect(cfg);\n      });\n      this.end();\n      return this;\n    }\n    this.config.host = cfg.hostname || cfg.host || 'localhost';\n    this.config.port = cfg.port || 22;\n    this.config.localAddress = typeof cfg.localAddress === 'string' ? cfg.localAddress : undefined;\n    this.config.localPort = typeof cfg.localPort === 'string' || typeof cfg.localPort === 'number' ? cfg.localPort : undefined;\n    this.config.forceIPv4 = cfg.forceIPv4 || false;\n    this.config.forceIPv6 = cfg.forceIPv6 || false;\n    this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === 'number' && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;\n    this.config.keepaliveInterval = typeof cfg.keepaliveInterval === 'number' && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;\n    this.config.readyTimeout = typeof cfg.readyTimeout === 'number' && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 20000;\n    this.config.ident = typeof cfg.ident === 'string' || Buffer.isBuffer(cfg.ident) ? cfg.ident : undefined;\n    const algorithms = {\n      kex: undefined,\n      serverHostKey: undefined,\n      cs: {\n        cipher: undefined,\n        mac: undefined,\n        compress: undefined,\n        lang: []\n      },\n      sc: undefined\n    };\n    let allOfferDefaults = true;\n    if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n      algorithms.kex = generateAlgorithmList(cfg.algorithms.kex, DEFAULT_KEX, SUPPORTED_KEX);\n      if (algorithms.kex !== DEFAULT_KEX) allOfferDefaults = false;\n      algorithms.serverHostKey = generateAlgorithmList(cfg.algorithms.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY) allOfferDefaults = false;\n      algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER);\n      if (algorithms.cs.cipher !== DEFAULT_CIPHER) allOfferDefaults = false;\n      algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac, DEFAULT_MAC, SUPPORTED_MAC);\n      if (algorithms.cs.mac !== DEFAULT_MAC) allOfferDefaults = false;\n      algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION);\n      if (algorithms.cs.compress !== DEFAULT_COMPRESSION) allOfferDefaults = false;\n      if (!allOfferDefaults) algorithms.sc = algorithms.cs;\n    }\n    if (typeof cfg.username === 'string') this.config.username = cfg.username;else if (typeof cfg.user === 'string') this.config.username = cfg.user;else throw new Error('Invalid username');\n    this.config.password = typeof cfg.password === 'string' ? cfg.password : undefined;\n    this.config.privateKey = typeof cfg.privateKey === 'string' || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : undefined;\n    this.config.localHostname = typeof cfg.localHostname === 'string' ? cfg.localHostname : undefined;\n    this.config.localUsername = typeof cfg.localUsername === 'string' ? cfg.localUsername : undefined;\n    this.config.tryKeyboard = cfg.tryKeyboard === true;\n    if (typeof cfg.agent === 'string' && cfg.agent.length) this.config.agent = createAgent(cfg.agent);else if (isAgent(cfg.agent)) this.config.agent = cfg.agent;else this.config.agent = undefined;\n    this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== undefined;\n    let authHandler = this.config.authHandler = typeof cfg.authHandler === 'function' || Array.isArray(cfg.authHandler) ? cfg.authHandler : undefined;\n    this.config.strictVendor = typeof cfg.strictVendor === 'boolean' ? cfg.strictVendor : true;\n    const debug = this.config.debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    if (cfg.agentForward === true && !this.config.allowAgentFwd) {\n      throw new Error('You must set a valid agent path to allow agent forwarding');\n    }\n    let callbacks = this._callbacks = [];\n    this._chanMgr = new ChannelManager(this);\n    this._forwarding = {};\n    this._forwardingUnix = {};\n    this._acceptX11 = 0;\n    this._agentFwdEnabled = false;\n    this._agent = this.config.agent ? this.config.agent : undefined;\n    this._remoteVer = undefined;\n    let privateKey;\n    if (this.config.privateKey) {\n      privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) {\n        throw new Error('privateKey value does not contain a (valid) private key');\n      }\n    }\n    let hostVerifier;\n    if (typeof cfg.hostVerifier === 'function') {\n      const hashCb = cfg.hostVerifier;\n      let hashAlgo;\n      if (HASHES.indexOf(cfg.hostHash) !== -1) {\n        // Default to old behavior of hashing on user's behalf\n        hashAlgo = cfg.hostHash;\n      }\n      hostVerifier = (key, verify) => {\n        if (hashAlgo) key = createHash(hashAlgo).update(key).digest('hex');\n        const ret = hashCb(key, verify);\n        if (ret !== undefined) verify(ret);\n      };\n    }\n    const sock = this._sock = cfg.sock || new Socket();\n    let ready = false;\n    let sawHeader = false;\n    if (this._protocol) this._protocol.cleanup();\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from server: ${JSON.stringify(msg)}`);\n    };\n    let serverSigAlgs;\n    const proto = this._protocol = new Protocol({\n      ident: this.config.ident,\n      offer: allOfferDefaults ? undefined : algorithms,\n      onWrite: data => {\n        if (isWritable(sock)) sock.write(data);\n      },\n      onError: err => {\n        if (err.level === 'handshake') clearTimeout(this._readyTimeout);\n        if (!proto._destruct) sock.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          sock.end();\n        } catch {}\n      },\n      onHeader: header => {\n        sawHeader = true;\n        this._remoteVer = header.versions.software;\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        this.emit('handshake', negotiated);\n        if (!ready) {\n          ready = true;\n          proto.service('ssh-userauth');\n        }\n      },\n      debug,\n      hostVerifier,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          sock.end();\n        },\n        SERVICE_ACCEPT: (p, name) => {\n          if (name === 'ssh-userauth') tryNextAuth();\n        },\n        EXT_INFO: (p, exts) => {\n          if (serverSigAlgs === undefined) {\n            for (const ext of exts) {\n              if (ext.name === 'server-sig-algs') {\n                serverSigAlgs = ext.algs;\n                return;\n              }\n            }\n            serverSigAlgs = null;\n          }\n        },\n        USERAUTH_BANNER: (p, msg) => {\n          this.emit('banner', msg);\n        },\n        USERAUTH_SUCCESS: p => {\n          // Start keepalive mechanism\n          resetKA();\n          clearTimeout(this._readyTimeout);\n          this.emit('ready');\n        },\n        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {\n          // For key-based authentication, check if we should retry the current\n          // key with a different algorithm first\n          if (curAuth.keyAlgos) {\n            const oldKeyAlgo = curAuth.keyAlgos[0][0];\n            if (debug) debug(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);\n            curAuth.keyAlgos.shift();\n            if (curAuth.keyAlgos.length) {\n              const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n              switch (curAuth.type) {\n                case 'agent':\n                  proto.authPK(curAuth.username, curAuth.agentCtx.currentKey(), keyAlgo);\n                  return;\n                case 'publickey':\n                  proto.authPK(curAuth.username, curAuth.key, keyAlgo);\n                  return;\n                case 'hostbased':\n                  proto.authHostbased(curAuth.username, curAuth.key, curAuth.localHostname, curAuth.localUsername, keyAlgo, (buf, cb) => {\n                    const signature = curAuth.key.sign(buf, hashAlgo);\n                    if (signature instanceof Error) {\n                      signature.message = `Error while signing with key: ${signature.message}`;\n                      signature.level = 'client-authentication';\n                      this.emit('error', signature);\n                      return tryNextAuth();\n                    }\n                    cb(signature);\n                  });\n                  return;\n              }\n            } else {\n              curAuth.keyAlgos = undefined;\n            }\n          }\n          if (curAuth.type === 'agent') {\n            const pos = curAuth.agentCtx.pos();\n            debug && debug(`Client: Agent key #${pos + 1} failed`);\n            return tryNextAgentKey();\n          }\n          debug && debug(`Client: ${curAuth.type} auth failed`);\n          curPartial = partialSuccess;\n          curAuthsLeft = authMethods;\n          tryNextAuth();\n        },\n        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {\n          if (curAuth.type === 'password') {\n            // TODO: support a `changePrompt()` on `curAuth` that defaults to\n            // emitting 'change password' as before\n            this.emit('change password', prompt, newPassword => {\n              proto.authPassword(this.config.username, this.config.password, newPassword);\n            });\n          }\n        },\n        USERAUTH_PK_OK: p => {\n          let keyAlgo;\n          let hashAlgo;\n          if (curAuth.keyAlgos) [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n          if (curAuth.type === 'agent') {\n            const key = curAuth.agentCtx.currentKey();\n            proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {\n              const opts = {\n                hash: hashAlgo\n              };\n              curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {\n                if (err) {\n                  err.level = 'agent';\n                  this.emit('error', err);\n                } else {\n                  return cb(signed);\n                }\n                tryNextAgentKey();\n              });\n            });\n          } else if (curAuth.type === 'publickey') {\n            proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {\n              const signature = curAuth.key.sign(buf, hashAlgo);\n              if (signature instanceof Error) {\n                signature.message = `Error signing data with key: ${signature.message}`;\n                signature.level = 'client-authentication';\n                this.emit('error', signature);\n                return tryNextAuth();\n              }\n              cb(signature);\n            });\n          }\n        },\n        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {\n          if (curAuth.type === 'keyboard-interactive') {\n            const nprompts = Array.isArray(prompts) ? prompts.length : 0;\n            if (nprompts === 0) {\n              debug && debug('Client: Sending automatic USERAUTH_INFO_RESPONSE');\n              proto.authInfoRes();\n              return;\n            }\n            // We sent a keyboard-interactive user authentication request and\n            // now the server is sending us the prompts we need to present to\n            // the user\n            curAuth.prompt(name, instructions, '', prompts, answers => {\n              proto.authInfoRes(answers);\n            });\n          }\n        },\n        REQUEST_SUCCESS: (p, data) => {\n          if (callbacks.length) callbacks.shift()(false, data);\n        },\n        REQUEST_FAILURE: p => {\n          if (callbacks.length) callbacks.shift()(true);\n        },\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          switch (name) {\n            case 'hostkeys-00@openssh.com':\n              // Automatically verify keys before passing to end user\n              hostKeysProve(this, data, (err, keys) => {\n                if (err) return;\n                this.emit('hostkeys', keys);\n              });\n              if (wantReply) proto.requestSuccess();\n              break;\n            default:\n              // Auto-reject all other global requests, this can be especially\n              // useful if the server is sending us dummy keepalive global\n              // requests\n              if (wantReply) proto.requestFailure();\n          }\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from server, typically a forwarded TCP or\n          // X11 connection\n          onCHANNEL_OPEN(this, info);\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function') return;\n          const isSFTP = channel.type === 'sftp';\n          const type = isSFTP ? 'session' : channel.type;\n          const chanInfo = {\n            type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = isSFTP ? new SFTP(this, chanInfo, {\n            debug\n          }) : new Channel(this, chanInfo);\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          if (type !== STDERR) return;\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (!channel.stderr.push(data)) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          this._resetKA();\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          this._resetKA();\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          const exit = channel._exit;\n          if (exit.code !== undefined) return;\n          switch (type) {\n            case 'exit-status':\n              channel.emit('exit', exit.code = data);\n              return;\n            case 'exit-signal':\n              channel.emit('exit', exit.code = null, exit.signal = `SIG${data.signal}`, exit.dump = data.coreDumped, exit.desc = data.errorMessage);\n              return;\n          }\n\n          // Keepalive request? OpenSSH will send one as a channel request if\n          // there is a channel open\n\n          if (wantReply) p.channelFailure(channel.outgoing.id);\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n          if (channel.stderr.readable) channel.stderr.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));\n        }\n      }\n    });\n    sock.pause();\n\n    // TODO: check keepalive implementation\n    // Keepalive-related\n    const kainterval = this.config.keepaliveInterval;\n    const kacountmax = this.config.keepaliveCountMax;\n    let kacount = 0;\n    let katimer;\n    const sendKA = () => {\n      if (++kacount > kacountmax) {\n        clearInterval(katimer);\n        if (sock.readable) {\n          const err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }\n        return;\n      }\n      if (isWritable(sock)) {\n        // Append dummy callback to keep correct callback order\n        callbacks.push(resetKA);\n        proto.ping();\n      } else {\n        clearInterval(katimer);\n      }\n    };\n    function resetKA() {\n      if (kainterval > 0) {\n        kacount = 0;\n        clearInterval(katimer);\n        if (isWritable(sock)) katimer = setInterval(sendKA, kainterval);\n      }\n    }\n    this._resetKA = resetKA;\n    const onDone = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        if (wasConnected && !sawHeader) {\n          const err = makeError('Connection lost before handshake', 'protocol', true);\n          this.emit('error', err);\n        }\n      };\n    })();\n    const onConnect = (() => {\n      let called = false;\n      return () => {\n        if (called) return;\n        called = true;\n        wasConnected = true;\n        debug && debug('Socket connected');\n        this.emit('connect');\n        cryptoInit.then(() => {\n          proto.start();\n          sock.on('data', data => {\n            try {\n              proto.parse(data, 0, data.length);\n            } catch (ex) {\n              this.emit('error', ex);\n              try {\n                if (isWritable(sock)) sock.end();\n              } catch {}\n            }\n          });\n\n          // Drain stderr if we are connection hopping using an exec stream\n          if (sock.stderr && typeof sock.stderr.resume === 'function') sock.stderr.resume();\n          sock.resume();\n        }).catch(err => {\n          this.emit('error', err);\n          try {\n            if (isWritable(sock)) sock.end();\n          } catch {}\n        });\n      };\n    })();\n    let wasConnected = false;\n    sock.on('connect', onConnect).on('timeout', () => {\n      this.emit('timeout');\n    }).on('error', err => {\n      debug && debug(`Socket error: ${err.message}`);\n      clearTimeout(this._readyTimeout);\n      err.level = 'client-socket';\n      this.emit('error', err);\n    }).on('end', () => {\n      debug && debug('Socket ended');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('end');\n    }).on('close', () => {\n      debug && debug('Socket closed');\n      onDone();\n      proto.cleanup();\n      clearTimeout(this._readyTimeout);\n      clearInterval(katimer);\n      this.emit('close');\n\n      // Notify outstanding channel requests of disconnection ...\n      const callbacks_ = callbacks;\n      callbacks = this._callbacks = [];\n      const err = new Error('No response from server');\n      for (let i = 0; i < callbacks_.length; ++i) callbacks_[i](err);\n\n      // Simulate error for any channels waiting to be opened\n      this._chanMgr.cleanup(err);\n    });\n\n    // Begin authentication handling ===========================================\n    let curAuth;\n    let curPartial = null;\n    let curAuthsLeft = null;\n    const authsAllowed = ['none'];\n    if (this.config.password !== undefined) authsAllowed.push('password');\n    if (privateKey !== undefined) authsAllowed.push('publickey');\n    if (this._agent !== undefined) authsAllowed.push('agent');\n    if (this.config.tryKeyboard) authsAllowed.push('keyboard-interactive');\n    if (privateKey !== undefined && this.config.localHostname !== undefined && this.config.localUsername !== undefined) {\n      authsAllowed.push('hostbased');\n    }\n    if (Array.isArray(authHandler)) authHandler = makeSimpleAuthHandler(authHandler);else if (typeof authHandler !== 'function') authHandler = makeSimpleAuthHandler(authsAllowed);\n    let hasSentAuth = false;\n    const doNextAuth = nextAuth => {\n      if (hasSentAuth) return;\n      hasSentAuth = true;\n      if (nextAuth === false) {\n        const err = new Error('All configured authentication methods failed');\n        err.level = 'client-authentication';\n        this.emit('error', err);\n        this.end();\n        return;\n      }\n      if (typeof nextAuth === 'string') {\n        // Remain backwards compatible with original `authHandler()` usage,\n        // which only supported passing names of next method to try using data\n        // from the `connect()` config object\n\n        const type = nextAuth;\n        if (authsAllowed.indexOf(type) === -1) return skipAuth(`Authentication method not allowed: ${type}`);\n        const username = this.config.username;\n        switch (type) {\n          case 'password':\n            nextAuth = {\n              type,\n              username,\n              password: this.config.password\n            };\n            break;\n          case 'publickey':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey\n            };\n            break;\n          case 'hostbased':\n            nextAuth = {\n              type,\n              username,\n              key: privateKey,\n              localHostname: this.config.localHostname,\n              localUsername: this.config.localUsername\n            };\n            break;\n          case 'agent':\n            nextAuth = {\n              type,\n              username,\n              agentCtx: new AgentContext(this._agent)\n            };\n            break;\n          case 'keyboard-interactive':\n            nextAuth = {\n              type,\n              username,\n              prompt: (...args) => this.emit('keyboard-interactive', ...args)\n            };\n            break;\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      } else if (typeof nextAuth !== 'object' || nextAuth === null) {\n        return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n      } else {\n        const username = nextAuth.username;\n        if (typeof username !== 'string') {\n          return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);\n        }\n        const type = nextAuth.type;\n        switch (type) {\n          case 'password':\n            {\n              const {\n                password\n              } = nextAuth;\n              if (typeof password !== 'string' && !Buffer.isBuffer(password)) return skipAuth('Skipping invalid password auth attempt');\n              nextAuth = {\n                type,\n                username,\n                password\n              };\n              break;\n            }\n          case 'publickey':\n            {\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error) return skipAuth('Skipping invalid key auth attempt');\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key\n              };\n              break;\n            }\n          case 'hostbased':\n            {\n              const {\n                localHostname,\n                localUsername\n              } = nextAuth;\n              const key = parseKey(nextAuth.key, nextAuth.passphrase);\n              if (key instanceof Error || typeof localHostname !== 'string' || typeof localUsername !== 'string') {\n                return skipAuth('Skipping invalid hostbased auth attempt');\n              }\n              if (!key.isPrivateKey()) return skipAuth('Skipping non-private key');\n              nextAuth = {\n                type,\n                username,\n                key,\n                localHostname,\n                localUsername\n              };\n              break;\n            }\n          case 'agent':\n            {\n              let agent = nextAuth.agent;\n              if (typeof agent === 'string' && agent.length) {\n                agent = createAgent(agent);\n              } else if (!isAgent(agent)) {\n                return skipAuth(`Skipping invalid agent: ${nextAuth.agent}`);\n              }\n              nextAuth = {\n                type,\n                username,\n                agentCtx: new AgentContext(agent)\n              };\n              break;\n            }\n          case 'keyboard-interactive':\n            {\n              const {\n                prompt\n              } = nextAuth;\n              if (typeof prompt !== 'function') {\n                return skipAuth('Skipping invalid keyboard-interactive auth attempt');\n              }\n              nextAuth = {\n                type,\n                username,\n                prompt\n              };\n              break;\n            }\n          case 'none':\n            nextAuth = {\n              type,\n              username\n            };\n            break;\n          default:\n            return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);\n        }\n      }\n      curAuth = nextAuth;\n\n      // Begin authentication method's process\n      try {\n        const username = curAuth.username;\n        switch (curAuth.type) {\n          case 'password':\n            proto.authPassword(username, curAuth.password);\n            break;\n          case 'publickey':\n            {\n              let keyAlgo;\n              curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);\n              if (curAuth.keyAlgos) {\n                if (curAuth.keyAlgos.length) {\n                  keyAlgo = curAuth.keyAlgos[0][0];\n                } else {\n                  return skipAuth('Skipping key authentication (no mutual hash algorithm)');\n                }\n              }\n              proto.authPK(username, curAuth.key, keyAlgo);\n              break;\n            }\n          case 'hostbased':\n            {\n              let keyAlgo;\n              let hashAlgo;\n              curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);\n              if (curAuth.keyAlgos) {\n                if (curAuth.keyAlgos.length) {\n                  [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];\n                } else {\n                  return skipAuth('Skipping hostbased authentication (no mutual hash algorithm)');\n                }\n              }\n              proto.authHostbased(username, curAuth.key, curAuth.localHostname, curAuth.localUsername, keyAlgo, (buf, cb) => {\n                const signature = curAuth.key.sign(buf, hashAlgo);\n                if (signature instanceof Error) {\n                  signature.message = `Error while signing with key: ${signature.message}`;\n                  signature.level = 'client-authentication';\n                  this.emit('error', signature);\n                  return tryNextAuth();\n                }\n                cb(signature);\n              });\n              break;\n            }\n          case 'agent':\n            curAuth.agentCtx.init(err => {\n              if (err) {\n                err.level = 'agent';\n                this.emit('error', err);\n                return tryNextAuth();\n              }\n              tryNextAgentKey();\n            });\n            break;\n          case 'keyboard-interactive':\n            proto.authKeyboard(username);\n            break;\n          case 'none':\n            proto.authNone(username);\n            break;\n        }\n      } finally {\n        hasSentAuth = false;\n      }\n    };\n    function skipAuth(msg) {\n      debug && debug(msg);\n      process.nextTick(tryNextAuth);\n    }\n    function tryNextAuth() {\n      hasSentAuth = false;\n      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n      if (hasSentAuth || auth === undefined) return;\n      doNextAuth(auth);\n    }\n    const tryNextAgentKey = () => {\n      if (curAuth.type === 'agent') {\n        const key = curAuth.agentCtx.nextKey();\n        if (key === false) {\n          debug && debug('Agent: No more keys left to try');\n          debug && debug('Client: agent auth failed');\n          tryNextAuth();\n        } else {\n          const pos = curAuth.agentCtx.pos();\n          let keyAlgo;\n          curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);\n          if (curAuth.keyAlgos) {\n            if (curAuth.keyAlgos.length) {\n              keyAlgo = curAuth.keyAlgos[0][0];\n            } else {\n              debug && debug(`Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`);\n              tryNextAgentKey();\n              return;\n            }\n          }\n          debug && debug(`Agent: Trying key #${pos + 1}`);\n          proto.authPK(curAuth.username, key, keyAlgo);\n        }\n      }\n    };\n    const startTimeout = () => {\n      if (this.config.readyTimeout > 0) {\n        this._readyTimeout = setTimeout(() => {\n          const err = new Error('Timed out while waiting for handshake');\n          err.level = 'client-timeout';\n          this.emit('error', err);\n          sock.destroy();\n        }, this.config.readyTimeout);\n      }\n    };\n    if (!cfg.sock) {\n      let host = this.config.host;\n      const forceIPv4 = this.config.forceIPv4;\n      const forceIPv6 = this.config.forceIPv6;\n      debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);\n      const doConnect = () => {\n        startTimeout();\n        sock.connect({\n          host,\n          port: this.config.port,\n          localAddress: this.config.localAddress,\n          localPort: this.config.localPort\n        });\n        sock.setMaxListeners(0);\n        sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n      };\n      if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {\n        doConnect();\n      } else {\n        dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {\n          if (err) {\n            const type = forceIPv4 ? 'IPv4' : 'IPv6';\n            const error = new Error(`Error while looking up ${type} address for '${host}': ${err}`);\n            clearTimeout(this._readyTimeout);\n            error.level = 'client-dns';\n            this.emit('error', error);\n            this.emit('close');\n            return;\n          }\n          host = address;\n          doConnect();\n        });\n      }\n    } else {\n      // Custom socket passed in\n      startTimeout();\n      if (typeof sock.connecting === 'boolean') {\n        // net.Socket\n\n        if (!sock.connecting) {\n          // Already connected\n          onConnect();\n        }\n      } else {\n        // Assume socket/stream is already \"connected\"\n        onConnect();\n      }\n    }\n    return this;\n  }\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n  destroy() {\n    this._sock && isWritable(this._sock) && this._sock.destroy();\n    return this;\n  }\n  exec(cmd, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    const extraOpts = {\n      allowHalfOpen: opts.allowHalfOpen !== false\n    };\n    openChannel(this, 'session', extraOpts, (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const todo = [];\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length) todo.shift()();\n      }\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n        if (typeof opts.pty === 'object' && opts.pty !== null || opts.pty === true) {\n          todo.push(() => reqPty(chan, opts.pty, reqCb));\n        }\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n      todo.push(() => reqExec(chan, cmd, opts, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n  shell(wndopts, opts, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof wndopts === 'function') {\n      cb = wndopts;\n      wndopts = opts = undefined;\n    } else if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n      opts = wndopts;\n      wndopts = undefined;\n    }\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const todo = [];\n      function reqCb(err) {\n        if (err) {\n          chan.close();\n          cb(err);\n          return;\n        }\n        if (todo.length) todo.shift()();\n      }\n      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== undefined) {\n        todo.push(() => reqAgentFwd(chan, reqCb));\n      }\n      if (wndopts !== false) todo.push(() => reqPty(chan, wndopts, reqCb));\n      if (typeof opts === 'object' && opts !== null) {\n        if (typeof opts.env === 'object' && opts.env !== null) reqEnv(chan, opts.env);\n        if (typeof opts.x11 === 'object' && opts.x11 !== null || opts.x11 === 'number' || opts.x11 === true) {\n          todo.push(() => reqX11(chan, opts.x11, reqCb));\n        }\n      }\n      todo.push(() => reqShell(chan, cb));\n      todo.shift()();\n    });\n    return this;\n  }\n  subsys(name, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'session', (err, chan) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      reqSubsystem(chan, name, (err, stream) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        cb(undefined, stream);\n      });\n    });\n    return this;\n  }\n  forwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request for the server to start forwarding TCP connections to us\n    // on a particular address and port\n\n    const wantReply = typeof cb === 'function';\n    if (wantReply) {\n      this._callbacks.push((had_err, data) => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));\n          return;\n        }\n        let realPort = bindPort;\n        if (bindPort === 0 && data && data.length >= 4) {\n          realPort = readUInt32BE(data, 0);\n          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG)) bindPort = realPort;\n        }\n        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;\n        cb(undefined, realPort);\n      });\n    }\n    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);\n    return this;\n  }\n  unforwardIn(bindAddr, bindPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request to stop forwarding us new connections for a particular\n    // address and port\n\n    const wantReply = typeof cb === 'function';\n    if (wantReply) {\n      this._callbacks.push(had_err => {\n        if (had_err) {\n          cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));\n          return;\n        }\n        delete this._forwarding[`${bindAddr}:${bindPort}`];\n        cb();\n      });\n    }\n    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);\n    return this;\n  }\n  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n\n    // Send a request to forward a TCP connection to the server\n\n    const cfg = {\n      srcIP: srcIP,\n      srcPort: srcPort,\n      dstIP: dstIP,\n      dstPort: dstPort\n    };\n    if (typeof cb !== 'function') cb = noop;\n    openChannel(this, 'direct-tcpip', cfg, cb);\n    return this;\n  }\n  openssh_noMoreSessions(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error('Unable to disable future sessions'));\n            return;\n          }\n          cb();\n        });\n      }\n      this._protocol.openssh_noMoreSessions(wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_forwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));\n            return;\n          }\n          this._forwardingUnix[socketPath] = true;\n          cb();\n        });\n      }\n      this._protocol.openssh_streamLocalForward(socketPath, wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_unforwardInStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    const wantReply = typeof cb === 'function';\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      if (wantReply) {\n        this._callbacks.push(had_err => {\n          if (had_err) {\n            cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));\n            return;\n          }\n          delete this._forwardingUnix[socketPath];\n          cb();\n        });\n      }\n      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);\n      return this;\n    }\n    if (!wantReply) return this;\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    if (typeof cb !== 'function') cb = noop;\n    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {\n      openChannel(this, 'direct-streamlocal@openssh.com', {\n        socketPath\n      }, cb);\n      return this;\n    }\n    process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    return this;\n  }\n  sftp(cb) {\n    if (!this._sock || !isWritable(this._sock)) throw new Error('Not connected');\n    openChannel(this, 'sftp', (err, sftp) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      reqSubsystem(sftp, 'sftp', (err, sftp_) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        function removeListeners() {\n          sftp.removeListener('ready', onReady);\n          sftp.removeListener('error', onError);\n          sftp.removeListener('exit', onExit);\n          sftp.removeListener('close', onExit);\n        }\n        function onReady() {\n          // TODO: do not remove exit/close in case remote end closes the\n          // channel abruptly and we need to notify outstanding callbacks\n          removeListeners();\n          cb(undefined, sftp);\n        }\n        function onError(err) {\n          removeListeners();\n          cb(err);\n        }\n        function onExit(code, signal) {\n          removeListeners();\n          let msg;\n          if (typeof code === 'number') msg = `Received exit code ${code} while establishing SFTP session`;else if (signal !== undefined) msg = `Received signal ${signal} while establishing SFTP session`;else msg = 'Received unexpected SFTP session termination';\n          const err = new Error(msg);\n          err.code = code;\n          err.signal = signal;\n          cb(err);\n        }\n        sftp.on('ready', onReady).on('error', onError).on('exit', onExit).on('close', onExit);\n        sftp._init();\n      });\n    });\n    return this;\n  }\n  setNoDelay(noDelay) {\n    if (this._sock && typeof this._sock.setNoDelay === 'function') this._sock.setNoDelay(noDelay);\n    return this;\n  }\n}\nfunction openChannel(self, type, opts, cb) {\n  // Ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n  const localChan = self._chanMgr.add(wrapper);\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n  switch (type) {\n    case 'session':\n    case 'sftp':\n      self._protocol.session(localChan, initWindow, maxPacket);\n      break;\n    case 'direct-tcpip':\n      self._protocol.directTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'direct-streamlocal@openssh.com':\n      self._protocol.openssh_directStreamLocal(localChan, initWindow, maxPacket, opts);\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\nfunction reqX11(chan, screen, cb) {\n  // Asks server to start sending us X11 connections\n  const cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean') cfg.single = screen.single;\n    if (typeof screen.screen === 'number') cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string') cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string') cfg.cookie = screen.cookie;else if (Buffer.isBuffer(screen.cookie)) cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);\n  }\n  if (cfg.cookie === undefined) cfg.cookie = randomCookie();\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request X11'));\n        return;\n      }\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', () => {\n        if (chan._client._acceptX11) --chan._client._acceptX11;\n      });\n      cb();\n    });\n  }\n  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\nfunction reqPty(chan, opts, cb) {\n  let rows = 24;\n  let cols = 80;\n  let width = 640;\n  let height = 480;\n  let term = 'vt100';\n  let modes = null;\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number') rows = opts.rows;\n    if (typeof opts.cols === 'number') cols = opts.cols;\n    if (typeof opts.width === 'number') width = opts.width;\n    if (typeof opts.height === 'number') height = opts.height;\n    if (typeof opts.term === 'string') term = opts.term;\n    if (typeof opts.modes === 'object') modes = opts.modes;\n  }\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    if (wantReply) cb(new Error('Channel is not open'));\n    return;\n  }\n  if (wantReply) {\n    chan._callbacks.push(had_err => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Unable to request a pseudo-terminal'));\n        return;\n      }\n      cb();\n    });\n  }\n  chan._client._protocol.pty(chan.outgoing.id, rows, cols, height, width, term, modes, wantReply);\n}\nfunction reqAgentFwd(chan, cb) {\n  const wantReply = typeof cb === 'function';\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return;\n  }\n  if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return;\n  }\n  chan._client._agentFwdEnabled = true;\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      if (wantReply) {\n        cb(had_err !== true ? had_err : new Error('Unable to request agent forwarding'));\n      }\n      return;\n    }\n    if (wantReply) cb();\n  });\n  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);\n}\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to open shell'));\n      return;\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n  chan._client._protocol.shell(chan.outgoing.id, true);\n}\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error('Unable to exec'));\n      return;\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = opts.allowHalfOpen !== false;\n    cb(undefined, chan);\n  });\n  chan._client._protocol.exec(chan.outgoing.id, cmd, true);\n}\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open') return;\n  const keys = Object.keys(env || {});\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const val = env[key];\n    chan._client._protocol.env(chan.outgoing.id, key, val, false);\n  }\n}\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return;\n  }\n  chan._callbacks.push(had_err => {\n    if (had_err) {\n      cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));\n      return;\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n  chan._client._protocol.subsystem(chan.outgoing.id, name, true);\n}\n\n// TODO: inline implementation into single call site\nfunction onCHANNEL_OPEN(self, info) {\n  // The server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  let localChan = -1;\n  let reason;\n  const accept = () => {\n    const chanInfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    const stream = new Channel(self, chanInfo);\n    self._chanMgr.update(localChan, stream);\n    self._protocol.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n    return stream;\n  };\n  const reject = () => {\n    if (reason === undefined) {\n      if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n    if (localChan !== -1) self._chanMgr.remove(localChan);\n    self._protocol.channelOpenFail(info.sender, reason, '');\n  };\n  const reserveChannel = () => {\n    localChan = self._chanMgr.add();\n    if (localChan === -1) {\n      reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of incoming channel open: ' + 'no channels available');\n      }\n    }\n    return localChan !== -1;\n  };\n  const data = info.data;\n  switch (info.type) {\n    case 'forwarded-tcpip':\n      {\n        const val = self._forwarding[`${data.destIP}:${data.destPort}`];\n        if (val !== undefined && reserveChannel()) {\n          if (data.destPort === 0) data.destPort = val;\n          self.emit('tcp connection', data, accept, reject);\n          return;\n        }\n        break;\n      }\n    case 'forwarded-streamlocal@openssh.com':\n      if (self._forwardingUnix[data.socketPath] !== undefined && reserveChannel()) {\n        self.emit('unix connection', data, accept, reject);\n        return;\n      }\n      break;\n    case 'auth-agent@openssh.com':\n      if (self._agentFwdEnabled && typeof self._agent.getStream === 'function' && reserveChannel()) {\n        self._agent.getStream((err, stream) => {\n          if (err) return reject();\n          const upstream = accept();\n          upstream.pipe(stream).pipe(upstream);\n        });\n        return;\n      }\n      break;\n    case 'x11':\n      if (self._acceptX11 !== 0 && reserveChannel()) {\n        self.emit('x11', data, accept, reject);\n        return;\n      }\n      break;\n    default:\n      // Automatically reject any unsupported channel open requests\n      reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n      if (self.config.debug) {\n        self.config.debug('Client: Automatic rejection of unsupported incoming channel open ' + `type: ${info.type}`);\n      }\n  }\n  if (reason === undefined) {\n    reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n    if (self.config.debug) {\n      self.config.debug('Client: Automatic rejection of unexpected incoming channel open for: ' + info.type);\n    }\n  }\n  reject();\n}\nconst randomCookie = (() => {\n  const buffer = Buffer.allocUnsafe(16);\n  return () => {\n    randomFillSync(buffer, 0, 16);\n    return buffer.hexSlice(0, 16);\n  };\n})();\nfunction makeSimpleAuthHandler(authList) {\n  if (!Array.isArray(authList)) throw new Error('authList must be an array');\n  let a = 0;\n  return (authsLeft, partialSuccess, cb) => {\n    if (a === authList.length) return false;\n    return authList[a++];\n  };\n}\nfunction hostKeysProve(client, keys_, cb) {\n  if (!client._sock || !isWritable(client._sock)) return;\n  if (typeof cb !== 'function') cb = noop;\n  if (!Array.isArray(keys_)) throw new TypeError('Invalid keys argument type');\n  const keys = [];\n  for (const key of keys_) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) throw parsed;\n    keys.push(parsed);\n  }\n  if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {\n    client._callbacks.push((had_err, data) => {\n      if (had_err) {\n        cb(had_err !== true ? had_err : new Error('Server failed to prove supplied keys'));\n        return;\n      }\n\n      // TODO: move all of this parsing/verifying logic out of the client?\n      const ret = [];\n      let keyIdx = 0;\n      bufferParser.init(data, 0);\n      while (bufferParser.avail()) {\n        if (keyIdx === keys.length) break;\n        const key = keys[keyIdx++];\n        const keyPublic = key.getPublicSSH();\n        const sigEntry = bufferParser.readString();\n        sigParser.init(sigEntry, 0);\n        const type = sigParser.readString(true);\n        let value = sigParser.readString();\n        let algo;\n        if (type !== key.type) {\n          if (key.type === 'ssh-rsa') {\n            switch (type) {\n              case 'rsa-sha2-256':\n                algo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                algo = 'sha512';\n                break;\n              default:\n                continue;\n            }\n          } else {\n            continue;\n          }\n        }\n        const sessionID = client._protocol._kex.sessionID;\n        const verifyData = Buffer.allocUnsafe(4 + 29 + 4 + sessionID.length + 4 + keyPublic.length);\n        let p = 0;\n        writeUInt32BE(verifyData, 29, p);\n        verifyData.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n        writeUInt32BE(verifyData, sessionID.length, p += 29);\n        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);\n        writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);\n        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);\n        if (!(value = sigSSHToASN1(value, type))) continue;\n        if (key.verify(verifyData, value, algo) === true) ret.push(key);\n      }\n      sigParser.clear();\n      bufferParser.clear();\n      cb(null, ret);\n    });\n    client._protocol.openssh_hostKeysProve(keys);\n    return;\n  }\n  process.nextTick(cb, new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n}\nfunction getKeyAlgos(client, key, serverSigAlgs) {\n  switch (key.type) {\n    case 'ssh-rsa':\n      if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {\n        if (!Array.isArray(serverSigAlgs)) serverSigAlgs = ['rsa-sha2-256', 'rsa-sha2-512'];else serverSigAlgs = ['rsa-sha2-256', 'rsa-sha2-512', ...serverSigAlgs];\n      }\n      if (Array.isArray(serverSigAlgs)) {\n        if (serverSigAlgs.indexOf('rsa-sha2-256') !== -1) return [['rsa-sha2-256', 'sha256']];\n        if (serverSigAlgs.indexOf('rsa-sha2-512') !== -1) return [['rsa-sha2-512', 'sha512']];\n        if (serverSigAlgs.indexOf('ssh-rsa') === -1) return [];\n      }\n      return [['ssh-rsa', 'sha1']];\n  }\n}\nmodule.exports = Client;","'use strict';\n\nconst {\n  Agent: HttpAgent\n} = require('http');\nconst {\n  Agent: HttpsAgent\n} = require('https');\nconst {\n  connect: tlsConnect\n} = require('tls');\nlet Client;\nfor (const ctor of [HttpAgent, HttpsAgent]) {\n  class SSHAgent extends ctor {\n    constructor(connectCfg, agentOptions) {\n      super(agentOptions);\n      this._connectCfg = connectCfg;\n      this._defaultSrcIP = agentOptions && agentOptions.srcIP || 'localhost';\n    }\n    createConnection(options, cb) {\n      const srcIP = options && options.localAddress || this._defaultSrcIP;\n      const srcPort = options && options.localPort || 0;\n      const dstIP = options.host;\n      const dstPort = options.port;\n      if (Client === undefined) Client = require('./client.js');\n      const client = new Client();\n      let triedForward = false;\n      client.on('ready', () => {\n        client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {\n          triedForward = true;\n          if (err) {\n            client.end();\n            return cb(err);\n          }\n          stream.once('close', () => client.end());\n          cb(null, decorateStream(stream, ctor, options));\n        });\n      }).on('error', cb).on('close', () => {\n        if (!triedForward) cb(new Error('Unexpected connection close'));\n      }).connect(this._connectCfg);\n    }\n  }\n  exports[ctor === HttpAgent ? 'SSHTTPAgent' : 'SSHTTPSAgent'] = SSHAgent;\n}\nfunction noop() {}\nfunction decorateStream(stream, ctor, options) {\n  if (ctor === HttpAgent) {\n    // HTTP\n    stream.setKeepAlive = noop;\n    stream.setNoDelay = noop;\n    stream.setTimeout = noop;\n    stream.ref = noop;\n    stream.unref = noop;\n    stream.destroySoon = stream.destroy;\n    return stream;\n  }\n\n  // HTTPS\n  options.socket = stream;\n  const wrapped = tlsConnect(options);\n\n  // This is a workaround for a regression in node v12.16.3+\n  // https://github.com/nodejs/node/issues/35904\n  const onClose = (() => {\n    let called = false;\n    return () => {\n      if (called) return;\n      called = true;\n      if (stream.isPaused()) stream.resume();\n    };\n  })();\n  // 'end' listener is needed because 'close' is not emitted in some scenarios\n  // in node v12.x for some unknown reason\n  wrapped.on('end', onClose).on('close', onClose);\n  return wrapped;\n}","'use strict';\n\nconst {\n  AgentProtocol,\n  BaseAgent,\n  createAgent,\n  CygwinAgent,\n  OpenSSHAgent,\n  PageantAgent\n} = require('./agent.js');\nconst {\n  SSHTTPAgent: HTTPAgent,\n  SSHTTPSAgent: HTTPSAgent\n} = require('./http-agents.js');\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\nconst {\n  flagsToString,\n  OPEN_MODE,\n  STATUS_CODE,\n  stringToFlags\n} = require('./protocol/SFTP.js');\nmodule.exports = {\n  AgentProtocol,\n  BaseAgent,\n  createAgent,\n  Client: require('./client.js'),\n  CygwinAgent,\n  HTTPAgent,\n  HTTPSAgent,\n  OpenSSHAgent,\n  PageantAgent,\n  Server: require('./server.js'),\n  utils: {\n    parseKey,\n    ...require('./keygen.js'),\n    sftp: {\n      flagsToString,\n      OPEN_MODE,\n      STATUS_CODE,\n      stringToFlags\n    }\n  }\n};","'use strict';\n\nconst {\n  createCipheriv,\n  generateKeyPair: generateKeyPair_,\n  generateKeyPairSync: generateKeyPairSync_,\n  getCurves,\n  randomBytes\n} = require('crypto');\nconst {\n  Ber\n} = require('asn1');\nconst bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\nconst {\n  CIPHER_INFO\n} = require('./protocol/crypto.js');\nconst SALT_LEN = 16;\nconst DEFAULT_ROUNDS = 16;\nconst curves = getCurves();\nconst ciphers = new Map(Object.entries(CIPHER_INFO));\nfunction makeArgs(type, opts) {\n  if (typeof type !== 'string') throw new TypeError('Key type must be a string');\n  const publicKeyEncoding = {\n    type: 'spki',\n    format: 'der'\n  };\n  const privateKeyEncoding = {\n    type: 'pkcs8',\n    format: 'der'\n  };\n  switch (type.toLowerCase()) {\n    case 'rsa':\n      {\n        if (typeof opts !== 'object' || opts === null) throw new TypeError('Missing options object for RSA key');\n        const modulusLength = opts.bits;\n        if (!Number.isInteger(modulusLength)) throw new TypeError('RSA bits must be an integer');\n        if (modulusLength <= 0 || modulusLength > 16384) throw new RangeError('RSA bits must be non-zero and <= 16384');\n        return ['rsa', {\n          modulusLength,\n          publicKeyEncoding,\n          privateKeyEncoding\n        }];\n      }\n    case 'ecdsa':\n      {\n        if (typeof opts !== 'object' || opts === null) throw new TypeError('Missing options object for ECDSA key');\n        if (!Number.isInteger(opts.bits)) throw new TypeError('ECDSA bits must be an integer');\n        let namedCurve;\n        switch (opts.bits) {\n          case 256:\n            namedCurve = 'prime256v1';\n            break;\n          case 384:\n            namedCurve = 'secp384r1';\n            break;\n          case 521:\n            namedCurve = 'secp521r1';\n            break;\n          default:\n            throw new Error('ECDSA bits must be 256, 384, or 521');\n        }\n        if (!curves.includes(namedCurve)) throw new Error('Unsupported ECDSA bits value');\n        return ['ec', {\n          namedCurve,\n          publicKeyEncoding,\n          privateKeyEncoding\n        }];\n      }\n    case 'ed25519':\n      return ['ed25519', {\n        publicKeyEncoding,\n        privateKeyEncoding\n      }];\n    default:\n      throw new Error(`Unsupported key type: ${type}`);\n  }\n}\nfunction parseDERs(keyType, pub, priv) {\n  switch (keyType) {\n    case 'rsa':\n      {\n        // Note: we don't need to parse the public key since the PKCS8 private key\n        // already includes the public key parameters\n\n        // Parse private key\n        let reader = new Ber.Reader(priv);\n        reader.readSequence();\n\n        // - Version\n        if (reader.readInt() !== 0) throw new Error('Unsupported version in RSA private key');\n\n        // - Algorithm\n        reader.readSequence();\n        if (reader.readOID() !== '1.2.840.113549.1.1.1') throw new Error('Bad RSA private OID');\n        // - Algorithm parameters (RSA has none)\n        if (reader.readByte() !== Ber.Null) throw new Error('Malformed RSA private key (expected null)');\n        if (reader.readByte() !== 0x00) {\n          throw new Error('Malformed RSA private key (expected zero-length null)');\n        }\n        reader = new Ber.Reader(reader.readString(Ber.OctetString, true));\n        reader.readSequence();\n        if (reader.readInt() !== 0) throw new Error('Unsupported version in RSA private key');\n        const n = reader.readString(Ber.Integer, true);\n        const e = reader.readString(Ber.Integer, true);\n        const d = reader.readString(Ber.Integer, true);\n        const p = reader.readString(Ber.Integer, true);\n        const q = reader.readString(Ber.Integer, true);\n        reader.readString(Ber.Integer, true); // dmp1\n        reader.readString(Ber.Integer, true); // dmq1\n        const iqmp = reader.readString(Ber.Integer, true);\n\n        /*\n          OpenSSH RSA private key:\n            string  \"ssh-rsa\"\n            string  n -- public\n            string  e -- public\n            string  d -- private\n            string  iqmp -- private\n            string  p -- private\n            string  q -- private\n        */\n        const keyName = Buffer.from('ssh-rsa');\n        const privBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length);\n        let pos = 0;\n        privBuf.writeUInt32BE(keyName.length, pos += 0);\n        privBuf.set(keyName, pos += 4);\n        privBuf.writeUInt32BE(n.length, pos += keyName.length);\n        privBuf.set(n, pos += 4);\n        privBuf.writeUInt32BE(e.length, pos += n.length);\n        privBuf.set(e, pos += 4);\n        privBuf.writeUInt32BE(d.length, pos += e.length);\n        privBuf.set(d, pos += 4);\n        privBuf.writeUInt32BE(iqmp.length, pos += d.length);\n        privBuf.set(iqmp, pos += 4);\n        privBuf.writeUInt32BE(p.length, pos += iqmp.length);\n        privBuf.set(p, pos += 4);\n        privBuf.writeUInt32BE(q.length, pos += p.length);\n        privBuf.set(q, pos += 4);\n\n        /*\n          OpenSSH RSA public key:\n            string  \"ssh-rsa\"\n            string  e -- public\n            string  n -- public\n        */\n        const pubBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + e.length + 4 + n.length);\n        pos = 0;\n        pubBuf.writeUInt32BE(keyName.length, pos += 0);\n        pubBuf.set(keyName, pos += 4);\n        pubBuf.writeUInt32BE(e.length, pos += keyName.length);\n        pubBuf.set(e, pos += 4);\n        pubBuf.writeUInt32BE(n.length, pos += e.length);\n        pubBuf.set(n, pos += 4);\n        return {\n          sshName: keyName.toString(),\n          priv: privBuf,\n          pub: pubBuf\n        };\n      }\n    case 'ec':\n      {\n        // Parse public key\n        let reader = new Ber.Reader(pub);\n        reader.readSequence();\n        reader.readSequence();\n        if (reader.readOID() !== '1.2.840.10045.2.1') throw new Error('Bad ECDSA public OID');\n        // Skip curve OID, we'll get it from the private key\n        reader.readOID();\n        let pubBin = reader.readString(Ber.BitString, true);\n        {\n          // Remove leading zero bytes\n          let i = 0;\n          for (; i < pubBin.length && pubBin[i] === 0x00; ++i);\n          if (i > 0) pubBin = pubBin.slice(i);\n        }\n\n        // Parse private key\n        reader = new Ber.Reader(priv);\n        reader.readSequence();\n\n        // - Version\n        if (reader.readInt() !== 0) throw new Error('Unsupported version in ECDSA private key');\n        reader.readSequence();\n        if (reader.readOID() !== '1.2.840.10045.2.1') throw new Error('Bad ECDSA private OID');\n        const curveOID = reader.readOID();\n        let sshCurveName;\n        switch (curveOID) {\n          case '1.2.840.10045.3.1.7':\n            // prime256v1/secp256r1\n            sshCurveName = 'nistp256';\n            break;\n          case '1.3.132.0.34':\n            // secp384r1\n            sshCurveName = 'nistp384';\n            break;\n          case '1.3.132.0.35':\n            // secp521r1\n            sshCurveName = 'nistp521';\n            break;\n          default:\n            throw new Error('Unsupported curve in ECDSA private key');\n        }\n        reader = new Ber.Reader(reader.readString(Ber.OctetString, true));\n        reader.readSequence();\n\n        // - Version\n        if (reader.readInt() !== 1) throw new Error('Unsupported version in ECDSA private key');\n\n        // Add leading zero byte to prevent negative bignum in private key\n        const privBin = Buffer.concat([Buffer.from([0x00]), reader.readString(Ber.OctetString, true)]);\n\n        /*\n          OpenSSH ECDSA private key:\n            string  \"ecdsa-sha2-<sshCurveName>\"\n            string  curve name\n            string  Q -- public\n            string  d -- private\n        */\n        const keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);\n        sshCurveName = Buffer.from(sshCurveName);\n        const privBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length);\n        let pos = 0;\n        privBuf.writeUInt32BE(keyName.length, pos += 0);\n        privBuf.set(keyName, pos += 4);\n        privBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);\n        privBuf.set(sshCurveName, pos += 4);\n        privBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);\n        privBuf.set(pubBin, pos += 4);\n        privBuf.writeUInt32BE(privBin.length, pos += pubBin.length);\n        privBuf.set(privBin, pos += 4);\n\n        /*\n          OpenSSH ECDSA public key:\n            string  \"ecdsa-sha2-<sshCurveName>\"\n            string  curve name\n            string  Q -- public\n        */\n        const pubBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length);\n        pos = 0;\n        pubBuf.writeUInt32BE(keyName.length, pos += 0);\n        pubBuf.set(keyName, pos += 4);\n        pubBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);\n        pubBuf.set(sshCurveName, pos += 4);\n        pubBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);\n        pubBuf.set(pubBin, pos += 4);\n        return {\n          sshName: keyName.toString(),\n          priv: privBuf,\n          pub: pubBuf\n        };\n      }\n    case 'ed25519':\n      {\n        // Parse public key\n        let reader = new Ber.Reader(pub);\n        reader.readSequence();\n\n        // - Algorithm\n        reader.readSequence();\n        if (reader.readOID() !== '1.3.101.112') throw new Error('Bad ED25519 public OID');\n        // - Attributes (absent for ED25519)\n\n        let pubBin = reader.readString(Ber.BitString, true);\n        {\n          // Remove leading zero bytes\n          let i = 0;\n          for (; i < pubBin.length && pubBin[i] === 0x00; ++i);\n          if (i > 0) pubBin = pubBin.slice(i);\n        }\n\n        // Parse private key\n        reader = new Ber.Reader(priv);\n        reader.readSequence();\n\n        // - Version\n        if (reader.readInt() !== 0) throw new Error('Unsupported version in ED25519 private key');\n\n        // - Algorithm\n        reader.readSequence();\n        if (reader.readOID() !== '1.3.101.112') throw new Error('Bad ED25519 private OID');\n        // - Attributes (absent)\n\n        reader = new Ber.Reader(reader.readString(Ber.OctetString, true));\n        const privBin = reader.readString(Ber.OctetString, true);\n\n        /*\n          OpenSSH ed25519 private key:\n            string  \"ssh-ed25519\"\n            string  public key\n            string  private key + public key\n        */\n        const keyName = Buffer.from('ssh-ed25519');\n        const privBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length));\n        let pos = 0;\n        privBuf.writeUInt32BE(keyName.length, pos += 0);\n        privBuf.set(keyName, pos += 4);\n        privBuf.writeUInt32BE(pubBin.length, pos += keyName.length);\n        privBuf.set(pubBin, pos += 4);\n        privBuf.writeUInt32BE(privBin.length + pubBin.length, pos += pubBin.length);\n        privBuf.set(privBin, pos += 4);\n        privBuf.set(pubBin, pos += privBin.length);\n\n        /*\n          OpenSSH ed25519 public key:\n            string  \"ssh-ed25519\"\n            string  public key\n        */\n        const pubBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + pubBin.length);\n        pos = 0;\n        pubBuf.writeUInt32BE(keyName.length, pos += 0);\n        pubBuf.set(keyName, pos += 4);\n        pubBuf.writeUInt32BE(pubBin.length, pos += keyName.length);\n        pubBuf.set(pubBin, pos += 4);\n        return {\n          sshName: keyName.toString(),\n          priv: privBuf,\n          pub: pubBuf\n        };\n      }\n  }\n}\nfunction convertKeys(keyType, pub, priv, opts) {\n  let format = 'new';\n  let encrypted;\n  let comment = '';\n  if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.comment === 'string' && opts.comment) comment = opts.comment;\n    if (typeof opts.format === 'string' && opts.format) format = opts.format;\n    if (opts.passphrase) {\n      let passphrase;\n      if (typeof opts.passphrase === 'string') passphrase = Buffer.from(opts.passphrase);else if (Buffer.isBuffer(opts.passphrase)) passphrase = opts.passphrase;else throw new Error('Invalid passphrase');\n      if (opts.cipher === undefined) throw new Error('Missing cipher name');\n      const cipher = ciphers.get(opts.cipher);\n      if (cipher === undefined) throw new Error('Invalid cipher name');\n      if (format === 'new') {\n        let rounds = DEFAULT_ROUNDS;\n        if (opts.rounds !== undefined) {\n          if (!Number.isInteger(opts.rounds)) throw new TypeError('rounds must be an integer');\n          if (opts.rounds > 0) rounds = opts.rounds;\n        }\n        const gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen);\n        const salt = randomBytes(SALT_LEN);\n        const r = bcrypt_pbkdf(passphrase, passphrase.length, salt, salt.length, gen, gen.length, rounds);\n        if (r !== 0) return new Error('Failed to generate information to encrypt key');\n\n        /*\n          string salt\n          uint32 rounds\n        */\n        const kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);\n        {\n          let pos = 0;\n          kdfOptions.writeUInt32BE(salt.length, pos += 0);\n          kdfOptions.set(salt, pos += 4);\n          kdfOptions.writeUInt32BE(rounds, pos += salt.length);\n        }\n        encrypted = {\n          cipher,\n          cipherName: opts.cipher,\n          kdfName: 'bcrypt',\n          kdfOptions,\n          key: gen.slice(0, cipher.keyLen),\n          iv: gen.slice(cipher.keyLen)\n        };\n      }\n    }\n  }\n  switch (format) {\n    case 'new':\n      {\n        let privateB64 = '-----BEGIN OPENSSH PRIVATE KEY-----\\n';\n        let publicB64;\n        /*\n          byte[]  \"openssh-key-v1\\0\"\n          string  ciphername\n          string  kdfname\n          string  kdfoptions\n          uint32  number of keys N\n          string  publickey1\n          string  encrypted, padded list of private keys\n            uint32  checkint\n            uint32  checkint\n            byte[]  privatekey1\n            string  comment1\n            byte  1\n            byte  2\n            byte  3\n            ...\n            byte  padlen % 255\n        */\n        const cipherName = Buffer.from(encrypted ? encrypted.cipherName : 'none');\n        const kdfName = Buffer.from(encrypted ? encrypted.kdfName : 'none');\n        const kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0);\n        const blockLen = encrypted ? encrypted.cipher.blockLen : 8;\n        const parsed = parseDERs(keyType, pub, priv);\n        const checkInt = randomBytes(4);\n        const commentBin = Buffer.from(comment);\n        const privBlobLen = 4 + 4 + parsed.priv.length + 4 + commentBin.length;\n        let padding = [];\n        for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i) padding.push(i & 0xFF);\n        padding = Buffer.from(padding);\n        let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length);\n        let extra;\n        {\n          let pos = 0;\n          privBlob.set(checkInt, pos += 0);\n          privBlob.set(checkInt, pos += 4);\n          privBlob.set(parsed.priv, pos += 4);\n          privBlob.writeUInt32BE(commentBin.length, pos += parsed.priv.length);\n          privBlob.set(commentBin, pos += 4);\n          privBlob.set(padding, pos += commentBin.length);\n        }\n        if (encrypted) {\n          const options = {\n            authTagLength: encrypted.cipher.authLen\n          };\n          const cipher = createCipheriv(encrypted.cipher.sslName, encrypted.key, encrypted.iv, options);\n          cipher.setAutoPadding(false);\n          privBlob = Buffer.concat([cipher.update(privBlob), cipher.final()]);\n          if (encrypted.cipher.authLen > 0) extra = cipher.getAuthTag();else extra = Buffer.alloc(0);\n          encrypted.key.fill(0);\n          encrypted.iv.fill(0);\n        } else {\n          extra = Buffer.alloc(0);\n        }\n        const magicBytes = Buffer.from('openssh-key-v1\\0');\n        const privBin = Buffer.allocUnsafe(magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length);\n        {\n          let pos = 0;\n          privBin.set(magicBytes, pos += 0);\n          privBin.writeUInt32BE(cipherName.length, pos += magicBytes.length);\n          privBin.set(cipherName, pos += 4);\n          privBin.writeUInt32BE(kdfName.length, pos += cipherName.length);\n          privBin.set(kdfName, pos += 4);\n          privBin.writeUInt32BE(kdfOptions.length, pos += kdfName.length);\n          privBin.set(kdfOptions, pos += 4);\n          privBin.writeUInt32BE(1, pos += kdfOptions.length);\n          privBin.writeUInt32BE(parsed.pub.length, pos += 4);\n          privBin.set(parsed.pub, pos += 4);\n          privBin.writeUInt32BE(privBlob.length, pos += parsed.pub.length);\n          privBin.set(privBlob, pos += 4);\n          privBin.set(extra, pos += privBlob.length);\n        }\n        {\n          const b64 = privBin.base64Slice(0, privBin.length);\n          let formatted = b64.replace(/.{64}/g, '$&\\n');\n          if (b64.length & 63) formatted += '\\n';\n          privateB64 += formatted;\n        }\n        {\n          const b64 = parsed.pub.base64Slice(0, parsed.pub.length);\n          publicB64 = `${parsed.sshName} ${b64}${comment ? ` ${comment}` : ''}`;\n        }\n        privateB64 += '-----END OPENSSH PRIVATE KEY-----\\n';\n        return {\n          private: privateB64,\n          public: publicB64\n        };\n      }\n    default:\n      throw new Error('Invalid output key format');\n  }\n}\nfunction noop() {}\nmodule.exports = {\n  generateKeyPair: (keyType, opts, cb) => {\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = undefined;\n    }\n    if (typeof cb !== 'function') cb = noop;\n    const args = makeArgs(keyType, opts);\n    generateKeyPair_(...args, (err, pub, priv) => {\n      if (err) return cb(err);\n      let ret;\n      try {\n        ret = convertKeys(args[0], pub, priv, opts);\n      } catch (ex) {\n        return cb(ex);\n      }\n      cb(null, ret);\n    });\n  },\n  generateKeyPairSync: (keyType, opts) => {\n    const args = makeArgs(keyType, opts);\n    const {\n      publicKey: pub,\n      privateKey: priv\n    } = generateKeyPairSync_(...args);\n    return convertKeys(args[0], pub, priv, opts);\n  }\n};","/*\n  TODO:\n    * Replace `buffer._pos` usage in keyParser.js and elsewhere\n    * Utilize optional \"writev\" support when writing packets from\n      cipher.encrypt()\n    * Built-in support for automatic re-keying, on by default\n    * Revisit receiving unexpected/unknown packets\n      * Error (fatal or otherwise) or ignore or pass on to user (in some or all\n        cases)?\n      * Including server/client check for single directional packet types?\n      * Check packets for validity or bail as early as possible?\n    * Automatic re-key every 2**31 packets after the last key exchange (sent or\n      received), as suggested by RFC4344. OpenSSH currently does this.\n    * Automatic re-key every so many blocks depending on cipher. RFC4344:\n         Because of a birthday property of block ciphers and some modes of\n         operation, implementations must be careful not to encrypt too many\n         blocks with the same encryption key.\n\n         Let L be the block length (in bits) of an SSH encryption method's\n         block cipher (e.g., 128 for AES).  If L is at least 128, then, after\n         rekeying, an SSH implementation SHOULD NOT encrypt more than 2**(L/4)\n         blocks before rekeying again.  If L is at least 128, then SSH\n         implementations should also attempt to force a rekey before receiving\n         more than 2**(L/4) blocks.  If L is less than 128 (which is the case\n         for older ciphers such as 3DES, Blowfish, CAST-128, and IDEA), then,\n         although it may be too expensive to rekey every 2**(L/4) blocks, it\n         is still advisable for SSH implementations to follow the original\n         recommendation in [RFC4253]: rekey at least once for every gigabyte\n         of transmitted data.\n\n         Note that if L is less than or equal to 128, then the recommendation\n         in this subsection supersedes the recommendation in Section 3.1.  If\n         an SSH implementation uses a block cipher with a larger block size\n         (e.g., Rijndael with 256-bit blocks), then the recommendations in\n         Section 3.1 may supersede the recommendations in this subsection\n         (depending on the lengths of the packets).\n*/\n\n'use strict';\n\nconst {\n  inspect\n} = require('util');\nconst {\n  bindingAvailable,\n  NullCipher,\n  NullDecipher\n} = require('./crypto.js');\nconst {\n  COMPAT_CHECKS,\n  DISCONNECT_REASON,\n  eddsaSupported,\n  MESSAGE,\n  SIGNALS,\n  TERMINAL_MODE\n} = require('./constants.js');\nconst {\n  DEFAULT_KEXINIT_CLIENT,\n  DEFAULT_KEXINIT_SERVER,\n  KexInit,\n  kexinit,\n  onKEXPayload\n} = require('./kex.js');\nconst {\n  parseKey\n} = require('./keyParser.js');\nconst MESSAGE_HANDLERS = require('./handlers.js');\nconst {\n  bufferCopy,\n  bufferFill,\n  bufferSlice,\n  convertSignature,\n  sendPacket,\n  writeUInt32BE\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\nconst MODULE_VER = require('../../package.json').version;\nconst VALID_DISCONNECT_REASONS = new Map(Object.values(DISCONNECT_REASON).map(n => [n, 1]));\nconst IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);\nconst IDENT = Buffer.from(`${IDENT_RAW}\\r\\n`);\nconst MAX_LINE_LEN = 8192;\nconst MAX_LINES = 1024;\nconst PING_PAYLOAD = Buffer.from([MESSAGE.GLOBAL_REQUEST,\n// \"keepalive@openssh.com\"\n0, 0, 0, 21, 107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115, 115, 104, 46, 99, 111, 109,\n// Request a reply\n1]);\nconst NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);\nfunction noop() {}\n\n/*\n  Inbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * raw ident\n    * rekey packet queue\n    * expected packet (implemented as separate _parse() function?)\n  Outbound:\n    * kexinit payload (needed only until exchange hash is generated)\n    * rekey packet queue\n    * kex secret (needed only until NEWKEYS)\n    * exchange hash (needed only until NEWKEYS)\n    * session ID (set to exchange hash from initial handshake)\n*/\nclass Protocol {\n  constructor(config) {\n    const onWrite = config.onWrite;\n    if (typeof onWrite !== 'function') throw new Error('Missing onWrite function');\n    this._onWrite = data => {\n      onWrite(data);\n    };\n    const onError = config.onError;\n    if (typeof onError !== 'function') throw new Error('Missing onError function');\n    this._onError = err => {\n      onError(err);\n    };\n    const debug = config.debug;\n    this._debug = typeof debug === 'function' ? msg => {\n      debug(msg);\n    } : undefined;\n    const onHeader = config.onHeader;\n    this._onHeader = typeof onHeader === 'function' ? (...args) => {\n      onHeader(...args);\n    } : noop;\n    const onPacket = config.onPacket;\n    this._onPacket = typeof onPacket === 'function' ? () => {\n      onPacket();\n    } : noop;\n    let onHandshakeComplete = config.onHandshakeComplete;\n    if (typeof onHandshakeComplete !== 'function') onHandshakeComplete = noop;\n    let firstHandshake;\n    this._onHandshakeComplete = (...args) => {\n      this._debug && this._debug('Handshake completed');\n      if (firstHandshake === undefined) firstHandshake = true;else firstHandshake = false;\n\n      // Process packets queued during a rekey where necessary\n      const oldQueue = this._queue;\n      if (oldQueue) {\n        this._queue = undefined;\n        this._debug && this._debug(`Draining outbound queue (${oldQueue.length}) ...`);\n        for (let i = 0; i < oldQueue.length; ++i) {\n          const data = oldQueue[i];\n          // data === payload only\n\n          // XXX: hacky\n          let finalized = this._packetRW.write.finalize(data);\n          if (finalized === data) {\n            const packet = this._cipher.allocPacket(data.length);\n            packet.set(data, 5);\n            finalized = packet;\n          }\n          sendPacket(this, finalized);\n        }\n        this._debug && this._debug('... finished draining outbound queue');\n      }\n      if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled) sendExtInfo(this);\n      onHandshakeComplete(...args);\n    };\n    this._queue = undefined;\n    const messageHandlers = config.messageHandlers;\n    if (typeof messageHandlers === 'object' && messageHandlers !== null) this._handlers = messageHandlers;else this._handlers = {};\n    this._onPayload = onPayload.bind(this);\n    this._server = !!config.server;\n    this._banner = undefined;\n    let greeting;\n    if (this._server) {\n      if (typeof config.hostKeys !== 'object' || config.hostKeys === null) throw new Error('Missing server host key(s)');\n      this._hostKeys = config.hostKeys;\n\n      // Greeting displayed before the ssh identification string is sent, this\n      // is usually ignored by most clients\n      if (typeof config.greeting === 'string' && config.greeting.length) {\n        greeting = config.greeting.slice(-2) === '\\r\\n' ? config.greeting : `${config.greeting}\\r\\n`;\n      }\n\n      // Banner shown after the handshake completes, but before user\n      // authentication begins\n      if (typeof config.banner === 'string' && config.banner.length) {\n        this._banner = config.banner.slice(-2) === '\\r\\n' ? config.banner : `${config.banner}\\r\\n`;\n      }\n    } else {\n      this._hostKeys = undefined;\n    }\n    let offer = config.offer;\n    if (typeof offer !== 'object' || offer === null) {\n      offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;\n    } else if (offer.constructor !== KexInit) {\n      if (this._server) {\n        offer.kex = offer.kex.concat(['kex-strict-s-v00@openssh.com']);\n      } else {\n        offer.kex = offer.kex.concat(['ext-info-c', 'kex-strict-c-v00@openssh.com']);\n      }\n      offer = new KexInit(offer);\n    }\n    this._kex = undefined;\n    this._strictMode = undefined;\n    this._kexinit = undefined;\n    this._offer = offer;\n    this._cipher = new NullCipher(0, this._onWrite);\n    this._decipher = undefined;\n    this._skipNextInboundPacket = false;\n    this._packetRW = {\n      read: new PacketReader(),\n      write: new PacketWriter(this)\n    };\n    this._hostVerifier = !this._server && typeof config.hostVerifier === 'function' ? config.hostVerifier : undefined;\n    this._parse = parseHeader;\n    this._buffer = undefined;\n    this._authsQueue = [];\n    this._authenticated = false;\n    this._remoteIdentRaw = undefined;\n    let sentIdent;\n    if (typeof config.ident === 'string') {\n      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);\n      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);\n      sentIdent.set(this._identRaw, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else if (Buffer.isBuffer(config.ident)) {\n      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);\n      fullIdent.latin1Write('SSH-2.0-', 0, 8);\n      fullIdent.set(config.ident, 8);\n      this._identRaw = fullIdent;\n      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);\n      sentIdent.set(fullIdent, 0);\n      sentIdent[sentIdent.length - 2] = 13; // '\\r'\n      sentIdent[sentIdent.length - 1] = 10; // '\\n'\n    } else {\n      this._identRaw = IDENT_RAW;\n      sentIdent = IDENT;\n    }\n    this._compatFlags = 0;\n    if (this._debug) {\n      if (bindingAvailable) this._debug('Custom crypto binding available');else this._debug('Custom crypto binding not available');\n    }\n    this._debug && this._debug(`Local ident: ${inspect(this._identRaw.toString())}`);\n    this.start = () => {\n      this.start = undefined;\n      if (greeting) this._onWrite(greeting);\n      this._onWrite(sentIdent);\n    };\n  }\n  _destruct(reason) {\n    this._packetRW.read.cleanup();\n    this._packetRW.write.cleanup();\n    this._cipher && this._cipher.free();\n    this._decipher && this._decipher.free();\n    if (typeof reason !== 'string' || reason.length === 0) reason = 'fatal error';\n    this.parse = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._onWrite = () => {\n      throw new Error(`Instance unusable after ${reason}`);\n    };\n    this._destruct = undefined;\n  }\n  cleanup() {\n    this._destruct && this._destruct();\n  }\n  parse(chunk, i, len) {\n    while (i < len) i = this._parse(chunk, i, len);\n  }\n\n  // Protocol message API\n\n  // ===========================================================================\n  // Common/Shared =============================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  disconnect(reason) {\n    const pktLen = 1 + 4 + 4 + 4;\n    // We don't use _packetRW.write.* here because we need to make sure that\n    // we always get a full packet allocated because this message can be sent\n    // at any time -- even during a key exchange\n    let p = this._packetRW.write.allocStartKEX;\n    const packet = this._packetRW.write.alloc(pktLen, true);\n    const end = p + pktLen;\n    if (!VALID_DISCONNECT_REASONS.has(reason)) reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    packet[p] = MESSAGE.DISCONNECT;\n    writeUInt32BE(packet, reason, ++p);\n    packet.fill(0, p += 4, end);\n    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);\n    sendPacket(this, this._packetRW.write.finalize(packet, true), true);\n  }\n  ping() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);\n    packet.set(PING_PAYLOAD, p);\n    this._debug && this._debug('Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  rekey() {\n    if (this._kexinit === undefined) {\n      this._debug && this._debug('Outbound: Initiated explicit rekey');\n      this._queue = [];\n      kexinit(this);\n    } else {\n      this._debug && this._debug('Outbound: Ignoring rekey during handshake');\n    }\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  requestSuccess(data) {\n    let p = this._packetRW.write.allocStart;\n    let packet;\n    if (Buffer.isBuffer(data)) {\n      packet = this._packetRW.write.alloc(1 + data.length);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n      packet.set(data, ++p);\n    } else {\n      packet = this._packetRW.write.alloc(1);\n      packet[p] = MESSAGE.REQUEST_SUCCESS;\n    }\n    this._debug && this._debug('Outbound: Sending REQUEST_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  requestFailure() {\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n    packet[p] = MESSAGE.REQUEST_FAILURE;\n    this._debug && this._debug('Outbound: Sending REQUEST_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelSuccess(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_SUCCESS;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelFailure(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_FAILURE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelEOF(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_EOF;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelClose(chan) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4);\n    packet[p] = MESSAGE.CHANNEL_CLOSE;\n    writeUInt32BE(packet, chan, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelWindowAdjust(chan, amount) {\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, amount, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelData(chan, data) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);\n    packet[p] = MESSAGE.CHANNEL_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelExtData(chan, data, type) {\n    const isBuffer = Buffer.isBuffer(data);\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);\n    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, type, p += 4);\n    writeUInt32BE(packet, dataLen, p += 4);\n    if (isBuffer) packet.set(data, p += 4);else packet.utf8Write(data, p += 4, dataLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenConfirm(remote, local, initWindow, maxPacket) {\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, local, p += 4);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  channelOpenFail(remote, reason, desc) {\n    if (typeof desc !== 'string') desc = '';\n    const descLen = Buffer.byteLength(desc);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;\n    writeUInt32BE(packet, remote, ++p);\n    writeUInt32BE(packet, reason, p += 4);\n    writeUInt32BE(packet, descLen, p += 4);\n    p += 4;\n    if (descLen) {\n      packet.utf8Write(desc, p, descLen);\n      p += descLen;\n    }\n    writeUInt32BE(packet, 0, p); // Empty language tag\n\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  service(name) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);\n    packet[p] = MESSAGE.SERVICE_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-userauth' service-specific\n  // -------------------------------\n  authPassword(username, password, newPassword) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    const passLen = Buffer.byteLength(password);\n    const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0));\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 8, p += 14);\n    packet.utf8Write('password', p += 4, 8);\n    packet[p += 8] = newPassword ? 1 : 0;\n    writeUInt32BE(packet, passLen, ++p);\n    if (Buffer.isBuffer(password)) bufferCopy(password, packet, 0, passLen, p += 4);else packet.utf8Write(password, p += 4, passLen);\n    if (newPassword) {\n      writeUInt32BE(packet, newPassLen, p += passLen);\n      if (Buffer.isBuffer(newPassword)) bufferCopy(newPassword, packet, 0, newPassLen, p += 4);else packet.utf8Write(newPassword, p += 4, newPassLen);\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (changed password)');\n    } else {\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (password)');\n    }\n    this._authsQueue.push('password');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPK(username, pubKey, keyAlgo, cbSign) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    if (typeof keyAlgo === 'function') {\n      cbSign = keyAlgo;\n      keyAlgo = undefined;\n    }\n    if (!keyAlgo) keyAlgo = keyType;\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyAlgo);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;\n    let packet;\n    let p;\n    if (cbSign) {\n      packet = Buffer.allocUnsafe(payloadLen);\n      p = 0;\n      writeUInt32BE(packet, sesLen, p);\n      packet.set(sessionID, p += 4);\n      p += sesLen;\n    } else {\n      packet = this._packetRW.write.alloc(payloadLen);\n      p = this._packetRW.write.allocStart;\n    }\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 9, p += 14);\n    packet.utf8Write('publickey', p += 4, 9);\n    packet[p += 9] = cbSign ? 1 : 0;\n    writeUInt32BE(packet, algoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, algoLen);\n    writeUInt32BE(packet, pubKeyLen, p += algoLen);\n    packet.set(pubKey, p += 4);\n    if (!cbSign) {\n      this._authsQueue.push('publickey');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey -- check)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n      return;\n    }\n    cbSign(packet, signature => {\n      signature = convertSignature(signature, keyType);\n      if (signature === false) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      p = this._packetRW.write.allocStart;\n      packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen);\n\n      // TODO: simply copy from original \"packet\" to new `packet` to avoid\n      // having to write each individual field a second time?\n      packet[p] = MESSAGE.USERAUTH_REQUEST;\n      writeUInt32BE(packet, userLen, ++p);\n      packet.utf8Write(username, p += 4, userLen);\n      writeUInt32BE(packet, 14, p += userLen);\n      packet.utf8Write('ssh-connection', p += 4, 14);\n      writeUInt32BE(packet, 9, p += 14);\n      packet.utf8Write('publickey', p += 4, 9);\n      packet[p += 9] = 1;\n      writeUInt32BE(packet, algoLen, ++p);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, pubKeyLen, p += algoLen);\n      packet.set(pubKey, p += 4);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n\n      // Servers shouldn't send packet type 60 in response to signed publickey\n      // attempts, but if they do, interpret as type 60.\n      this._authsQueue.push('publickey');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (publickey)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {\n    // TODO: Make DRY by sharing similar code with authPK()\n    if (this._server) throw new Error('Client-only method called in server mode');\n    pubKey = parseKey(pubKey);\n    if (pubKey instanceof Error) throw new Error('Invalid key');\n    const keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n    if (typeof keyAlgo === 'function') {\n      cbSign = keyAlgo;\n      keyAlgo = undefined;\n    }\n    if (!keyAlgo) keyAlgo = keyType;\n    const userLen = Buffer.byteLength(username);\n    const algoLen = Buffer.byteLength(keyAlgo);\n    const pubKeyLen = pubKey.length;\n    const sessionID = this._kex.sessionID;\n    const sesLen = sessionID.length;\n    const hostnameLen = Buffer.byteLength(hostname);\n    const userlocalLen = Buffer.byteLength(userlocal);\n    const data = Buffer.allocUnsafe(4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen);\n    let p = 0;\n    writeUInt32BE(data, sesLen, p);\n    data.set(sessionID, p += 4);\n    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(data, userLen, ++p);\n    data.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(data, 14, p += userLen);\n    data.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(data, 9, p += 14);\n    data.utf8Write('hostbased', p += 4, 9);\n    writeUInt32BE(data, algoLen, p += 9);\n    data.utf8Write(keyAlgo, p += 4, algoLen);\n    writeUInt32BE(data, pubKeyLen, p += algoLen);\n    data.set(pubKey, p += 4);\n    writeUInt32BE(data, hostnameLen, p += pubKeyLen);\n    data.utf8Write(hostname, p += 4, hostnameLen);\n    writeUInt32BE(data, userlocalLen, p += hostnameLen);\n    data.utf8Write(userlocal, p += 4, userlocalLen);\n    cbSign(data, signature => {\n      signature = convertSignature(signature, keyType);\n      if (!signature) throw new Error('Error while converting handshake signature');\n      const sigLen = signature.length;\n      const reqDataLen = data.length - sesLen - 4;\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(reqDataLen + 4 + 4 + algoLen + 4 + sigLen);\n      bufferCopy(data, packet, 4 + sesLen, data.length, p);\n      writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);\n      writeUInt32BE(packet, algoLen, p += 4);\n      packet.utf8Write(keyAlgo, p += 4, algoLen);\n      writeUInt32BE(packet, sigLen, p += algoLen);\n      packet.set(signature, p += 4);\n      this._authsQueue.push('hostbased');\n      this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (hostbased)');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    });\n  }\n  authKeyboard(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4);\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 20, p += 14);\n    packet.utf8Write('keyboard-interactive', p += 4, 20);\n    writeUInt32BE(packet, 0, p += 20);\n    writeUInt32BE(packet, 0, p += 4);\n    this._authsQueue.push('keyboard-interactive');\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authNone(username) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const userLen = Buffer.byteLength(username);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);\n    packet[p] = MESSAGE.USERAUTH_REQUEST;\n    writeUInt32BE(packet, userLen, ++p);\n    packet.utf8Write(username, p += 4, userLen);\n    writeUInt32BE(packet, 14, p += userLen);\n    packet.utf8Write('ssh-connection', p += 4, 14);\n    writeUInt32BE(packet, 4, p += 14);\n    packet.utf8Write('none', p += 4, 4);\n    this._authsQueue.push('none');\n    this._debug && this._debug('Outbound: Sending USERAUTH_REQUEST (none)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoRes(responses) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let responsesTotalLen = 0;\n    let responseLens;\n    if (responses) {\n      responseLens = new Array(responses.length);\n      for (let i = 0; i < responses.length; ++i) {\n        const len = Buffer.byteLength(responses[i]);\n        responseLens[i] = len;\n        responsesTotalLen += 4 + len;\n      }\n    }\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);\n    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;\n    if (responses) {\n      writeUInt32BE(packet, responses.length, ++p);\n      p += 4;\n      for (let i = 0; i < responses.length; ++i) {\n        const len = responseLens[i];\n        writeUInt32BE(packet, len, p);\n        p += 4;\n        if (len) {\n          packet.utf8Write(responses[i], p, len);\n          p += len;\n        }\n      }\n    } else {\n      writeUInt32BE(packet, 0, ++p);\n    }\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_RESPONSE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // 'ssh-connection' service-specific\n  // ---------------------------------\n  tcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 13, ++p);\n    packet.utf8Write('tcpip-forward', p += 4, 13);\n    packet[p += 13] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  cancelTcpipForward(bindAddr, bindPort, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const addrLen = Buffer.byteLength(bindAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 20, ++p);\n    packet.utf8Write('cancel-tcpip-forward', p += 4, 20);\n    packet[p += 20] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, addrLen, ++p);\n    packet.utf8Write(bindAddr, p += 4, addrLen);\n    writeUInt32BE(packet, bindPort, p += addrLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_streamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + socketPathLen);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 31, ++p);\n    packet.utf8Write('streamlocal-forward@openssh.com', p += 4, 31);\n    packet[p += 31] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_cancelStreamLocalForward(socketPath, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const socketPathLen = Buffer.byteLength(socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + socketPathLen);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 38, ++p);\n    packet.utf8Write('cancel-streamlocal-forward@openssh.com', p += 4, 38);\n    packet[p += 38] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, socketPathLen, ++p);\n    packet.utf8Write(socketPath, p += 4, socketPathLen);\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST ' + '(cancel-streamlocal-forward@openssh.com)');\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  directTcpip(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const srcLen = Buffer.byteLength(cfg.srcIP);\n    const dstLen = Buffer.byteLength(cfg.dstIP);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 12, ++p);\n    packet.utf8Write('direct-tcpip', p += 4, 12);\n    writeUInt32BE(packet, chan, p += 12);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, dstLen, p += 4);\n    packet.utf8Write(cfg.dstIP, p += 4, dstLen);\n    writeUInt32BE(packet, cfg.dstPort, p += dstLen);\n    writeUInt32BE(packet, srcLen, p += 4);\n    packet.utf8Write(cfg.srcIP, p += 4, srcLen);\n    writeUInt32BE(packet, cfg.srcPort, p += srcLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 30, ++p);\n    packet.utf8Write('direct-streamlocal@openssh.com', p += 4, 30);\n    writeUInt32BE(packet, chan, p += 30);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n\n    // zero-fill reserved fields (string and uint32)\n    bufferFill(packet, 0, p += pathLen, p + 8);\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, direct-streamlocal@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_noMoreSessions(wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 28, ++p);\n    packet.utf8Write('no-more-sessions@openssh.com', p += 4, 28);\n    packet[p += 28] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug('Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  session(chan, initWindow, maxPacket) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 7, ++p);\n    packet.utf8Write('session', p += 4, 7);\n    writeUInt32BE(packet, chan, p += 7);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  windowChange(chan, rows, cols, height, width) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 13, p += 4);\n    packet.utf8Write('window-change', p += 4, 13);\n    packet[p += 13] = 0;\n    writeUInt32BE(packet, cols, ++p);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  pty(chan, rows, cols, height, width, term, modes, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    if (!term || !term.length) term = 'vt100';\n    if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === 'object' && modes !== null) {\n      modes = modesToBytes(modes);\n    }\n    if (!modes || !modes.length) modes = NO_TERMINAL_MODES_BUFFER;\n    const termLen = term.length;\n    const modesLen = modes.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('pty-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, termLen, ++p);\n    packet.utf8Write(term, p += 4, termLen);\n    writeUInt32BE(packet, cols, p += termLen);\n    writeUInt32BE(packet, rows, p += 4);\n    writeUInt32BE(packet, width, p += 4);\n    writeUInt32BE(packet, height, p += 4);\n    writeUInt32BE(packet, modesLen, p += 4);\n    p += 4;\n    if (Array.isArray(modes)) {\n      for (let i = 0; i < modesLen; ++i) packet[p++] = modes[i];\n    } else if (Buffer.isBuffer(modes)) {\n      packet.set(modes, p);\n    }\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  shell(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 5, p += 4);\n    packet.utf8Write('shell', p += 4, 5);\n    packet[p += 5] = wantReply === undefined || wantReply === true ? 1 : 0;\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exec(chan, cmd, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const isBuf = Buffer.isBuffer(cmd);\n    const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 4, p += 4);\n    packet.utf8Write('exec', p += 4, 4);\n    packet[p += 4] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, cmdLen, ++p);\n    if (isBuf) packet.set(cmd, p += 4);else packet.utf8Write(cmd, p += 4, cmdLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  signal(chan, signal) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const origSignal = signal;\n    signal = signal.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const signalLen = signal.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 6, p += 4);\n    packet.utf8Write('signal', p += 4, 6);\n    packet[p += 6] = 0;\n    writeUInt32BE(packet, signalLen, ++p);\n    packet.utf8Write(signal, p += 4, signalLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  env(chan, key, val, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const keyLen = Buffer.byteLength(key);\n    const isBuf = Buffer.isBuffer(val);\n    const valLen = isBuf ? val.length : Buffer.byteLength(val);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 3, p += 4);\n    packet.utf8Write('env', p += 4, 3);\n    packet[p += 3] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, keyLen, ++p);\n    packet.utf8Write(key, p += 4, keyLen);\n    writeUInt32BE(packet, valLen, p += keyLen);\n    if (isBuf) packet.set(val, p += 4);else packet.utf8Write(val, p += 4, valLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11Forward(chan, cfg, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    const protocol = cfg.protocol;\n    const cookie = cfg.cookie;\n    const isBufProto = Buffer.isBuffer(protocol);\n    const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);\n    const isBufCookie = Buffer.isBuffer(cookie);\n    const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 7, p += 4);\n    packet.utf8Write('x11-req', p += 4, 7);\n    packet[p += 7] = wantReply === undefined || wantReply === true ? 1 : 0;\n    packet[++p] = cfg.single ? 1 : 0;\n    writeUInt32BE(packet, protoLen, ++p);\n    if (isBufProto) packet.set(protocol, p += 4);else packet.utf8Write(protocol, p += 4, protoLen);\n    writeUInt32BE(packet, cookieLen, p += protoLen);\n    if (isBufCookie) packet.set(cookie, p += 4);else packet.latin1Write(cookie, p += 4, cookieLen);\n    writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  subsystem(chan, name, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n    const nameLen = Buffer.byteLength(name);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 9, p += 4);\n    packet.utf8Write('subsystem', p += 4, 9);\n    packet[p += 9] = wantReply === undefined || wantReply === true ? 1 : 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(name, p += 4, nameLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_agentForward(chan, wantReply) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n\n    // Does not consume window space\n\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 26, p += 4);\n    packet.utf8Write('auth-agent-req@openssh.com', p += 4, 26);\n    packet[p += 26] = wantReply === undefined || wantReply === true ? 1 : 0;\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_REQUEST ' + `(r:${chan}, auth-agent-req@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_hostKeysProve(keys) {\n    if (this._server) throw new Error('Client-only method called in server mode');\n    let keysTotal = 0;\n    const publicKeys = [];\n    for (const key of keys) {\n      const publicKey = key.getPublicSSH();\n      keysTotal += 4 + publicKey.length;\n      publicKeys.push(publicKey);\n    }\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);\n    packet[p] = MESSAGE.GLOBAL_REQUEST;\n    writeUInt32BE(packet, 29, ++p);\n    packet.utf8Write('hostkeys-prove-00@openssh.com', p += 4, 29);\n    packet[p += 29] = 1; // want reply\n\n    ++p;\n    for (const buf of publicKeys) {\n      writeUInt32BE(packet, buf.length, p);\n      bufferCopy(buf, packet, 0, buf.length, p += 4);\n      p += buf.length;\n    }\n    if (this._debug) {\n      this._debug('Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)');\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n\n  // Global\n  // ------\n  serviceAccept(svcName) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const svcNameLen = Buffer.byteLength(svcName);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);\n    packet[p] = MESSAGE.SERVICE_ACCEPT;\n    writeUInt32BE(packet, svcNameLen, ++p);\n    packet.utf8Write(svcName, p += 4, svcNameLen);\n    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._server && this._banner && svcName === 'ssh-userauth') {\n      const banner = this._banner;\n      this._banner = undefined; // Prevent banner from being displayed again\n      const bannerLen = Buffer.byteLength(banner);\n      p = this._packetRW.write.allocStart;\n      const packet = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);\n      packet[p] = MESSAGE.USERAUTH_BANNER;\n      writeUInt32BE(packet, bannerLen, ++p);\n      packet.utf8Write(banner, p += 4, bannerLen);\n      writeUInt32BE(packet, 0, p += bannerLen); // Empty language tag\n\n      this._debug && this._debug('Outbound: Sending USERAUTH_BANNER');\n      sendPacket(this, this._packetRW.write.finalize(packet));\n    }\n  }\n  // 'ssh-connection' service-specific\n  forwardedTcpip(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 15, ++p);\n    packet.utf8Write('forwarded-tcpip', p += 4, 15);\n    writeUInt32BE(packet, chan, p += 15);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, boundAddrLen, p += 4);\n    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);\n    writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);\n    writeUInt32BE(packet, remoteAddrLen, p += 4);\n    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);\n    writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  x11(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const addrLen = Buffer.byteLength(cfg.originAddr);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 3, ++p);\n    packet.utf8Write('x11', p += 4, 3);\n    writeUInt32BE(packet, chan, p += 3);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, addrLen, p += 4);\n    packet.utf8Write(cfg.originAddr, p += 4, addrLen);\n    writeUInt32BE(packet, cfg.originPort, p += addrLen);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_authAgent(chan, initWindow, maxPacket) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 22, ++p);\n    packet.utf8Write('auth-agent@openssh.com', p += 4, 22);\n    writeUInt32BE(packet, chan, p += 22);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const pathLen = Buffer.byteLength(cfg.socketPath);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4);\n    packet[p] = MESSAGE.CHANNEL_OPEN;\n    writeUInt32BE(packet, 33, ++p);\n    packet.utf8Write('forwarded-streamlocal@openssh.com', p += 4, 33);\n    writeUInt32BE(packet, chan, p += 33);\n    writeUInt32BE(packet, initWindow, p += 4);\n    writeUInt32BE(packet, maxPacket, p += 4);\n    writeUInt32BE(packet, pathLen, p += 4);\n    packet.utf8Write(cfg.socketPath, p += 4, pathLen);\n    writeUInt32BE(packet, 0, p += pathLen);\n    if (this._debug) {\n      this._debug('Outbound: Sending CHANNEL_OPEN ' + `(r:${chan}, forwarded-streamlocal@openssh.com)`);\n    }\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitStatus(chan, status) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-status', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, status, ++p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  exitSignal(chan, name, coreDumped, msg) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n\n    // Does not consume window space\n\n    const origSignal = name;\n    if (typeof origSignal !== 'string' || !origSignal) throw new Error(`Invalid signal: ${origSignal}`);\n    let signal = name.toUpperCase();\n    if (signal.slice(0, 3) === 'SIG') signal = signal.slice(3);\n    if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);\n    const nameLen = Buffer.byteLength(signal);\n    const msgLen = msg ? Buffer.byteLength(msg) : 0;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);\n    packet[p] = MESSAGE.CHANNEL_REQUEST;\n    writeUInt32BE(packet, chan, ++p);\n    writeUInt32BE(packet, 11, p += 4);\n    packet.utf8Write('exit-signal', p += 4, 11);\n    packet[p += 11] = 0;\n    writeUInt32BE(packet, nameLen, ++p);\n    packet.utf8Write(signal, p += 4, nameLen);\n    packet[p += nameLen] = coreDumped ? 1 : 0;\n    writeUInt32BE(packet, msgLen, ++p);\n    p += 4;\n    if (msgLen) {\n      packet.utf8Write(msg, p, msgLen);\n      p += msgLen;\n    }\n    writeUInt32BE(packet, 0, p);\n    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`);\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  // 'ssh-userauth' service-specific\n  authFailure(authMethods, isPartial) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    let methods;\n    if (typeof authMethods === 'boolean') {\n      isPartial = authMethods;\n      authMethods = undefined;\n    }\n    if (authMethods) {\n      methods = [];\n      for (let i = 0; i < authMethods.length; ++i) {\n        if (authMethods[i].toLowerCase() === 'none') continue;\n        methods.push(authMethods[i]);\n      }\n      methods = methods.join(',');\n    } else {\n      methods = '';\n    }\n    const methodsLen = methods.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);\n    packet[p] = MESSAGE.USERAUTH_FAILURE;\n    writeUInt32BE(packet, methodsLen, ++p);\n    packet.utf8Write(methods, p += 4, methodsLen);\n    packet[p += methodsLen] = isPartial === true ? 1 : 0;\n    this._authsQueue.shift();\n    this._debug && this._debug('Outbound: Sending USERAUTH_FAILURE');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authSuccess() {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0) throw new Error('No auth in progress');\n    const p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1);\n    packet[p] = MESSAGE.USERAUTH_SUCCESS;\n    this._authsQueue.shift();\n    this._authenticated = true;\n    this._debug && this._debug('Outbound: Sending USERAUTH_SUCCESS');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n  }\n  authPKOK(keyAlgo, key) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    if (this._authsQueue.length === 0 || this._authsQueue[0] !== 'publickey') throw new Error('\"publickey\" auth not in progress');\n\n    // TODO: support parsed key for `key`\n\n    const keyAlgoLen = Buffer.byteLength(keyAlgo);\n    const keyLen = key.length;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);\n    packet[p] = MESSAGE.USERAUTH_PK_OK;\n    writeUInt32BE(packet, keyAlgoLen, ++p);\n    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);\n    writeUInt32BE(packet, keyLen, p += keyAlgoLen);\n    packet.set(key, p += 4);\n    this._authsQueue.shift();\n    this._debug && this._debug('Outbound: Sending USERAUTH_PK_OK');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authPasswdChg(prompt) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    const promptLen = Buffer.byteLength(prompt);\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);\n    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n    writeUInt32BE(packet, promptLen, ++p);\n    packet.utf8Write(prompt, p += 4, promptLen);\n    writeUInt32BE(packet, 0, p += promptLen); // Empty language tag\n\n    this._debug && this._debug('Outbound: Sending USERAUTH_PASSWD_CHANGEREQ');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n  authInfoReq(name, instructions, prompts) {\n    if (!this._server) throw new Error('Server-only method called in client mode');\n    let promptsLen = 0;\n    const nameLen = name ? Buffer.byteLength(name) : 0;\n    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n    for (let i = 0; i < prompts.length; ++i) promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n    let p = this._packetRW.write.allocStart;\n    const packet = this._packetRW.write.alloc(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);\n    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;\n    writeUInt32BE(packet, nameLen, ++p);\n    p += 4;\n    if (name) {\n      packet.utf8Write(name, p, nameLen);\n      p += nameLen;\n    }\n    writeUInt32BE(packet, instrLen, p);\n    p += 4;\n    if (instructions) {\n      packet.utf8Write(instructions, p, instrLen);\n      p += instrLen;\n    }\n    writeUInt32BE(packet, 0, p);\n    writeUInt32BE(packet, prompts.length, p += 4);\n    p += 4;\n    for (let i = 0; i < prompts.length; ++i) {\n      const prompt = prompts[i];\n      const promptLen = Buffer.byteLength(prompt.prompt);\n      writeUInt32BE(packet, promptLen, p);\n      p += 4;\n      if (promptLen) {\n        packet.utf8Write(prompt.prompt, p, promptLen);\n        p += promptLen;\n      }\n      packet[p++] = prompt.echo ? 1 : 0;\n    }\n    this._debug && this._debug('Outbound: Sending USERAUTH_INFO_REQUEST');\n    sendPacket(this, this._packetRW.write.finalize(packet));\n  }\n}\n\n// SSH-protoversion-softwareversion (SP comments) CR LF\nconst RE_IDENT = /^SSH-(2\\.0|1\\.99)-([^ ]+)(?: (.*))?$/;\n\n// TODO: optimize this by starting n bytes from the end of this._buffer instead\n// of the beginning\nfunction parseHeader(chunk, p, len) {\n  let data;\n  let chunkOffset;\n  if (this._buffer) {\n    data = Buffer.allocUnsafe(this._buffer.length + (len - p));\n    data.set(this._buffer, 0);\n    if (p === 0) {\n      data.set(chunk, this._buffer.length);\n    } else {\n      data.set(new Uint8Array(chunk.buffer, chunk.byteOffset + p, len - p), this._buffer.length);\n    }\n    chunkOffset = this._buffer.length;\n    p = 0;\n  } else {\n    data = chunk;\n    chunkOffset = 0;\n  }\n  const op = p;\n  let start = p;\n  let end = p;\n  let needNL = false;\n  let lineLen = 0;\n  let lines = 0;\n  for (; p < data.length; ++p) {\n    const ch = data[p];\n    if (ch === 13 /* '\\r' */) {\n      needNL = true;\n      continue;\n    }\n    if (ch === 10 /* '\\n' */) {\n      if (end > start && end - start > 4 && data[start] === 83 /* 'S' */ && data[start + 1] === 83 /* 'S' */ && data[start + 2] === 72 /* 'H' */ && data[start + 3] === 45 /* '-' */) {\n        const full = data.latin1Slice(op, end + 1);\n        const identRaw = start === op ? full : full.slice(start - op);\n        const m = RE_IDENT.exec(identRaw);\n        if (!m) throw new Error('Invalid identification string');\n        const header = {\n          greeting: start === op ? '' : full.slice(0, start - op),\n          identRaw,\n          versions: {\n            protocol: m[1],\n            software: m[2]\n          },\n          comments: m[3]\n        };\n\n        // Needed during handshake\n        this._remoteIdentRaw = Buffer.from(identRaw);\n        this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`);\n        this._compatFlags = getCompatFlags(header);\n        this._buffer = undefined;\n        this._decipher = new NullDecipher(0, onKEXPayload.bind(this, {\n          firstPacket: true\n        }));\n        this._parse = parsePacket;\n        this._onHeader(header);\n        if (!this._destruct) {\n          // We disconnected inside _onHeader\n          return len;\n        }\n        kexinit(this);\n        return p + 1 - chunkOffset;\n      }\n\n      // Only allow pre-ident greetings when we're a client\n      if (this._server) throw new Error('Greetings from clients not permitted');\n      if (++lines > MAX_LINES) throw new Error('Max greeting lines exceeded');\n      needNL = false;\n      start = p + 1;\n      lineLen = 0;\n    } else if (needNL) {\n      throw new Error('Invalid header: expected newline');\n    } else if (++lineLen >= MAX_LINE_LEN) {\n      throw new Error('Header line too long');\n    }\n    end = p;\n  }\n  if (!this._buffer) this._buffer = bufferSlice(data, op);\n  return p - chunkOffset;\n}\nfunction parsePacket(chunk, p, len) {\n  return this._decipher.decrypt(chunk, p, len);\n}\nfunction onPayload(payload) {\n  // XXX: move this to the Decipher implementations?\n\n  this._onPacket();\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n  if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {\n    this._authenticated = true;\n    if (this._kex.negotiated.cs.compress === 'zlib@openssh.com') this._packetRW.write = new ZlibPacketWriter(this);\n    if (this._kex.negotiated.sc.compress === 'zlib@openssh.com') this._packetRW.read = new ZlibPacketReader();\n  }\n  const handler = MESSAGE_HANDLERS[type];\n  if (handler === undefined) {\n    this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);\n    return;\n  }\n  return handler(this, payload);\n}\nfunction getCompatFlags(header) {\n  const software = header.versions.software;\n  let flags = 0;\n  for (const rule of COMPAT_CHECKS) {\n    if (typeof rule[0] === 'string') {\n      if (software === rule[0]) flags |= rule[1];\n    } else if (rule[0].test(software)) {\n      flags |= rule[1];\n    }\n  }\n  return flags;\n}\nfunction modesToBytes(modes) {\n  const keys = Object.keys(modes);\n  const bytes = Buffer.allocUnsafe(5 * keys.length + 1);\n  let b = 0;\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === 'TTY_OP_END') continue;\n    const opcode = TERMINAL_MODE[key];\n    if (opcode === undefined) continue;\n    const val = modes[key];\n    if (typeof val === 'number' && isFinite(val)) {\n      bytes[b++] = opcode;\n      bytes[b++] = val >>> 24;\n      bytes[b++] = val >>> 16;\n      bytes[b++] = val >>> 8;\n      bytes[b++] = val;\n    }\n  }\n  bytes[b++] = TERMINAL_MODE.TTY_OP_END;\n  if (b < bytes.length) return bufferSlice(bytes, 0, b);\n  return bytes;\n}\nfunction sendExtInfo(proto) {\n  let serverSigAlgs = 'ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521' + 'rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss';\n  if (eddsaSupported) serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;\n  const algsLen = Buffer.byteLength(serverSigAlgs);\n  let p = proto._packetRW.write.allocStart;\n  const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);\n  packet[p] = MESSAGE.EXT_INFO;\n  writeUInt32BE(packet, 1, ++p);\n  writeUInt32BE(packet, 15, p += 4);\n  packet.utf8Write('server-sig-algs', p += 4, 15);\n  writeUInt32BE(packet, algsLen, p += 15);\n  packet.utf8Write(serverSigAlgs, p += 4, algsLen);\n  proto._debug && proto._debug('Outbound: Sending EXT_INFO');\n  sendPacket(proto, proto._packetRW.write.finalize(packet));\n}\nmodule.exports = Protocol;","'use strict';\n\nconst EventEmitter = require('events');\nconst fs = require('fs');\nconst {\n  constants\n} = fs;\nconst {\n  Readable: ReadableStream,\n  Writable: WritableStream\n} = require('stream');\nconst {\n  inherits,\n  types: {\n    isDate\n  }\n} = require('util');\nconst FastBuffer = Buffer[Symbol.species];\nconst {\n  bufferCopy,\n  bufferSlice,\n  makeBufferParser,\n  writeUInt32BE\n} = require('./utils.js');\nconst ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n};\n\n// Large enough to store all possible attributes\nconst ATTRS_BUF = Buffer.alloc(28);\nconst STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nconst VALID_STATUS_CODES = new Map(Object.values(STATUS_CODE).map(n => [n, 1]));\nconst STATUS_CODE_STR = {\n  [STATUS_CODE.OK]: 'No error',\n  [STATUS_CODE.EOF]: 'End of file',\n  [STATUS_CODE.NO_SUCH_FILE]: 'No such file or directory',\n  [STATUS_CODE.PERMISSION_DENIED]: 'Permission denied',\n  [STATUS_CODE.FAILURE]: 'Failure',\n  [STATUS_CODE.BAD_MESSAGE]: 'Bad message',\n  [STATUS_CODE.NO_CONNECTION]: 'No connection',\n  [STATUS_CODE.CONNECTION_LOST]: 'Connection lost',\n  [STATUS_CODE.OP_UNSUPPORTED]: 'Operation unsupported'\n};\nconst REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nconst RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nconst OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nconst PKT_RW_OVERHEAD = 2 * 1024;\nconst MAX_REQID = 2 ** 32 - 1;\nconst CLIENT_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */, REQUEST.INIT, 0, 0, 0, 3 /* version */]);\nconst SERVER_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */, RESPONSE.VERSION, 0, 0, 0, 3 /* version */]);\nconst RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nconst OPENSSH_MAX_PKT_LEN = 256 * 1024;\nconst bufferParser = makeBufferParser();\nconst fakeStderr = {\n  readable: false,\n  writable: false,\n  push: data => {},\n  once: () => {},\n  on: () => {},\n  emit: () => {},\n  end: () => {}\n};\nfunction noop() {}\n\n// Emulates enough of `Channel` to be able to be used as a drop-in replacement\n// in order to process incoming data with as little overhead as possible\nclass SFTP extends EventEmitter {\n  constructor(client, chanInfo, cfg) {\n    super();\n    if (typeof cfg !== 'object' || !cfg) cfg = {};\n    const remoteIdentRaw = client._protocol._remoteIdentRaw;\n    this.server = !!cfg.server;\n    this._debug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);\n    this._version = -1;\n    this._extensions = {};\n    this._biOpt = cfg.biOpt;\n    this._pktLenBytes = 0;\n    this._pktLen = 0;\n    this._pktPos = 0;\n    this._pktType = 0;\n    this._pktData = undefined;\n    this._writeReqid = -1;\n    this._requests = {};\n    this._maxInPktLen = OPENSSH_MAX_PKT_LEN;\n    this._maxOutPktLen = 34000;\n    this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34000) - PKT_RW_OVERHEAD;\n    this.maxOpenHandles = undefined;\n\n    // Channel compatibility\n    this._client = client;\n    this._protocol = client._protocol;\n    this._callbacks = [];\n    this._hasX11 = false;\n    this._exit = {\n      code: undefined,\n      signal: undefined,\n      dump: undefined,\n      desc: undefined\n    };\n    this._waitWindow = false; // SSH-level backpressure\n    this._chunkcb = undefined;\n    this._buffer = [];\n    this.type = chanInfo.type;\n    this.subtype = undefined;\n    this.incoming = chanInfo.incoming;\n    this.outgoing = chanInfo.outgoing;\n    this.stderr = fakeStderr;\n    this.readable = true;\n  }\n\n  // This handles incoming data to parse\n  push(data) {\n    if (data === null) {\n      cleanupRequests(this);\n      if (!this.readable) return;\n      // No more incoming data from the remote side\n      this.readable = false;\n      this.emit('end');\n      return;\n    }\n    /*\n        uint32             length\n        byte               type\n        byte[length - 1]   data payload\n    */\n    let p = 0;\n    while (p < data.length) {\n      if (this._pktLenBytes < 4) {\n        let nb = Math.min(4 - this._pktLenBytes, data.length - p);\n        this._pktLenBytes += nb;\n        while (nb--) this._pktLen = (this._pktLen << 8) + data[p++];\n        if (this._pktLenBytes < 4) return;\n        if (this._pktLen === 0) return doFatalSFTPError(this, 'Invalid packet length');\n        if (this._pktLen > this._maxInPktLen) {\n          const max = this._maxInPktLen;\n          return doFatalSFTPError(this, `Packet length ${this._pktLen} exceeds max length of ${max}`);\n        }\n        if (p >= data.length) return;\n      }\n      if (this._pktPos < this._pktLen) {\n        const nb = Math.min(this._pktLen - this._pktPos, data.length - p);\n        if (p !== 0 || nb !== data.length) {\n          if (nb === this._pktLen) {\n            this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);\n          } else {\n            if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);\n            this._pkt.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._pktPos);\n          }\n        } else if (nb === this._pktLen) {\n          this._pkt = data;\n        } else {\n          if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);\n          this._pkt.set(data, this._pktPos);\n        }\n        p += nb;\n        this._pktPos += nb;\n        if (this._pktPos < this._pktLen) return;\n      }\n      const type = this._pkt[0];\n      const payload = this._pkt;\n\n      // Prepare for next packet\n      this._pktLen = 0;\n      this._pktLenBytes = 0;\n      this._pkt = undefined;\n      this._pktPos = 0;\n      const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];\n      if (!handler) return doFatalSFTPError(this, `Unknown packet type ${type}`);\n      if (this._version === -1) {\n        if (this.server) {\n          if (type !== REQUEST.INIT) return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);\n        } else if (type !== RESPONSE.VERSION) {\n          return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);\n        }\n      }\n      if (handler(this, payload) === false) return;\n    }\n  }\n  end() {\n    this.destroy();\n  }\n  destroy() {\n    if (this.outgoing.state === 'open' || this.outgoing.state === 'eof') {\n      this.outgoing.state = 'closing';\n      this._protocol.channelClose(this.outgoing.id);\n    }\n  }\n  _init() {\n    this._init = noop;\n    if (!this.server) sendOrBuffer(this, CLIENT_VERSION_BUFFER);\n  }\n\n  // ===========================================================================\n  // Client-specific ===========================================================\n  // ===========================================================================\n  createReadStream(path, options) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    return new ReadStream(this, path, options);\n  }\n  createWriteStream(path, options) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    return new WriteStream(this, path, options);\n  }\n  open(path, flags_, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n    const flags = typeof flags_ === 'number' ? flags_ : stringToFlags(flags_);\n    if (flags === null) throw new Error(`Unknown flags string: ${flags_}`);\n    let attrsFlags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'string' || typeof attrs === 'number') attrs = {\n      mode: attrs\n    };\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      attrsFlags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32        id\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPEN;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    writeUInt32BE(buf, attrsFlags, p += 4);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPEN`);\n  }\n  close(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.CLOSE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} CLOSE`);\n  }\n  read(handle, buf, off, len, position, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf)) throw new Error('buffer is not a Buffer');\n    if (off >= buf.length) throw new Error('offset is out of bounds');\n    if (off + len > buf.length) throw new Error('length extends beyond buffer');\n    if (position === null) throw new Error('null position currently unsupported');\n    read_(this, handle, buf, off, len, position, cb);\n  }\n  readData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.read(handle, buf, off, len, position, cb);\n  }\n  write(handle, buf, off, len, position, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    if (!Buffer.isBuffer(buf)) throw new Error('buffer is not a Buffer');\n    if (off > buf.length) throw new Error('offset is out of bounds');\n    if (off + len > buf.length) throw new Error('length extends beyond buffer');\n    if (position === null) throw new Error('null position currently unsupported');\n    if (!len) {\n      cb && process.nextTick(cb, undefined, 0);\n      return;\n    }\n    const maxDataLen = this._maxWriteLen;\n    const overflow = Math.max(len - maxDataLen, 0);\n    const origPosition = position;\n    if (overflow) len = maxDataLen;\n\n    /*\n      uint32     id\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);\n    writeUInt32BE(out, out.length - 4, 0);\n    out[4] = REQUEST.WRITE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(out, reqid, 5);\n    writeUInt32BE(out, handleLen, p);\n    out.set(handle, p += 4);\n    p += handleLen;\n    for (let i = 7; i >= 0; --i) {\n      out[p + i] = position & 0xFF;\n      position /= 256;\n    }\n    writeUInt32BE(out, len, p += 8);\n    bufferCopy(buf, out, off, off + len, p += 4);\n    this._requests[reqid] = {\n      cb: err => {\n        if (err) {\n          if (typeof cb === 'function') cb(err);\n        } else if (overflow) {\n          this.write(handle, buf, off + len, overflow, origPosition + len, cb);\n        } else if (typeof cb === 'function') {\n          cb(undefined, off + len);\n        }\n      }\n    };\n    const isSent = sendOrBuffer(this, out);\n    if (this._debug) {\n      const how = isSent ? 'Sent' : 'Buffered';\n      this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);\n    }\n  }\n  writeData(handle, buf, off, len, position, cb) {\n    // Backwards compatibility\n    this.write(handle, buf, off, len, position, cb);\n  }\n  fastGet(remotePath, localPath, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    fastXfer(this, fs, remotePath, localPath, opts, cb);\n  }\n  fastPut(localPath, remotePath, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    fastXfer(fs, this, localPath, remotePath, opts, cb);\n  }\n  readFile(path, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof options === 'string') options = {\n      encoding: options,\n      flag: 'r'\n    };else if (!options) options = {\n      encoding: null,\n      flag: 'r'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    const encoding = options.encoding;\n    if (encoding && !Buffer.isEncoding(encoding)) throw new Error(`Unknown encoding: ${encoding}`);\n\n    // First stat the file, so we know the size.\n    let size;\n    let buffer; // Single buffer with file data\n    let buffers; // List for when size is unknown\n    let pos = 0;\n    let handle;\n\n    // SFTPv3 does not support using -1 for read position, so we have to track\n    // read position manually\n    let bytesRead = 0;\n    const flag = options.flag || 'r';\n    const read = () => {\n      if (size === 0) {\n        buffer = Buffer.allocUnsafe(8192);\n        this.read(handle, buffer, 0, 8192, bytesRead, afterRead);\n      } else {\n        this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);\n      }\n    };\n    const afterRead = (er, nbytes) => {\n      let eof;\n      if (er) {\n        eof = er.code === STATUS_CODE.EOF;\n        if (!eof) {\n          return this.close(handle, () => {\n            return callback && callback(er);\n          });\n        }\n      } else {\n        eof = false;\n      }\n      if (eof || size === 0 && nbytes === 0) return close();\n      bytesRead += nbytes;\n      pos += nbytes;\n      if (size !== 0) {\n        if (pos === size) close();else read();\n      } else {\n        // Unknown size, just read until we don't get bytes.\n        buffers.push(bufferSlice(buffer, 0, nbytes));\n        read();\n      }\n    };\n    afterRead._wantEOFError = true;\n    const close = () => {\n      this.close(handle, er => {\n        if (size === 0) {\n          // Collect the data into the buffers list.\n          buffer = Buffer.concat(buffers, pos);\n        } else if (pos < size) {\n          buffer = bufferSlice(buffer, 0, pos);\n        }\n        if (encoding) buffer = buffer.toString(encoding);\n        return callback && callback(er, buffer);\n      });\n    };\n    this.open(path, flag, 0o666, (er, handle_) => {\n      if (er) return callback && callback(er);\n      handle = handle_;\n      const tryStat = (er, st) => {\n        if (er) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          this.stat(path, (er_, st_) => {\n            if (er_) {\n              return this.close(handle, () => {\n                callback && callback(er);\n              });\n            }\n            tryStat(null, st_);\n          });\n          return;\n        }\n        size = st.size || 0;\n        if (size === 0) {\n          // The kernel lies about many files.\n          // Go ahead and try to read some bytes.\n          buffers = [];\n          return read();\n        }\n        buffer = Buffer.allocUnsafe(size);\n        read();\n      };\n      this.fstat(handle, tryStat);\n    });\n  }\n  writeFile(path, data, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof options === 'string') options = {\n      encoding: options,\n      mode: 0o666,\n      flag: 'w'\n    };else if (!options) options = {\n      encoding: 'utf8',\n      mode: 0o666,\n      flag: 'w'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    if (options.encoding && !Buffer.isEncoding(options.encoding)) throw new Error(`Unknown encoding: ${options.encoding}`);\n    const flag = options.flag || 'w';\n    this.open(path, flag, options.mode, (openErr, handle) => {\n      if (openErr) {\n        callback && callback(openErr);\n      } else {\n        const buffer = Buffer.isBuffer(data) ? data : Buffer.from('' + data, options.encoding || 'utf8');\n        const position = /a/.test(flag) ? null : 0;\n\n        // SFTPv3 does not support the notion of 'current position'\n        // (null position), so we just attempt to append to the end of the file\n        // instead\n        if (position === null) {\n          const tryStat = (er, st) => {\n            if (er) {\n              // Try stat() for sftp servers that may not support fstat() for\n              // whatever reason\n              this.stat(path, (er_, st_) => {\n                if (er_) {\n                  return this.close(handle, () => {\n                    callback && callback(er);\n                  });\n                }\n                tryStat(null, st_);\n              });\n              return;\n            }\n            writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);\n          };\n          this.fstat(handle, tryStat);\n          return;\n        }\n        writeAll(this, handle, buffer, 0, buffer.length, position, callback);\n      }\n    });\n  }\n  appendFile(path, data, options, callback_) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let callback;\n    if (typeof callback_ === 'function') {\n      callback = callback_;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof options === 'string') options = {\n      encoding: options,\n      mode: 0o666,\n      flag: 'a'\n    };else if (!options) options = {\n      encoding: 'utf8',\n      mode: 0o666,\n      flag: 'a'\n    };else if (typeof options !== 'object') throw new TypeError('Bad arguments');\n    if (!options.flag) options = Object.assign({\n      flag: 'a'\n    }, options);\n    this.writeFile(path, data, options, callback);\n  }\n  exists(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    this.stat(path, err => {\n      cb && cb(err ? false : true);\n    });\n  }\n  unlink(filename, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     filename\n    */\n    const fnameLen = Buffer.byteLength(filename);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REMOVE;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, fnameLen, p);\n    buf.utf8Write(filename, p += 4, fnameLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REMOVE`);\n  }\n  rename(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     oldpath\n      string     newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RENAME;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, oldLen, p);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RENAME`);\n  }\n  mkdir(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'function') {\n      cb = attrs;\n      attrs = undefined;\n    }\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.MKDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} MKDIR`);\n  }\n  rmdir(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.RMDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} RMDIR`);\n  }\n  readdir(where, opts, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n    if (typeof opts !== 'object' || opts === null) opts = {};\n    const doFilter = opts && opts.full ? false : true;\n    if (!Buffer.isBuffer(where) && typeof where !== 'string') throw new Error('missing directory handle or path');\n    if (typeof where === 'string') {\n      const entries = [];\n      let e = 0;\n      const reread = (err, handle) => {\n        if (err) return cb(err);\n        this.readdir(handle, opts, (err, list) => {\n          const eof = err && err.code === STATUS_CODE.EOF;\n          if (err && !eof) return this.close(handle, () => cb(err));\n          if (eof) {\n            return this.close(handle, err => {\n              if (err) return cb(err);\n              cb(undefined, entries);\n            });\n          }\n          for (let i = 0; i < list.length; ++i, ++e) entries[e] = list[i];\n          reread(undefined, handle);\n        });\n      };\n      return this.opendir(where, reread);\n    }\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = where.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(where, p += 4);\n    this._requests[reqid] = {\n      cb: doFilter ? (err, list) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        for (let i = list.length - 1; i >= 0; --i) {\n          if (list[i].filename === '.' || list[i].filename === '..') list.splice(i, 1);\n        }\n        cb(undefined, list);\n      } : cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READDIR`);\n  }\n  fstat(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32     id\n      string     handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSTAT`);\n  }\n  stat(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.STAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STAT`);\n  }\n  lstat(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.LSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} LSTAT`);\n  }\n  opendir(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.OPENDIR;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} OPENDIR`);\n  }\n  setstat(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     path\n      ATTRS      attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SETSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SETSTAT`);\n  }\n  fsetstat(handle, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32     id\n      string     handle\n      ATTRS      attrs\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.FSETSTAT;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    buf.set(handle, p += 4);\n    writeUInt32BE(buf, flags, p += handleLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} FSETSTAT`);\n  }\n  futimes(handle, atime, mtime, cb) {\n    return this.fsetstat(handle, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  utimes(path, atime, mtime, cb) {\n    return this.setstat(path, {\n      atime: toUnixTimestamp(atime),\n      mtime: toUnixTimestamp(mtime)\n    }, cb);\n  }\n  fchown(handle, uid, gid, cb) {\n    return this.fsetstat(handle, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  chown(path, uid, gid, cb) {\n    return this.setstat(path, {\n      uid: uid,\n      gid: gid\n    }, cb);\n  }\n  fchmod(handle, mode, cb) {\n    return this.fsetstat(handle, {\n      mode: mode\n    }, cb);\n  }\n  chmod(path, mode, cb) {\n    return this.setstat(path, {\n      mode: mode\n    }, cb);\n  }\n  readlink(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.READLINK;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing link info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READLINK`);\n  }\n  symlink(targetPath, linkPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     linkpath\n      string     targetpath\n    */\n    const linkLen = Buffer.byteLength(linkPath);\n    const targetLen = Buffer.byteLength(targetPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.SYMLINK;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    if (this._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      writeUInt32BE(buf, targetLen, p);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n      writeUInt32BE(buf, linkLen, p += targetLen);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n    } else {\n      writeUInt32BE(buf, linkLen, p);\n      buf.utf8Write(linkPath, p += 4, linkLen);\n      writeUInt32BE(buf, targetLen, p += linkLen);\n      buf.utf8Write(targetPath, p += 4, targetLen);\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} SYMLINK`);\n  }\n  realpath(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n\n    /*\n      uint32     id\n      string     path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.REALPATH;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, pathLen, p);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing path info'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} REALPATH`);\n  }\n  // extended requests\n  ext_openssh_rename(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['posix-rename@openssh.com'];\n    if (!ext || ext !== '1') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"posix-rename@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 24, p);\n    buf.utf8Write('posix-rename@openssh.com', p += 4, 24);\n    writeUInt32BE(buf, oldLen, p += 24);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);\n    }\n  }\n  ext_openssh_statvfs(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['statvfs@openssh.com'];\n    if (!ext || ext !== '2') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"statvfs@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 19, p);\n    buf.utf8Write('statvfs@openssh.com', p += 4, 19);\n    writeUInt32BE(buf, pathLen, p += 19);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      extended: 'statvfs@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);\n    }\n  }\n  ext_openssh_fstatvfs(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['fstatvfs@openssh.com'];\n    if (!ext || ext !== '2') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fstatvfs@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('fstatvfs@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, handleLen, p += 20);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      extended: 'fstatvfs@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);\n    }\n  }\n  ext_openssh_hardlink(oldPath, newPath, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['hardlink@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"hardlink@openssh.com\"\n      string    oldpath\n      string    newpath\n    */\n    const oldLen = Buffer.byteLength(oldPath);\n    const newLen = Buffer.byteLength(newPath);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('hardlink@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, oldLen, p += 20);\n    buf.utf8Write(oldPath, p += 4, oldLen);\n    writeUInt32BE(buf, newLen, p += oldLen);\n    buf.utf8Write(newPath, p += 4, newLen);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const which = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);\n    }\n  }\n  ext_openssh_fsync(handle, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['fsync@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"fsync@openssh.com\"\n      string    handle\n    */\n    const handleLen = handle.length;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 17, p);\n    buf.utf8Write('fsync@openssh.com', p += 4, 17);\n    writeUInt32BE(buf, handleLen, p += 17);\n    buf.set(handle, p += 4);\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} fsync@openssh.com`);\n  }\n  ext_openssh_lsetstat(path, attrs, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['lsetstat@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    let flags = 0;\n    let attrsLen = 0;\n    if (typeof attrs === 'object' && attrs !== null) {\n      attrs = attrsToBytes(attrs);\n      flags = attrs.flags;\n      attrsLen = attrs.nb;\n    } else if (typeof attrs === 'function') {\n      cb = attrs;\n    }\n\n    /*\n      uint32    id\n      string    \"lsetstat@openssh.com\"\n      string    path\n      ATTRS     attrs\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 20, p);\n    buf.utf8Write('lsetstat@openssh.com', p += 4, 20);\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n    writeUInt32BE(buf, flags, p += pathLen);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);\n    }\n  }\n  ext_openssh_expandPath(path, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['expand-path@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n\n    /*\n      uint32    id\n      string    \"expand-path@openssh.com\"\n      string    path\n    */\n    const pathLen = Buffer.byteLength(path);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = REQUEST.EXTENDED;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, 23, p);\n    buf.utf8Write('expand-path@openssh.com', p += 4, 23);\n    writeUInt32BE(buf, pathLen, p += 20);\n    buf.utf8Write(path, p += 4, pathLen);\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing expanded path'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);\n    }\n  }\n  ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['copy-data'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Buffer.isBuffer(srcHandle)) throw new Error('Source handle is not a Buffer');\n    if (!Buffer.isBuffer(dstHandle)) throw new Error('Destination handle is not a Buffer');\n\n    /*\n      uint32    id\n      string    \"copy-data\"\n      string    read-from-handle\n      uint64    read-from-offset\n      uint64    read-data-length\n      string    write-to-handle\n      uint64    write-to-offset\n    */\n    let p = 0;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8);\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n    writeUInt32BE(buf, 9, p);\n    p += 4;\n    buf.utf8Write('copy-data', p, 9);\n    p += 9;\n    writeUInt32BE(buf, srcHandle.length, p);\n    p += 4;\n    buf.set(srcHandle, p);\n    p += srcHandle.length;\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = srcOffset & 0xFF;\n      srcOffset /= 256;\n    }\n    p += 8;\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = len & 0xFF;\n      len /= 256;\n    }\n    p += 8;\n    writeUInt32BE(buf, dstHandle.length, p);\n    p += 4;\n    buf.set(dstHandle, p);\n    p += dstHandle.length;\n    for (let i = 7; i >= 0; --i) {\n      buf[p + i] = dstOffset & 0xFF;\n      dstOffset /= 256;\n    }\n    this._requests[reqid] = {\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} copy-data`);\n    }\n  }\n  ext_home_dir(username, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['home-directory'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (typeof username !== 'string') throw new TypeError('username is not a string');\n\n    /*\n      uint32    id\n      string    \"home-directory\"\n      string    username\n    */\n    let p = 0;\n    const usernameLen = Buffer.byteLength(username);\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 14 + 4 + usernameLen);\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n    writeUInt32BE(buf, 14, p);\n    p += 4;\n    buf.utf8Write('home-directory', p, 14);\n    p += 14;\n    writeUInt32BE(buf, usernameLen, p);\n    p += 4;\n    buf.utf8Write(username, p, usernameLen);\n    p += usernameLen;\n    this._requests[reqid] = {\n      cb: (err, names) => {\n        if (typeof cb !== 'function') return;\n        if (err) return cb(err);\n        if (!names || !names.length) return cb(new Error('Response missing home directory'));\n        cb(undefined, names[0].filename);\n      }\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} home-directory`);\n    }\n  }\n  ext_users_groups(uids, gids, cb) {\n    if (this.server) throw new Error('Client-only method called in server mode');\n    const ext = this._extensions['users-groups-by-id@openssh.com'];\n    if (ext !== '1') throw new Error('Server does not support this extended request');\n    if (!Array.isArray(uids)) throw new TypeError('uids is not an array');\n    for (const val of uids) {\n      if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1) throw new Error('uid values must all be 32-bit unsigned integers');\n    }\n    if (!Array.isArray(gids)) throw new TypeError('gids is not an array');\n    for (const val of gids) {\n      if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1) throw new Error('gid values must all be 32-bit unsigned integers');\n    }\n\n    /*\n      uint32    id\n      string    \"users-groups-by-id@openssh.com\"\n      string    uids\n        uint32    uid1\n        ...\n      string    gids\n        uint32    gid1\n        ...\n    */\n    let p = 0;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 30 + 4 + 4 * uids.length + 4 + 4 * gids.length);\n    writeUInt32BE(buf, buf.length - 4, p);\n    p += 4;\n    buf[p] = REQUEST.EXTENDED;\n    ++p;\n    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;\n    writeUInt32BE(buf, reqid, p);\n    p += 4;\n    writeUInt32BE(buf, 30, p);\n    p += 4;\n    buf.utf8Write('users-groups-by-id@openssh.com', p, 30);\n    p += 30;\n    writeUInt32BE(buf, 4 * uids.length, p);\n    p += 4;\n    for (const val of uids) {\n      writeUInt32BE(buf, val, p);\n      p += 4;\n    }\n    writeUInt32BE(buf, 4 * gids.length, p);\n    p += 4;\n    for (const val of gids) {\n      writeUInt32BE(buf, val, p);\n      p += 4;\n    }\n    this._requests[reqid] = {\n      extended: 'users-groups-by-id@openssh.com',\n      cb\n    };\n    const isBuffered = sendOrBuffer(this, buf);\n    if (this._debug) {\n      const status = isBuffered ? 'Buffered' : 'Sending';\n      this._debug(`SFTP: Outbound: ${status} users-groups-by-id@openssh.com`);\n    }\n  }\n  // ===========================================================================\n  // Server-specific ===========================================================\n  // ===========================================================================\n  handle(reqid, handle) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!Buffer.isBuffer(handle)) throw new Error('handle is not a Buffer');\n    const handleLen = handle.length;\n    if (handleLen > 256) throw new Error('handle too large (> 256 bytes)');\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.HANDLE;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, handleLen, p);\n    if (handleLen) buf.set(handle, p += 4);\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} HANDLE`);\n  }\n  status(reqid, code, message) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!VALID_STATUS_CODES.has(code)) throw new Error(`Bad status code: ${code}`);\n    message || (message = '');\n    const msgLen = Buffer.byteLength(message);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.STATUS;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, code, p);\n    writeUInt32BE(buf, msgLen, p += 4);\n    p += 4;\n    if (msgLen) {\n      buf.utf8Write(message, p, msgLen);\n      p += msgLen;\n    }\n    writeUInt32BE(buf, 0, p); // Empty language tag\n\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} STATUS`);\n  }\n  data(reqid, data, encoding) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    const isBuffer = Buffer.isBuffer(data);\n    if (!isBuffer && typeof data !== 'string') throw new Error('data is not a Buffer or string');\n    let isUTF8;\n    if (!isBuffer && !encoding) {\n      encoding = undefined;\n      isUTF8 = true;\n    }\n    const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.DATA;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, dataLen, p);\n    if (dataLen) {\n      if (isBuffer) buf.set(data, p += 4);else if (isUTF8) buf.utf8Write(data, p += 4, dataLen);else buf.write(data, p += 4, dataLen, encoding);\n    }\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} DATA`);\n  }\n  name(reqid, names) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (!Array.isArray(names)) {\n      if (typeof names !== 'object' || names === null) throw new Error('names is not an object or array');\n      names = [names];\n    }\n    const count = names.length;\n    let namesLen = 0;\n    let nameAttrs;\n    const attrs = [];\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      const filename = !name || !name.filename || typeof name.filename !== 'string' ? '' : name.filename;\n      namesLen += 4 + Buffer.byteLength(filename);\n      const longname = !name || !name.longname || typeof name.longname !== 'string' ? '' : name.longname;\n      namesLen += 4 + Buffer.byteLength(longname);\n      if (typeof name.attrs === 'object' && name.attrs !== null) {\n        nameAttrs = attrsToBytes(name.attrs);\n        namesLen += 4 + nameAttrs.nb;\n        if (nameAttrs.nb) {\n          let bytes;\n          if (nameAttrs.nb === ATTRS_BUF.length) {\n            bytes = new Uint8Array(ATTRS_BUF);\n          } else {\n            bytes = new Uint8Array(nameAttrs.nb);\n            bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);\n          }\n          nameAttrs.bytes = bytes;\n        }\n        attrs.push(nameAttrs);\n      } else {\n        namesLen += 4;\n        attrs.push(null);\n      }\n    }\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.NAME;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, count, p);\n    p += 4;\n    for (let i = 0; i < count; ++i) {\n      const name = names[i];\n      {\n        const filename = !name || !name.filename || typeof name.filename !== 'string' ? '' : name.filename;\n        const len = Buffer.byteLength(filename);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(filename, p, len);\n          p += len;\n        }\n      }\n      {\n        const longname = !name || !name.longname || typeof name.longname !== 'string' ? '' : name.longname;\n        const len = Buffer.byteLength(longname);\n        writeUInt32BE(buf, len, p);\n        p += 4;\n        if (len) {\n          buf.utf8Write(longname, p, len);\n          p += len;\n        }\n      }\n      const attr = attrs[i];\n      if (attr) {\n        writeUInt32BE(buf, attr.flags, p);\n        p += 4;\n        if (attr.flags && attr.bytes) {\n          buf.set(attr.bytes, p);\n          p += attr.nb;\n        }\n      } else {\n        writeUInt32BE(buf, 0, p);\n        p += 4;\n      }\n    }\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} NAME`);\n  }\n  attrs(reqid, attrs) {\n    if (!this.server) throw new Error('Server-only method called in client mode');\n    if (typeof attrs !== 'object' || attrs === null) throw new Error('attrs is not an object');\n    attrs = attrsToBytes(attrs);\n    const flags = attrs.flags;\n    const attrsLen = attrs.nb;\n    let p = 9;\n    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);\n    writeUInt32BE(buf, buf.length - 4, 0);\n    buf[4] = RESPONSE.ATTRS;\n    writeUInt32BE(buf, reqid, 5);\n    writeUInt32BE(buf, flags, p);\n    if (attrsLen) {\n      p += 4;\n      if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);\n      p += attrsLen;\n    }\n    const isBuffered = sendOrBuffer(this, buf);\n    this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} ATTRS`);\n  }\n}\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\nfunction read_(self, handle, buf, off, len, position, cb, req_) {\n  const maxDataLen = self._maxReadLen;\n  const overflow = Math.max(len - maxDataLen, 0);\n  if (overflow) len = maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  const handleLen = handle.length;\n  let p = 9;\n  let pos = position;\n  const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  const reqid = self._writeReqid = self._writeReqid + 1 & MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n  writeUInt32BE(out, handleLen, p);\n  out.set(handle, p += 4);\n  p += handleLen;\n  for (let i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n  if (typeof cb !== 'function') cb = noop;\n  const req = req_ || {\n    nb: 0,\n    position,\n    off,\n    origOff: off,\n    len: undefined,\n    overflow: undefined,\n    cb: (err, data, nb) => {\n      const len = req.len;\n      const overflow = req.overflow;\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF) return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      } else if (nb === len && overflow) {\n        req.nb += nb;\n        req.position += nb;\n        req.off += nb;\n        read_(self, handle, buf, req.off, overflow, req.position, cb, req);\n        return;\n      }\n      nb = nb || 0;\n      if (req.origOff === 0 && buf.length === req.nb) data = buf;else data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);\n      cb(undefined, req.nb + nb, data, req.position);\n    },\n    buffer: undefined\n  };\n  req.len = len;\n  req.overflow = overflow;\n\n  // TODO: avoid creating multiple buffer slices when we need to re-call read_()\n  // because of overflow\n  req.buffer = bufferSlice(buf, off, off + len);\n  self._requests[reqid] = req;\n  const isBuffered = sendOrBuffer(self, out);\n  self._debug && self._debug(`SFTP: Outbound: ${isBuffered ? 'Buffered' : 'Sending'} READ`);\n}\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  let concurrency = 64;\n  let chunkSize = 32768;\n  let onstep;\n  let mode;\n  let fileSize;\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number' && opts.concurrency > 0 && !isNaN(opts.concurrency)) {\n      concurrency = opts.concurrency;\n    }\n    if (typeof opts.chunkSize === 'number' && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {\n      chunkSize = opts.chunkSize;\n    }\n    if (typeof opts.fileSize === 'number' && opts.fileSize > 0 && !isNaN(opts.fileSize)) {\n      fileSize = opts.fileSize;\n    }\n    if (typeof opts.step === 'function') onstep = opts.step;\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number') mode = modeNum(opts.mode);\n  }\n\n  // Internal state variables\n  let fsize;\n  let pdst = 0;\n  let total = 0;\n  let hadError = false;\n  let srcHandle;\n  let dstHandle;\n  let readbuf;\n  let bufsize = chunkSize * concurrency;\n  function onerror(err) {\n    if (hadError) return;\n    hadError = true;\n    let left = 0;\n    let cbfinal;\n    if (srcHandle || dstHandle) {\n      cbfinal = () => {\n        if (--left === 0) cb(err);\n      };\n      if (srcHandle && (src === fs || src.outgoing.state === 'open')) ++left;\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open')) ++left;\n      if (srcHandle && (src === fs || src.outgoing.state === 'open')) src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.outgoing.state === 'open')) dst.close(dstHandle, cbfinal);\n    } else {\n      cb(err);\n    }\n  }\n  src.open(srcPath, 'r', (err, sourceHandle) => {\n    if (err) return onerror(err);\n    srcHandle = sourceHandle;\n    if (fileSize === undefined) src.fstat(srcHandle, tryStat);else tryStat(null, {\n      size: fileSize\n    });\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, (err_, attrs_) => {\n            if (err_) return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n      dst.open(dstPath, 'w', (err, destHandle) => {\n        if (err) return onerror(err);\n        dstHandle = destHandle;\n        if (fsize <= 0) return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error) return onerror(readbuf);\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod()\n              // for whatever reason\n              dst.chmod(dstPath, mode, err_ => tryAgain());\n              return;\n            }\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err) return onerror(err);\n          datapos = datapos || 0;\n          dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n          function writeCb(err) {\n            if (err) return onerror(err);\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n            if (nb < origChunkLen) return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n            if (total === fsize) {\n              dst.close(dstHandle, err => {\n                dstHandle = undefined;\n                if (err) return onerror(err);\n                src.close(srcHandle, err => {\n                  srcHandle = undefined;\n                  if (err) return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n            if (pdst >= fsize) return;\n            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n        function makeCb(psrc, pdst, chunk) {\n          return (err, nb, data) => {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n        function singleRead(psrc, pdst, chunk) {\n          src.read(srcHandle, readbuf, psrc, chunk, pdst, makeCb(psrc, pdst, chunk));\n        }\n        function startReads() {\n          let reads = 0;\n          let psrc = 0;\n          while (pdst < fsize && reads < concurrency) {\n            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\nfunction writeAll(sftp, handle, buffer, offset, length, position, callback_) {\n  const callback = typeof callback_ === 'function' ? callback_ : undefined;\n  sftp.write(handle, buffer, offset, length, position, (writeErr, written) => {\n    if (writeErr) {\n      return sftp.close(handle, () => {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length) {\n      sftp.close(handle, callback);\n    } else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(sftp, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\nclass Stats {\n  constructor(initial) {\n    this.mode = initial && initial.mode;\n    this.uid = initial && initial.uid;\n    this.gid = initial && initial.gid;\n    this.size = initial && initial.size;\n    this.atime = initial && initial.atime;\n    this.mtime = initial && initial.mtime;\n    this.extended = initial && initial.extended;\n  }\n  isDirectory() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFDIR;\n  }\n  isFile() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFREG;\n  }\n  isBlockDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFBLK;\n  }\n  isCharacterDevice() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFCHR;\n  }\n  isSymbolicLink() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFLNK;\n  }\n  isFIFO() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFIFO;\n  }\n  isSocket() {\n    return (this.mode & constants.S_IFMT) === constants.S_IFSOCK;\n  }\n}\nfunction attrsToBytes(attrs) {\n  let flags = 0;\n  let nb = 0;\n  if (typeof attrs === 'object' && attrs !== null) {\n    if (typeof attrs.size === 'number') {\n      flags |= ATTR.SIZE;\n      const val = attrs.size;\n      // Big Endian\n      ATTRS_BUF[nb++] = val / 72057594037927940; // 2**56\n      ATTRS_BUF[nb++] = val / 281474976710656; // 2**48\n      ATTRS_BUF[nb++] = val / 1099511627776; // 2**40\n      ATTRS_BUF[nb++] = val / 4294967296; // 2**32\n      ATTRS_BUF[nb++] = val / 16777216; // 2**24\n      ATTRS_BUF[nb++] = val / 65536; // 2**16\n      ATTRS_BUF[nb++] = val / 256; // 2**8\n      ATTRS_BUF[nb++] = val;\n    }\n    if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n      flags |= ATTR.UIDGID;\n      const uid = attrs.uid;\n      const gid = attrs.gid;\n      // Big Endian\n      ATTRS_BUF[nb++] = uid >>> 24;\n      ATTRS_BUF[nb++] = uid >>> 16;\n      ATTRS_BUF[nb++] = uid >>> 8;\n      ATTRS_BUF[nb++] = uid;\n      ATTRS_BUF[nb++] = gid >>> 24;\n      ATTRS_BUF[nb++] = gid >>> 16;\n      ATTRS_BUF[nb++] = gid >>> 8;\n      ATTRS_BUF[nb++] = gid;\n    }\n    if (typeof attrs.mode === 'number' || typeof attrs.mode === 'string') {\n      const mode = modeNum(attrs.mode);\n      flags |= ATTR.PERMISSIONS;\n      // Big Endian\n      ATTRS_BUF[nb++] = mode >>> 24;\n      ATTRS_BUF[nb++] = mode >>> 16;\n      ATTRS_BUF[nb++] = mode >>> 8;\n      ATTRS_BUF[nb++] = mode;\n    }\n    if ((typeof attrs.atime === 'number' || isDate(attrs.atime)) && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n      const atime = toUnixTimestamp(attrs.atime);\n      const mtime = toUnixTimestamp(attrs.mtime);\n      flags |= ATTR.ACMODTIME;\n      // Big Endian\n      ATTRS_BUF[nb++] = atime >>> 24;\n      ATTRS_BUF[nb++] = atime >>> 16;\n      ATTRS_BUF[nb++] = atime >>> 8;\n      ATTRS_BUF[nb++] = atime;\n      ATTRS_BUF[nb++] = mtime >>> 24;\n      ATTRS_BUF[nb++] = mtime >>> 16;\n      ATTRS_BUF[nb++] = mtime >>> 8;\n      ATTRS_BUF[nb++] = mtime;\n    }\n    // TODO: extended attributes\n  }\n  return {\n    flags,\n    nb\n  };\n}\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof time === 'number' && time === time)\n    // Valid, non-NaN number\n    return time;\n  if (isDate(time)) return parseInt(time.getTime() / 1000, 10);\n  throw new Error(`Cannot parse time: ${time}`);\n}\nfunction modeNum(mode) {\n  // eslint-disable-next-line no-self-compare\n  if (typeof mode === 'number' && mode === mode)\n    // Valid, non-NaN number\n    return mode;\n  if (typeof mode === 'string') return modeNum(parseInt(mode, 8));\n  throw new Error(`Cannot parse mode: ${mode}`);\n}\nconst stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL\n};\nfunction stringToFlags(str) {\n  const flags = stringFlagMap[str];\n  return flags !== undefined ? flags : null;\n}\nconst flagsToString = (() => {\n  const stringFlagMapKeys = Object.keys(stringFlagMap);\n  return flags => {\n    for (let i = 0; i < stringFlagMapKeys.length; ++i) {\n      const key = stringFlagMapKeys[i];\n      if (stringFlagMap[key] === flags) return key;\n    }\n    return null;\n  };\n})();\nfunction readAttrs(biOpt) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  const flags = bufferParser.readUInt32BE();\n  if (flags === undefined) return;\n  const attrs = new Stats();\n  if (flags & ATTR.SIZE) {\n    const size = bufferParser.readUInt64BE(biOpt);\n    if (size === undefined) return;\n    attrs.size = size;\n  }\n  if (flags & ATTR.UIDGID) {\n    const uid = bufferParser.readUInt32BE();\n    const gid = bufferParser.readUInt32BE();\n    if (gid === undefined) return;\n    attrs.uid = uid;\n    attrs.gid = gid;\n  }\n  if (flags & ATTR.PERMISSIONS) {\n    const mode = bufferParser.readUInt32BE();\n    if (mode === undefined) return;\n    attrs.mode = mode;\n  }\n  if (flags & ATTR.ACMODTIME) {\n    const atime = bufferParser.readUInt32BE();\n    const mtime = bufferParser.readUInt32BE();\n    if (mtime === undefined) return;\n    attrs.atime = atime;\n    attrs.mtime = mtime;\n  }\n  if (flags & ATTR.EXTENDED) {\n    const count = bufferParser.readUInt32BE();\n    if (count === undefined) return;\n    const extended = {};\n    for (let i = 0; i < count; ++i) {\n      const type = bufferParser.readString(true);\n      const data = bufferParser.readString();\n      if (data === undefined) return;\n      extended[type] = data;\n    }\n    attrs.extended = extended;\n  }\n  return attrs;\n}\nfunction sendOrBuffer(sftp, payload) {\n  const ret = tryWritePayload(sftp, payload);\n  if (ret !== undefined) {\n    sftp._buffer.push(ret);\n    return false;\n  }\n  return true;\n}\nfunction tryWritePayload(sftp, payload) {\n  const outgoing = sftp.outgoing;\n  if (outgoing.state !== 'open') return;\n  if (outgoing.window === 0) {\n    sftp._waitWindow = true;\n    sftp._chunkcb = drainBuffer;\n    return payload;\n  }\n  let ret;\n  const len = payload.length;\n  let p = 0;\n  while (len - p > 0 && outgoing.window > 0) {\n    const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);\n    outgoing.window -= actualLen;\n    if (outgoing.window === 0) {\n      sftp._waitWindow = true;\n      sftp._chunkcb = drainBuffer;\n    }\n    if (p === 0 && actualLen === len) {\n      sftp._protocol.channelData(sftp.outgoing.id, payload);\n    } else {\n      sftp._protocol.channelData(sftp.outgoing.id, bufferSlice(payload, p, p + actualLen));\n    }\n    p += actualLen;\n  }\n  if (len - p > 0) {\n    if (p > 0) ret = bufferSlice(payload, p, len);else ret = payload; // XXX: should never get here?\n  }\n  return ret;\n}\nfunction drainBuffer() {\n  this._chunkcb = undefined;\n  const buffer = this._buffer;\n  let i = 0;\n  while (i < buffer.length) {\n    const payload = buffer[i];\n    const ret = tryWritePayload(this, payload);\n    if (ret !== undefined) {\n      if (ret !== payload) buffer[i] = ret;\n      if (i > 0) this._buffer = buffer.slice(i);\n      return;\n    }\n    ++i;\n  }\n  if (i > 0) this._buffer = [];\n}\nfunction doFatalSFTPError(sftp, msg, noDebug) {\n  const err = new Error(msg);\n  err.level = 'sftp-protocol';\n  if (!noDebug && sftp._debug) sftp._debug(`SFTP: Inbound: ${msg}`);\n  sftp.emit('error', err);\n  sftp.destroy();\n  cleanupRequests(sftp);\n  return false;\n}\nfunction cleanupRequests(sftp) {\n  const keys = Object.keys(sftp._requests);\n  if (keys.length === 0) return;\n  const reqs = sftp._requests;\n  sftp._requests = {};\n  const err = new Error('No response from server');\n  for (let i = 0; i < keys.length; ++i) {\n    const req = reqs[keys[i]];\n    if (typeof req.cb === 'function') req.cb(err);\n  }\n}\nfunction requestLimits(sftp, cb) {\n  /*\n    uint32    id\n    string    \"limits@openssh.com\"\n  */\n  let p = 9;\n  const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 18, p);\n  buf.utf8Write('limits@openssh.com', p += 4, 18);\n  sftp._requests[reqid] = {\n    extended: 'limits@openssh.com',\n    cb\n  };\n  const isBuffered = sendOrBuffer(sftp, buf);\n  if (sftp._debug) {\n    const which = isBuffered ? 'Buffered' : 'Sending';\n    sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);\n  }\n}\nconst CLIENT_HANDLERS = {\n  [RESPONSE.VERSION]: (sftp, payload) => {\n    if (sftp._version !== -1) return doFatalSFTPError(sftp, 'Duplicate VERSION packet');\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n    if (version === undefined) return doFatalSFTPError(sftp, 'Malformed VERSION packet');\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version}, exts:${names})`);\n      } else {\n        sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);\n      }\n    }\n    sftp._version = version;\n    sftp._extensions = extensions;\n    if (extensions['limits@openssh.com'] === '1') {\n      return requestLimits(sftp, (err, limits) => {\n        if (!err) {\n          if (limits.maxPktLen > 0) sftp._maxOutPktLen = limits.maxPktLen;\n          if (limits.maxReadLen > 0) sftp._maxReadLen = limits.maxReadLen;\n          if (limits.maxWriteLen > 0) sftp._maxWriteLen = limits.maxWriteLen;\n          sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;\n        }\n        sftp.emit('ready');\n      });\n    }\n    sftp.emit('ready');\n  },\n  [RESPONSE.STATUS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      uint32     error/status code\n      string     error message (ISO-10646 UTF-8)\n      string     language tag\n    */\n    const errorCode = bufferParser.readUInt32BE();\n    const errorMsg = bufferParser.readString(true);\n    bufferParser.clear();\n\n    // Note: we avoid checking that the error message and language tag are in\n    // the packet because there are some broken implementations that incorrectly\n    // omit them. The language tag in general was never really used amongst ssh\n    // implementations, so in the case of a missing error message we just\n    // default to something sensible.\n\n    if (sftp._debug) {\n      const jsonMsg = JSON.stringify(errorMsg);\n      sftp._debug(`SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`);\n    }\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') {\n      if (errorCode === STATUS_CODE.OK) {\n        req.cb();\n        return;\n      }\n      const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || 'Unknown status');\n      err.code = errorCode;\n      req.cb(err);\n    }\n  },\n  [RESPONSE.HANDLE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined) {\n      if (reqID !== undefined) delete sftp._requests[reqID];\n      return doFatalSFTPError(sftp, 'Malformed HANDLE packet');\n    }\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);\n    const req = sftp._requests[reqID];\n    delete sftp._requests[reqID];\n    if (req && typeof req.cb === 'function') req.cb(undefined, handle);\n  },\n  [RESPONSE.DATA]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      string     data\n    */\n    if (req && typeof req.cb === 'function') {\n      if (req.buffer) {\n        // We have already pre-allocated space to store the data\n\n        const nb = bufferParser.readString(req.buffer);\n        bufferParser.clear();\n        if (nb !== undefined) {\n          sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);\n          req.cb(undefined, req.buffer, nb);\n          return;\n        }\n      } else {\n        const data = bufferParser.readString();\n        bufferParser.clear();\n        if (data !== undefined) {\n          sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`);\n          req.cb(undefined, data);\n          return;\n        }\n      }\n    } else {\n      const nb = bufferParser.skipString();\n      bufferParser.clear();\n      if (nb !== undefined) {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);\n        return;\n      }\n    }\n    return doFatalSFTPError(sftp, 'Malformed DATA packet');\n  },\n  [RESPONSE.NAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      uint32     count\n      repeats count times:\n              string     filename\n              string     longname\n              ATTRS      attrs\n    */\n    const count = bufferParser.readUInt32BE();\n    if (count !== undefined) {\n      let names = [];\n      for (let i = 0; i < count; ++i) {\n        // We are going to assume UTF-8 for filenames despite the SFTPv3\n        // spec not specifying an encoding because the specs for newer\n        // versions of the protocol all explicitly specify UTF-8 for\n        // filenames\n        const filename = bufferParser.readString(true);\n\n        // `longname` only exists in SFTPv3 and since it typically will\n        // contain the filename, we assume it is also UTF-8\n        const longname = bufferParser.readString(true);\n        const attrs = readAttrs(sftp._biOpt);\n        if (attrs === undefined) {\n          names = undefined;\n          break;\n        }\n        names.push({\n          filename,\n          longname,\n          attrs\n        });\n      }\n      if (names !== undefined) {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`);\n        bufferParser.clear();\n        if (req && typeof req.cb === 'function') req.cb(undefined, names);\n        return;\n      }\n    }\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed NAME packet');\n  },\n  [RESPONSE.ATTRS]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    let req;\n    if (reqID !== undefined) {\n      req = sftp._requests[reqID];\n      delete sftp._requests[reqID];\n    }\n    /*\n      ATTRS      attrs\n    */\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs !== undefined) {\n      sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);\n      if (req && typeof req.cb === 'function') req.cb(undefined, attrs);\n      return;\n    }\n    return doFatalSFTPError(sftp, 'Malformed ATTRS packet');\n  },\n  [RESPONSE.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    if (reqID !== undefined) {\n      const req = sftp._requests[reqID];\n      if (req) {\n        delete sftp._requests[reqID];\n        switch (req.extended) {\n          case 'statvfs@openssh.com':\n          case 'fstatvfs@openssh.com':\n            {\n              /*\n                uint64    f_bsize   // file system block size\n                uint64    f_frsize  // fundamental fs block size\n                uint64    f_blocks  // number of blocks (unit f_frsize)\n                uint64    f_bfree   // free blocks in file system\n                uint64    f_bavail  // free blocks for non-root\n                uint64    f_files   // total file inodes\n                uint64    f_ffree   // free file inodes\n                uint64    f_favail  // free file inodes for to non-root\n                uint64    f_fsid    // file system id\n                uint64    f_flag    // bit mask of f_flag values\n                uint64    f_namemax // maximum filename length\n              */\n              const biOpt = sftp._biOpt;\n              const stats = {\n                f_bsize: bufferParser.readUInt64BE(biOpt),\n                f_frsize: bufferParser.readUInt64BE(biOpt),\n                f_blocks: bufferParser.readUInt64BE(biOpt),\n                f_bfree: bufferParser.readUInt64BE(biOpt),\n                f_bavail: bufferParser.readUInt64BE(biOpt),\n                f_files: bufferParser.readUInt64BE(biOpt),\n                f_ffree: bufferParser.readUInt64BE(biOpt),\n                f_favail: bufferParser.readUInt64BE(biOpt),\n                f_sid: bufferParser.readUInt64BE(biOpt),\n                f_flag: bufferParser.readUInt64BE(biOpt),\n                f_namemax: bufferParser.readUInt64BE(biOpt)\n              };\n              if (stats.f_namemax === undefined) break;\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, stats);\n              return;\n            }\n          case 'limits@openssh.com':\n            {\n              /*\n                uint64          max-packet-length\n                uint64          max-read-length\n                uint64          max-write-length\n                uint64          max-open-handles\n              */\n              const limits = {\n                maxPktLen: bufferParser.readUInt64BE(),\n                maxReadLen: bufferParser.readUInt64BE(),\n                maxWriteLen: bufferParser.readUInt64BE(),\n                maxOpenHandles: bufferParser.readUInt64BE()\n              };\n              if (limits.maxOpenHandles === undefined) break;\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, limits);\n              return;\n            }\n          case 'users-groups-by-id@openssh.com':\n            {\n              /*\n                string    usernames\n                  string    username1\n                  ...\n                string    groupnames\n                  string    groupname1\n                  ...\n              */\n              const usernameCount = bufferParser.readUInt32BE();\n              if (usernameCount === undefined) break;\n              const usernames = new Array(usernameCount);\n              for (let i = 0; i < usernames.length; ++i) usernames[i] = bufferParser.readString(true);\n              const groupnameCount = bufferParser.readUInt32BE();\n              if (groupnameCount === undefined) break;\n              const groupnames = new Array(groupnameCount);\n              for (let i = 0; i < groupnames.length; ++i) groupnames[i] = bufferParser.readString(true);\n              if (groupnames.length > 0 && groupnames[groupnames.length - 1] === undefined) {\n                break;\n              }\n              if (sftp._debug) {\n                sftp._debug('SFTP: Inbound: Received EXTENDED_REPLY ' + `(id:${reqID}, ${req.extended})`);\n              }\n              bufferParser.clear();\n              if (typeof req.cb === 'function') req.cb(undefined, usernames, groupnames);\n              return;\n            }\n          default:\n            // Unknown extended request\n            sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);\n            bufferParser.clear();\n            if (typeof req.cb === 'function') req.cb();\n            return;\n        }\n      } else {\n        sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);\n        bufferParser.clear();\n        return;\n      }\n    }\n    bufferParser.clear();\n    return doFatalSFTPError(sftp, 'Malformed EXTENDED_REPLY packet');\n  }\n};\nconst SERVER_HANDLERS = {\n  [REQUEST.INIT]: (sftp, payload) => {\n    if (sftp._version !== -1) return doFatalSFTPError(sftp, 'Duplicate INIT packet');\n    const extensions = {};\n\n    /*\n      uint32 version\n      <extension data>\n    */\n    bufferParser.init(payload, 1);\n    let version = bufferParser.readUInt32BE();\n    while (bufferParser.avail()) {\n      const extName = bufferParser.readString(true);\n      const extData = bufferParser.readString(true);\n      if (extData === undefined) {\n        version = undefined;\n        break;\n      }\n      extensions[extName] = extData;\n    }\n    bufferParser.clear();\n    if (version === undefined) return doFatalSFTPError(sftp, 'Malformed INIT packet');\n    if (sftp._debug) {\n      const names = Object.keys(extensions);\n      if (names.length) {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version}, exts:${names})`);\n      } else {\n        sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);\n      }\n    }\n    sendOrBuffer(sftp, SERVER_VERSION_BUFFER);\n    sftp._version = version;\n    sftp._extensions = extensions;\n    sftp.emit('ready');\n  },\n  [REQUEST.OPEN]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        filename\n      uint32        pflags\n      ATTRS         attrs\n    */\n    const filename = bufferParser.readString(true);\n    const pflags = bufferParser.readUInt32BE();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed OPEN packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);\n    if (!sftp.emit('OPEN', reqID, filename, pflags, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.CLOSE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed CLOSE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);\n    if (!sftp.emit('CLOSE', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READ]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      uint32     len\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const len = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (len === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed READ packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);\n    if (!sftp.emit('READ', reqID, handle, offset, len)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.WRITE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      uint64     offset\n      string     data\n    */\n    const handle = bufferParser.readString();\n    const offset = bufferParser.readUInt64BE(sftp._biOpt);\n    const data = bufferParser.readString();\n    bufferParser.clear();\n    if (data === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed WRITE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);\n    if (!sftp.emit('WRITE', reqID, handle, offset, data)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.LSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed LSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);\n    if (!sftp.emit('LSTAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed FSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);\n    if (!sftp.emit('FSTAT', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed SETSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);\n    if (!sftp.emit('SETSTAT', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.FSETSTAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     handle\n      ATTRS      attrs\n    */\n    const handle = bufferParser.readString();\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed FSETSTAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSETSTAT (id:${reqID})`);\n    if (!sftp.emit('FSETSTAT', reqID, handle, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.OPENDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed OPENDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);\n    if (!sftp.emit('OPENDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string        handle\n    */\n    const handle = bufferParser.readString();\n    bufferParser.clear();\n    if (handle === undefined || handle.length > 256) return doFatalSFTPError(sftp, 'Malformed READDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);\n    if (!sftp.emit('READDIR', reqID, handle)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REMOVE]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed REMOVE packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);\n    if (!sftp.emit('REMOVE', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.MKDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n      ATTRS      attrs\n    */\n    const path = bufferParser.readString(true);\n    const attrs = readAttrs(sftp._biOpt);\n    bufferParser.clear();\n    if (attrs === undefined) return doFatalSFTPError(sftp, 'Malformed MKDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);\n    if (!sftp.emit('MKDIR', reqID, path, attrs)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RMDIR]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed RMDIR packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);\n    if (!sftp.emit('RMDIR', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.REALPATH]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed REALPATH packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received REALPATH (id:${reqID})`);\n    if (!sftp.emit('REALPATH', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.STAT]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed STAT packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);\n    if (!sftp.emit('STAT', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.RENAME]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     oldpath\n      string     newpath\n    */\n    const oldPath = bufferParser.readString(true);\n    const newPath = bufferParser.readString(true);\n    bufferParser.clear();\n    if (newPath === undefined) return doFatalSFTPError(sftp, 'Malformed RENAME packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);\n    if (!sftp.emit('RENAME', reqID, oldPath, newPath)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.READLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     path\n    */\n    const path = bufferParser.readString(true);\n    bufferParser.clear();\n    if (path === undefined) return doFatalSFTPError(sftp, 'Malformed READLINK packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received READLINK (id:${reqID})`);\n    if (!sftp.emit('READLINK', reqID, path)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.SYMLINK]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     linkpath\n      string     targetpath\n    */\n    const linkPath = bufferParser.readString(true);\n    const targetPath = bufferParser.readString(true);\n    bufferParser.clear();\n    if (targetPath === undefined) return doFatalSFTPError(sftp, 'Malformed SYMLINK packet');\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);\n    let handled;\n    if (sftp._isOpenSSH) {\n      // OpenSSH has linkpath and targetpath positions switched\n      handled = sftp.emit('SYMLINK', reqID, targetPath, linkPath);\n    } else {\n      handled = sftp.emit('SYMLINK', reqID, linkPath, targetPath);\n    }\n    if (!handled) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  },\n  [REQUEST.EXTENDED]: (sftp, payload) => {\n    bufferParser.init(payload, 1);\n    const reqID = bufferParser.readUInt32BE();\n    /*\n      string     extended-request\n      ... any request-specific data ...\n    */\n    const extName = bufferParser.readString(true);\n    if (extName === undefined) {\n      bufferParser.clear();\n      return doFatalSFTPError(sftp, 'Malformed EXTENDED packet');\n    }\n    let extData;\n    if (bufferParser.avail()) extData = bufferParser.readRaw();\n    bufferParser.clear();\n    sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED (id:${reqID})`);\n    if (!sftp.emit('EXTENDED', reqID, extName, extData)) {\n      // Automatically reject request if no handler for request type\n      sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);\n    }\n  }\n};\n\n// =============================================================================\n// ReadStream/WriteStream-related ==============================================\n// =============================================================================\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  validateNumber\n} = require('./node-fs-compat');\nconst kMinPoolSpace = 128;\nlet pool;\n// It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\nconst poolFragments = [];\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0) pool = poolFragments.pop();else pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n// Check the `this.start` and `this.end` of stream.\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos)) throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n  if (pos < 0) throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\nfunction roundUpToMultipleOf8(n) {\n  return n + 7 & ~7; // Align to 8 byte boundary.\n}\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined) options = {};else if (typeof options === 'string') options = {\n    encoding: options\n  };else if (options === null || typeof options !== 'object') throw new TypeError('\"options\" argument must be a string or an object');else options = Object.create(options);\n\n  // A little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  ReadableStream.call(this, options);\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.isClosed = false;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n    this.pos = this.start;\n  }\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE('start', `<= \"end\" (here: ${this.end})`, this.start);\n    }\n  }\n  this.on('end', function () {\n    if (this.autoClose) this.destroy();\n  });\n  if (!Buffer.isBuffer(this.handle)) this.open();\n}\ninherits(ReadStream, ReadableStream);\nReadStream.prototype.open = function () {\n  if (this._opening) return;\n  this._opening = true;\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready');\n    // Start the flow of data.\n    this.read();\n  });\n};\nReadStream.prototype._read = function (n) {\n  if (!Buffer.isBuffer(this.handle)) return this.once('open', () => this._read(n));\n\n  // XXX: safe to remove this?\n  if (this.destroyed) return;\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // Discard the old pool.\n    allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  const thisPool = pool;\n  let toRead = Math.min(pool.length - pool.used, n);\n  const start = pool.used;\n  if (this.end !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // Already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0) return this.push(null);\n\n  // the actual read.\n  this.sftp.read(this.handle, pool, pool.used, toRead, this.pos, (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n    let b = null;\n\n    // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      const alignedEnd = start + toRead & ~7;\n      const alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace) poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    }\n\n    // Move the pool positions, and internal position for reading.\n    this.pos += bytesRead;\n    this.push(b);\n  });\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\nReadStream.prototype._destroy = function (err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle) return onclose();\n  stream.sftp.close(stream.handle, onclose);\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.isClosed = true;\n    if (!er) stream.emit('close');\n  }\n}\nReadStream.prototype.close = function (cb) {\n  this.destroy(null, cb);\n};\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n\n// TODO: add `concurrency` setting to allow more than one in-flight WRITE\n// request to server to improve throughput\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined) options = {};else if (typeof options === 'string') options = {\n    encoding: options\n  };else if (options === null || typeof options !== 'object') throw new TypeError('\"options\" argument must be a string or an object');else options = Object.create(options);\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = false; // Node 14 major change.\n\n  WritableStream.call(this, options);\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.isClosed = false;\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n    this.pos = this.start;\n  }\n  if (options.encoding) this.setDefaultEncoding(options.encoding);\n\n  // Node v6.x only\n  this.on('finish', function () {\n    if (this._writableState.finalCalled) return;\n    if (this.autoClose) this.destroy();\n  });\n  if (!Buffer.isBuffer(this.handle)) this.open();\n}\ninherits(WriteStream, WritableStream);\nWriteStream.prototype._final = function (cb) {\n  if (this.autoClose) this.destroy();\n  cb();\n};\nWriteStream.prototype.open = function () {\n  if (this._opening) return;\n  this._opening = true;\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose) this.destroy();\n      return;\n    }\n    this.handle = handle;\n    const tryAgain = err => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, err_ => tryAgain());\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (this.flags[0] === 'a') {\n        const tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\nWriteStream.prototype._write = function (data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function () {\n      this._write(data, encoding, cb);\n    });\n  }\n  this.sftp.write(this.handle, data, 0, data.length, this.pos, (er, bytes) => {\n    if (er) {\n      if (this.autoClose) this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n  this.pos += data.length;\n};\nWriteStream.prototype._writev = function (data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function () {\n      this._writev(data, cb);\n    });\n  }\n  const sftp = this.sftp;\n  const handle = this.handle;\n  let writesLeft = data.length;\n  const onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0) cb();\n  };\n\n  // TODO: try to combine chunks to reduce number of requests to the server?\n  for (let i = 0; i < data.length; ++i) {\n    const chunk = data[i].chunk;\n    sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\nif (typeof WritableStream.prototype.destroy !== 'function') WriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = function (cb) {\n  if (cb) {\n    if (this.isClosed) {\n      process.nextTick(cb);\n      return;\n    }\n    this.on('close', cb);\n  }\n\n  // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n  if (!this.autoClose) this.on('finish', this.destroy.bind(this));\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() {\n    return this.handle === null;\n  },\n  configurable: true\n});\n// =============================================================================\n\nmodule.exports = {\n  flagsToString,\n  OPEN_MODE,\n  SFTP,\n  Stats,\n  STATUS_CODE,\n  stringToFlags\n};","'use strict';\n\nconst crypto = require('crypto');\nlet cpuInfo;\ntry {\n  cpuInfo = require('cpu-features')();\n} catch {}\nconst {\n  bindingAvailable,\n  CIPHER_INFO,\n  MAC_INFO\n} = require('./crypto.js');\nconst eddsaSupported = (() => {\n  if (typeof crypto.sign === 'function' && typeof crypto.verify === 'function') {\n    const key = '-----BEGIN PRIVATE KEY-----\\r\\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD' + '/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\\r\\n-----END PRIVATE KEY-----';\n    const data = Buffer.from('a');\n    let sig;\n    let verified;\n    try {\n      sig = crypto.sign(null, data, key);\n      verified = crypto.verify(null, data, key, sig);\n    } catch {}\n    return Buffer.isBuffer(sig) && sig.length === 64 && verified === true;\n  }\n  return false;\n})();\nconst curve25519Supported = typeof crypto.diffieHellman === 'function' && typeof crypto.generateKeyPairSync === 'function' && typeof crypto.createPublicKey === 'function';\nconst DEFAULT_KEX = [\n// https://tools.ietf.org/html/rfc5656#section-10.1\n'ecdh-sha2-nistp256', 'ecdh-sha2-nistp384', 'ecdh-sha2-nistp521',\n// https://tools.ietf.org/html/rfc4419#section-4\n'diffie-hellman-group-exchange-sha256',\n// https://tools.ietf.org/html/rfc8268\n'diffie-hellman-group14-sha256', 'diffie-hellman-group15-sha512', 'diffie-hellman-group16-sha512', 'diffie-hellman-group17-sha512', 'diffie-hellman-group18-sha512'];\nif (curve25519Supported) {\n  DEFAULT_KEX.unshift('curve25519-sha256');\n  DEFAULT_KEX.unshift('curve25519-sha256@libssh.org');\n}\nconst SUPPORTED_KEX = DEFAULT_KEX.concat([\n// https://tools.ietf.org/html/rfc4419#section-4\n'diffie-hellman-group-exchange-sha1', 'diffie-hellman-group14-sha1',\n// REQUIRED\n'diffie-hellman-group1-sha1' // REQUIRED\n]);\nconst DEFAULT_SERVER_HOST_KEY = ['ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384', 'ecdsa-sha2-nistp521', 'rsa-sha2-512',\n// RFC 8332\n'rsa-sha2-256',\n// RFC 8332\n'ssh-rsa'];\nif (eddsaSupported) DEFAULT_SERVER_HOST_KEY.unshift('ssh-ed25519');\nconst SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat(['ssh-dss']);\nconst canUseCipher = (() => {\n  const ciphers = crypto.getCiphers();\n  return name => ciphers.includes(CIPHER_INFO[name].sslName);\n})();\nlet DEFAULT_CIPHER = [\n// http://tools.ietf.org/html/rfc5647\n'aes128-gcm@openssh.com', 'aes256-gcm@openssh.com',\n// http://tools.ietf.org/html/rfc4344#section-4\n'aes128-ctr', 'aes192-ctr', 'aes256-ctr'];\nif (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {\n  // We know for sure the CPU does not support AES acceleration\n  if (bindingAvailable) DEFAULT_CIPHER.unshift('chacha20-poly1305@openssh.com');else DEFAULT_CIPHER.push('chacha20-poly1305@openssh.com');\n} else if (bindingAvailable && cpuInfo && cpuInfo.arch === 'x86') {\n  // Places chacha20-poly1305 immediately after GCM ciphers since GCM ciphers\n  // seem to outperform it on x86, but it seems to be faster than CTR ciphers\n  DEFAULT_CIPHER.splice(4, 0, 'chacha20-poly1305@openssh.com');\n} else {\n  DEFAULT_CIPHER.push('chacha20-poly1305@openssh.com');\n}\nDEFAULT_CIPHER = DEFAULT_CIPHER.filter(canUseCipher);\nconst SUPPORTED_CIPHER = DEFAULT_CIPHER.concat(['aes256-cbc', 'aes192-cbc', 'aes128-cbc', 'blowfish-cbc', '3des-cbc', 'aes128-gcm', 'aes256-gcm',\n// http://tools.ietf.org/html/rfc4345#section-4:\n'arcfour256', 'arcfour128', 'cast128-cbc', 'arcfour'].filter(canUseCipher));\nconst canUseMAC = (() => {\n  const hashes = crypto.getHashes();\n  return name => hashes.includes(MAC_INFO[name].sslName);\n})();\nconst DEFAULT_MAC = ['hmac-sha2-256-etm@openssh.com', 'hmac-sha2-512-etm@openssh.com', 'hmac-sha1-etm@openssh.com', 'hmac-sha2-256', 'hmac-sha2-512', 'hmac-sha1'].filter(canUseMAC);\nconst SUPPORTED_MAC = DEFAULT_MAC.concat(['hmac-md5', 'hmac-sha2-256-96',\n// first 96 bits of HMAC-SHA256\n'hmac-sha2-512-96',\n// first 96 bits of HMAC-SHA512\n'hmac-ripemd160', 'hmac-sha1-96',\n// first 96 bits of HMAC-SHA1\n'hmac-md5-96' // first 96 bits of HMAC-MD5\n].filter(canUseMAC));\nconst DEFAULT_COMPRESSION = ['none', 'zlib@openssh.com',\n// ZLIB (LZ77) compression, except\n// compression/decompression does not start until after\n// successful user authentication\n'zlib' // ZLIB (LZ77) compression\n];\nconst SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([]);\nconst COMPAT = {\n  BAD_DHGEX: 1 << 0,\n  OLD_EXIT: 1 << 1,\n  DYN_RPORT_BUG: 1 << 2,\n  BUG_DHGEX_LARGE: 1 << 3,\n  IMPLY_RSA_SHA2_SIGALGS: 1 << 4\n};\nmodule.exports = {\n  MESSAGE: {\n    // Transport layer protocol -- generic (1-19)\n    DISCONNECT: 1,\n    IGNORE: 2,\n    UNIMPLEMENTED: 3,\n    DEBUG: 4,\n    SERVICE_REQUEST: 5,\n    SERVICE_ACCEPT: 6,\n    EXT_INFO: 7,\n    // RFC 8308\n\n    // Transport layer protocol -- algorithm negotiation (20-29)\n    KEXINIT: 20,\n    NEWKEYS: 21,\n    // Transport layer protocol -- key exchange method-specific (30-49)\n    KEXDH_INIT: 30,\n    KEXDH_REPLY: 31,\n    KEXDH_GEX_GROUP: 31,\n    KEXDH_GEX_INIT: 32,\n    KEXDH_GEX_REPLY: 33,\n    KEXDH_GEX_REQUEST: 34,\n    KEXECDH_INIT: 30,\n    KEXECDH_REPLY: 31,\n    // User auth protocol -- generic (50-59)\n    USERAUTH_REQUEST: 50,\n    USERAUTH_FAILURE: 51,\n    USERAUTH_SUCCESS: 52,\n    USERAUTH_BANNER: 53,\n    // User auth protocol -- user auth method-specific (60-79)\n    USERAUTH_PASSWD_CHANGEREQ: 60,\n    USERAUTH_PK_OK: 60,\n    USERAUTH_INFO_REQUEST: 60,\n    USERAUTH_INFO_RESPONSE: 61,\n    // Connection protocol -- generic (80-89)\n    GLOBAL_REQUEST: 80,\n    REQUEST_SUCCESS: 81,\n    REQUEST_FAILURE: 82,\n    // Connection protocol -- channel-related (90-127)\n    CHANNEL_OPEN: 90,\n    CHANNEL_OPEN_CONFIRMATION: 91,\n    CHANNEL_OPEN_FAILURE: 92,\n    CHANNEL_WINDOW_ADJUST: 93,\n    CHANNEL_DATA: 94,\n    CHANNEL_EXTENDED_DATA: 95,\n    CHANNEL_EOF: 96,\n    CHANNEL_CLOSE: 97,\n    CHANNEL_REQUEST: 98,\n    CHANNEL_SUCCESS: 99,\n    CHANNEL_FAILURE: 100\n\n    // Reserved for client protocols (128-191)\n\n    // Local extensions (192-155)\n  },\n  DISCONNECT_REASON: {\n    HOST_NOT_ALLOWED_TO_CONNECT: 1,\n    PROTOCOL_ERROR: 2,\n    KEY_EXCHANGE_FAILED: 3,\n    RESERVED: 4,\n    MAC_ERROR: 5,\n    COMPRESSION_ERROR: 6,\n    SERVICE_NOT_AVAILABLE: 7,\n    PROTOCOL_VERSION_NOT_SUPPORTED: 8,\n    HOST_KEY_NOT_VERIFIABLE: 9,\n    CONNECTION_LOST: 10,\n    BY_APPLICATION: 11,\n    TOO_MANY_CONNECTIONS: 12,\n    AUTH_CANCELED_BY_USER: 13,\n    NO_MORE_AUTH_METHODS_AVAILABLE: 14,\n    ILLEGAL_USER_NAME: 15\n  },\n  DISCONNECT_REASON_STR: undefined,\n  CHANNEL_OPEN_FAILURE: {\n    ADMINISTRATIVELY_PROHIBITED: 1,\n    CONNECT_FAILED: 2,\n    UNKNOWN_CHANNEL_TYPE: 3,\n    RESOURCE_SHORTAGE: 4\n  },\n  TERMINAL_MODE: {\n    TTY_OP_END: 0,\n    // Indicates end of options.\n    VINTR: 1,\n    // Interrupt character; 255 if none. Similarly for the\n    //  other characters.  Not all of these characters are\n    //  supported on all systems.\n    VQUIT: 2,\n    // The quit character (sends SIGQUIT signal on POSIX\n    //  systems).\n    VERASE: 3,\n    // Erase the character to left of the cursor.\n    VKILL: 4,\n    // Kill the current input line.\n    VEOF: 5,\n    // End-of-file character (sends EOF from the\n    //  terminal).\n    VEOL: 6,\n    // End-of-line character in addition to carriage\n    //  return and/or linefeed.\n    VEOL2: 7,\n    // Additional end-of-line character.\n    VSTART: 8,\n    // Continues paused output (normally control-Q).\n    VSTOP: 9,\n    // Pauses output (normally control-S).\n    VSUSP: 10,\n    // Suspends the current program.\n    VDSUSP: 11,\n    // Another suspend character.\n    VREPRINT: 12,\n    // Reprints the current input line.\n    VWERASE: 13,\n    // Erases a word left of cursor.\n    VLNEXT: 14,\n    // Enter the next character typed literally, even if\n    //  it is a special character\n    VFLUSH: 15,\n    // Character to flush output.\n    VSWTCH: 16,\n    // Switch to a different shell layer.\n    VSTATUS: 17,\n    // Prints system status line (load, command, pid,\n    //  etc).\n    VDISCARD: 18,\n    // Toggles the flushing of terminal output.\n    IGNPAR: 30,\n    // The ignore parity flag.  The parameter SHOULD be 0\n    //  if this flag is FALSE, and 1 if it is TRUE.\n    PARMRK: 31,\n    // Mark parity and framing errors.\n    INPCK: 32,\n    // Enable checking of parity errors.\n    ISTRIP: 33,\n    // Strip 8th bit off characters.\n    INLCR: 34,\n    // Map NL into CR on input.\n    IGNCR: 35,\n    // Ignore CR on input.\n    ICRNL: 36,\n    // Map CR to NL on input.\n    IUCLC: 37,\n    // Translate uppercase characters to lowercase.\n    IXON: 38,\n    // Enable output flow control.\n    IXANY: 39,\n    // Any char will restart after stop.\n    IXOFF: 40,\n    // Enable input flow control.\n    IMAXBEL: 41,\n    // Ring bell on input queue full.\n    ISIG: 50,\n    // Enable signals INTR, QUIT, [D]SUSP.\n    ICANON: 51,\n    // Canonicalize input lines.\n    XCASE: 52,\n    // Enable input and output of uppercase characters by\n    //  preceding their lowercase equivalents with \"\\\".\n    ECHO: 53,\n    // Enable echoing.\n    ECHOE: 54,\n    // Visually erase chars.\n    ECHOK: 55,\n    // Kill character discards current line.\n    ECHONL: 56,\n    // Echo NL even if ECHO is off.\n    NOFLSH: 57,\n    // Don't flush after interrupt.\n    TOSTOP: 58,\n    // Stop background jobs from output.\n    IEXTEN: 59,\n    // Enable extensions.\n    ECHOCTL: 60,\n    // Echo control characters as ^(Char).\n    ECHOKE: 61,\n    // Visual erase for line kill.\n    PENDIN: 62,\n    // Retype pending input.\n    OPOST: 70,\n    // Enable output processing.\n    OLCUC: 71,\n    // Convert lowercase to uppercase.\n    ONLCR: 72,\n    // Map NL to CR-NL.\n    OCRNL: 73,\n    // Translate carriage return to newline (output).\n    ONOCR: 74,\n    // Translate newline to carriage return-newline\n    //  (output).\n    ONLRET: 75,\n    // Newline performs a carriage return (output).\n    CS7: 90,\n    // 7 bit mode.\n    CS8: 91,\n    // 8 bit mode.\n    PARENB: 92,\n    // Parity enable.\n    PARODD: 93,\n    // Odd parity, else even.\n    TTY_OP_ISPEED: 128,\n    // Specifies the input baud rate in bits per second.\n    TTY_OP_OSPEED: 129 // Specifies the output baud rate in bits per second.\n  },\n  CHANNEL_EXTENDED_DATATYPE: {\n    STDERR: 1\n  },\n  SIGNALS: ['ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT', 'QUIT', 'SEGV', 'TERM', 'USR1', 'USR2', 'KILL', 'PIPE'].reduce((cur, val) => ({\n    ...cur,\n    [val]: 1\n  }), {}),\n  COMPAT,\n  COMPAT_CHECKS: [['Cisco-1.25', COMPAT.BAD_DHGEX], [/^Cisco-1[.]/, COMPAT.BUG_DHGEX_LARGE], [/^[0-9.]+$/, COMPAT.OLD_EXIT],\n  // old SSH.com implementations\n  [/^OpenSSH_5[.][0-9]+/, COMPAT.DYN_RPORT_BUG], [/^OpenSSH_7[.]4/, COMPAT.IMPLY_RSA_SHA2_SIGALGS]],\n  // KEX proposal-related\n  DEFAULT_KEX,\n  SUPPORTED_KEX,\n  DEFAULT_SERVER_HOST_KEY,\n  SUPPORTED_SERVER_HOST_KEY,\n  DEFAULT_CIPHER,\n  SUPPORTED_CIPHER,\n  DEFAULT_MAC,\n  SUPPORTED_MAC,\n  DEFAULT_COMPRESSION,\n  SUPPORTED_COMPRESSION,\n  curve25519Supported,\n  eddsaSupported\n};\nmodule.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module.exports.DISCONNECT_REASON)).reduce((obj, [key, value]) => ({\n  ...obj,\n  [value]: key\n}), {});","// TODO:\n//    * make max packet size configurable\n//    * if decompression is enabled, use `._packet` in decipher instances as\n//      input to (sync) zlib inflater with appropriate offset and length to\n//      avoid an additional copy of payload data before inflation\n//    * factor decompression status into packet length checks\n'use strict';\n\nconst {\n  createCipheriv,\n  createDecipheriv,\n  createHmac,\n  randomFillSync,\n  timingSafeEqual\n} = require('crypto');\nconst {\n  readUInt32BE,\n  writeUInt32BE\n} = require('./utils.js');\nconst FastBuffer = Buffer[Symbol.species];\nconst MAX_SEQNO = 2 ** 32 - 1;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nconst BUF_INT = Buffer.alloc(4);\nconst DISCARD_CACHE = new Map();\nconst MAX_PACKET_SIZE = 35000;\nlet binding;\nlet AESGCMCipher;\nlet ChaChaPolyCipher;\nlet GenericCipher;\nlet AESGCMDecipher;\nlet ChaChaPolyDecipher;\nlet GenericDecipher;\ntry {\n  binding = require('./crypto/build/Release/sshcrypto.node');\n  ({\n    AESGCMCipher,\n    ChaChaPolyCipher,\n    GenericCipher,\n    AESGCMDecipher,\n    ChaChaPolyDecipher,\n    GenericDecipher\n  } = binding);\n} catch {}\nconst CIPHER_STREAM = 1 << 0;\nconst CIPHER_INFO = (() => {\n  function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {\n    return {\n      sslName,\n      blockLen,\n      keyLen,\n      ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,\n      authLen,\n      discardLen,\n      stream: !!(flags & CIPHER_STREAM)\n    };\n  }\n  return {\n    'chacha20-poly1305@openssh.com': info('chacha20', 8, 64, 0, 16, 0, CIPHER_STREAM),\n    'aes128-gcm': info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),\n    'aes256-gcm': info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),\n    'aes128-gcm@openssh.com': info('aes-128-gcm', 16, 16, 12, 16, 0, CIPHER_STREAM),\n    'aes256-gcm@openssh.com': info('aes-256-gcm', 16, 32, 12, 16, 0, CIPHER_STREAM),\n    'aes128-cbc': info('aes-128-cbc', 16, 16, 0, 0, 0, 0),\n    'aes192-cbc': info('aes-192-cbc', 16, 24, 0, 0, 0, 0),\n    'aes256-cbc': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),\n    'rijndael-cbc@lysator.liu.se': info('aes-256-cbc', 16, 32, 0, 0, 0, 0),\n    '3des-cbc': info('des-ede3-cbc', 8, 24, 0, 0, 0, 0),\n    'blowfish-cbc': info('bf-cbc', 8, 16, 0, 0, 0, 0),\n    'idea-cbc': info('idea-cbc', 8, 16, 0, 0, 0, 0),\n    'cast128-cbc': info('cast-cbc', 8, 16, 0, 0, 0, 0),\n    'aes128-ctr': info('aes-128-ctr', 16, 16, 16, 0, 0, CIPHER_STREAM),\n    'aes192-ctr': info('aes-192-ctr', 16, 24, 16, 0, 0, CIPHER_STREAM),\n    'aes256-ctr': info('aes-256-ctr', 16, 32, 16, 0, 0, CIPHER_STREAM),\n    '3des-ctr': info('des-ede3', 8, 24, 8, 0, 0, CIPHER_STREAM),\n    'blowfish-ctr': info('bf-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),\n    'cast128-ctr': info('cast5-ecb', 8, 16, 8, 0, 0, CIPHER_STREAM),\n    /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n       [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n       generated by the cipher MUST be discarded, and the first byte of the\n       first encrypted packet MUST be encrypted using the 1537th byte of\n       keystream.\n        -- http://tools.ietf.org/html/rfc4345#section-4 */\n    'arcfour': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour128': info('rc4', 8, 16, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour256': info('rc4', 8, 32, 0, 0, 1536, CIPHER_STREAM),\n    'arcfour512': info('rc4', 8, 64, 0, 0, 1536, CIPHER_STREAM)\n  };\n})();\nconst MAC_INFO = (() => {\n  function info(sslName, len, actualLen, isETM) {\n    return {\n      sslName,\n      len,\n      actualLen,\n      isETM\n    };\n  }\n  return {\n    'hmac-md5': info('md5', 16, 16, false),\n    'hmac-md5-96': info('md5', 16, 12, false),\n    'hmac-ripemd160': info('ripemd160', 20, 20, false),\n    'hmac-sha1': info('sha1', 20, 20, false),\n    'hmac-sha1-etm@openssh.com': info('sha1', 20, 20, true),\n    'hmac-sha1-96': info('sha1', 20, 12, false),\n    'hmac-sha2-256': info('sha256', 32, 32, false),\n    'hmac-sha2-256-etm@openssh.com': info('sha256', 32, 32, true),\n    'hmac-sha2-256-96': info('sha256', 32, 12, false),\n    'hmac-sha2-512': info('sha512', 64, 64, false),\n    'hmac-sha2-512-etm@openssh.com': info('sha512', 64, 64, true),\n    'hmac-sha2-512-96': info('sha512', 64, 12, false)\n  };\n})();\n\n// Should only_be used during the initial handshake\nclass NullCipher {\n  constructor(seqno, onWrite) {\n    this.outSeqno = seqno;\n    this._onWrite = onWrite;\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen & 8 - 1);\n    if (padLen < 4) padLen += 8;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n    this._onWrite(packet);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nconst POLY1305_ZEROS = Buffer.alloc(32);\nconst POLY1305_OUT_COMPUTE = Buffer.alloc(16);\nlet POLY1305_WASM_MODULE;\nlet POLY1305_RESULT_MALLOC;\nlet poly1305_auth;\nclass ChaChaPolyCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encKeyMain = enc.cipherKey.slice(0, 32);\n    this._encKeyPktLen = enc.cipherKey.slice(32);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen - 4 & 8 - 1);\n    if (padLen < 4) padLen += 8;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n\n    // Generate Poly1305 key\n    POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n    writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);\n    const polyKey = createCipheriv('chacha20', this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);\n\n    // Encrypt packet length\n    const pktLenEnc = createCipheriv('chacha20', this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));\n    this._onWrite(pktLenEnc);\n\n    // Encrypt rest of packet\n    POLY1305_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)\n    const payloadEnc = createCipheriv('chacha20', this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));\n    this._onWrite(payloadEnc);\n\n    // Calculate Poly1305 MAC\n    poly1305_auth(POLY1305_RESULT_MALLOC, pktLenEnc, pktLenEnc.length, payloadEnc, payloadEnc.length, polyKey);\n    const mac = Buffer.allocUnsafe(16);\n    mac.set(new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer, POLY1305_RESULT_MALLOC, 16), 0);\n    this._onWrite(mac);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nclass ChaChaPolyCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._instance = new ChaChaPolyCipher(enc.cipherKey);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n    this._instance.free();\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 8 - (pktLen - 4 & 8 - 1);\n    if (padLen < 4) padLen += 8;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen + 16 /* MAC */);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n\n    // Encrypts in-place\n    this._instance.encrypt(packet, this.outSeqno);\n    this._onWrite(packet);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nclass AESGCMCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encSSLName = enc.cipherInfo.sslName;\n    this._encKey = enc.cipherKey;\n    this._encIV = enc.cipherIV;\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 16 - (pktLen - 4 & 16 - 1);\n    if (padLen < 4) padLen += 16;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n    const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);\n    cipher.setAutoPadding(false);\n    const lenData = packet.slice(0, 4);\n    cipher.setAAD(lenData);\n    this._onWrite(lenData);\n\n    // Encrypt pad length, payload, and padding\n    const encrypted = cipher.update(packet.slice(4));\n    this._onWrite(encrypted);\n    const final = cipher.final();\n    // XXX: final.length === 0 always?\n    if (final.length) this._onWrite(final);\n\n    // Generate MAC\n    const tag = cipher.getAuthTag();\n    this._onWrite(tag);\n\n    // Increment counter in IV by 1 for next packet\n    ivIncrement(this._encIV);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nclass AESGCMCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._instance = new AESGCMCipher(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n    this._instance.free();\n  }\n  allocPacket(payloadLen) {\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = 16 - (pktLen - 4 & 16 - 1);\n    if (padLen < 4) padLen += 16;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen + 16 /* authTag */);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n\n    // Encrypts in-place\n    this._instance.encrypt(packet);\n    this._onWrite(packet);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nclass GenericCipherNative {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encBlockLen = enc.cipherInfo.blockLen;\n    this._cipherInstance = createCipheriv(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV);\n    this._macSSLName = enc.macInfo.sslName;\n    this._macKey = enc.macKey;\n    this._macActualLen = enc.macInfo.actualLen;\n    this._macETM = enc.macInfo.isETM;\n    this._aadLen = this._macETM ? 4 : 0;\n    this._dead = false;\n    const discardLen = enc.cipherInfo.discardLen;\n    if (discardLen) {\n      let discard = DISCARD_CACHE.get(discardLen);\n      if (discard === undefined) {\n        discard = Buffer.alloc(discardLen);\n        DISCARD_CACHE.set(discardLen, discard);\n      }\n      this._cipherInstance.update(discard);\n    }\n  }\n  free() {\n    this._dead = true;\n  }\n  allocPacket(payloadLen) {\n    const blockLen = this._encBlockLen;\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);\n    if (padLen < 4) padLen += blockLen;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n    let mac;\n    if (this._macETM) {\n      // Encrypt pad length, payload, and padding\n      const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);\n      const encrypted = this._cipherInstance.update(new Uint8Array(packet.buffer, packet.byteOffset + 4, packet.length - 4));\n      this._onWrite(lenBytes);\n      this._onWrite(encrypted);\n\n      // TODO: look into storing seqno as 4-byte buffer and incrementing like we\n      // do for AES-GCM IVs to avoid having to (re)write all 4 bytes every time\n      mac = createHmac(this._macSSLName, this._macKey);\n      writeUInt32BE(BUF_INT, this.outSeqno, 0);\n      mac.update(BUF_INT);\n      mac.update(lenBytes);\n      mac.update(encrypted);\n    } else {\n      // Encrypt length field, pad length, payload, and padding\n      const encrypted = this._cipherInstance.update(packet);\n      this._onWrite(encrypted);\n\n      // TODO: look into storing seqno as 4-byte buffer and incrementing like we\n      // do for AES-GCM IVs to avoid having to (re)write all 4 bytes every time\n      mac = createHmac(this._macSSLName, this._macKey);\n      writeUInt32BE(BUF_INT, this.outSeqno, 0);\n      mac.update(BUF_INT);\n      mac.update(packet);\n    }\n    let digest = mac.digest();\n    if (digest.length > this._macActualLen) digest = digest.slice(0, this._macActualLen);\n    this._onWrite(digest);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nclass GenericCipherBinding {\n  constructor(config) {\n    const enc = config.outbound;\n    this.outSeqno = enc.seqno;\n    this._onWrite = enc.onWrite;\n    this._encBlockLen = enc.cipherInfo.blockLen;\n    this._macLen = enc.macInfo.len;\n    this._macActualLen = enc.macInfo.actualLen;\n    this._aadLen = enc.macInfo.isETM ? 4 : 0;\n    this._instance = new GenericCipher(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV, enc.macInfo.sslName, enc.macKey, enc.macInfo.isETM);\n    this._dead = false;\n  }\n  free() {\n    this._dead = true;\n    this._instance.free();\n  }\n  allocPacket(payloadLen) {\n    const blockLen = this._encBlockLen;\n    let pktLen = 4 + 1 + payloadLen;\n    let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);\n    if (padLen < 4) padLen += blockLen;\n    pktLen += padLen;\n    const packet = Buffer.allocUnsafe(pktLen + this._macLen);\n    writeUInt32BE(packet, pktLen - 4, 0);\n    packet[4] = padLen;\n    randomFillSync(packet, 5 + payloadLen, padLen);\n    return packet;\n  }\n  encrypt(packet) {\n    // `packet` === unencrypted packet\n\n    if (this._dead) return;\n\n    // Encrypts in-place\n    this._instance.encrypt(packet, this.outSeqno);\n    if (this._macActualLen < this._macLen) {\n      packet = new FastBuffer(packet.buffer, packet.byteOffset, packet.length - (this._macLen - this._macActualLen));\n    }\n    this._onWrite(packet);\n    this.outSeqno = this.outSeqno + 1 >>> 0;\n  }\n}\nclass NullDecipher {\n  constructor(seqno, onPayload) {\n    this.inSeqno = seqno;\n    this._onPayload = onPayload;\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._packetPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n        while (nb--) this._len = (this._len << 8) + data[p++];\n        if (this._lenBytes < 4) return;\n        if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n        if (p >= dataLen) return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._packetPos < this._len) {\n        const nb = Math.min(this._len - this._packetPos, dataLen - p);\n        let chunk;\n        if (p !== 0 || nb !== dataLen) chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);else chunk = data;\n        if (nb === this._len) {\n          this._packet = chunk;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(chunk, this._packetPos);\n        }\n        p += nb;\n        this._packetPos += nb;\n        if (this._packetPos < this._len) return;\n      }\n      const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\nclass ChaChaPolyDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decKeyMain = dec.decipherKey.slice(0, 32);\n    this._decKeyPktLen = dec.decipherKey.slice(32);\n    this._len = 0;\n    this._lenBuf = Buffer.alloc(4);\n    this._lenPos = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(16);\n    this._calcMac = Buffer.allocUnsafe(16);\n    this._macPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenPos < 4) {\n        let nb = Math.min(4 - this._lenPos, dataLen - p);\n        while (nb--) this._lenBuf[this._lenPos++] = data[p++];\n        if (this._lenPos < 4) return;\n        POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n        writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);\n        const decLenBytes = createDecipheriv('chacha20', this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);\n        this._len = readUInt32BE(decLenBytes, 0);\n        if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        if (p >= dataLen) return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      }\n\n      // Read Poly1305 MAC\n      {\n        const nb = Math.min(16 - this._macPos, dataLen - p);\n        // TODO: avoid copying if entire MAC is in current chunk\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < 16) return;\n      }\n\n      // Generate Poly1305 key\n      POLY1305_OUT_COMPUTE[0] = 0; // Set counter to 0 (little endian)\n      writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);\n      const polyKey = createCipheriv('chacha20', this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);\n\n      // Calculate and compare Poly1305 MACs\n      poly1305_auth(POLY1305_RESULT_MALLOC, this._lenBuf, 4, this._packet, this._packet.length, polyKey);\n      this._calcMac.set(new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer, POLY1305_RESULT_MALLOC, 16), 0);\n      if (!timingSafeEqual(this._calcMac, this._mac)) throw new Error('Invalid MAC');\n\n      // Decrypt packet\n      POLY1305_OUT_COMPUTE[0] = 1; // Set counter to 1 (little endian)\n      const packet = createDecipheriv('chacha20', this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);\n      const payload = new FastBuffer(packet.buffer, packet.byteOffset + 1, packet.length - packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenPos = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\nclass ChaChaPolyDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new ChaChaPolyDecipher(dec.decipherKey);\n    this._len = 0;\n    this._lenBuf = Buffer.alloc(4);\n    this._lenPos = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(16);\n    this._macPos = 0;\n  }\n  free() {\n    this._instance.free();\n  }\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length\n      if (this._lenPos < 4) {\n        let nb = Math.min(4 - this._lenPos, dataLen - p);\n        while (nb--) this._lenBuf[this._lenPos++] = data[p++];\n        if (this._lenPos < 4) return;\n        this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);\n        if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {\n          throw new Error('Bad packet length');\n        }\n        if (p >= dataLen) return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      }\n\n      // Read Poly1305 MAC\n      {\n        const nb = Math.min(16 - this._macPos, dataLen - p);\n        // TODO: avoid copying if entire MAC is in current chunk\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < 16) return;\n      }\n      this._instance.decrypt(this._packet, this._mac, this.inSeqno);\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenPos = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\nclass AESGCMDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decipherInstance = null;\n    this._decipherSSLName = dec.decipherInfo.sslName;\n    this._decipherKey = dec.decipherKey;\n    this._decipherIV = dec.decipherIV;\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._packetPos = 0;\n    this._pktLen = 0;\n    this._tag = Buffer.allocUnsafe(16);\n    this._tagPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length (unencrypted, but AAD)\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n        while (nb--) this._len = (this._len << 8) + data[p++];\n        if (this._lenBytes < 4) return;\n        if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {\n          throw new Error('Bad packet length');\n        }\n        this._decipherInstance = createDecipheriv(this._decipherSSLName, this._decipherKey, this._decipherIV);\n        this._decipherInstance.setAutoPadding(false);\n        this._decipherInstance.setAAD(intToBytes(this._len));\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        if (p >= dataLen) return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let decrypted;\n        if (p !== 0 || nb !== dataLen) {\n          decrypted = this._decipherInstance.update(new Uint8Array(data.buffer, data.byteOffset + p, nb));\n        } else {\n          decrypted = this._decipherInstance.update(data);\n        }\n        if (decrypted.length) {\n          if (nb === this._len) {\n            this._packet = decrypted;\n          } else {\n            if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n            this._packet.set(decrypted, this._packetPos);\n          }\n          this._packetPos += decrypted.length;\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      }\n\n      // Read authentication tag\n      {\n        const nb = Math.min(16 - this._tagPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._tag.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._tagPos);\n        } else {\n          this._tag.set(data, this._tagPos);\n        }\n        p += nb;\n        this._tagPos += nb;\n        if (this._tagPos < 16) return;\n      }\n      {\n        // Verify authentication tag\n        this._decipherInstance.setAuthTag(this._tag);\n        const decrypted = this._decipherInstance.final();\n\n        // XXX: this should never output any data since stream ciphers always\n        // return data from .update() and block ciphers must end on a multiple\n        // of the block length, which would have caused an exception to be\n        // thrown if the total input was not...\n        if (decrypted.length) {\n          if (this._packet) this._packet.set(decrypted, this._packetPos);else this._packet = decrypted;\n        }\n      }\n      const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      ivIncrement(this._decipherIV);\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      this._pktLen = 0;\n      this._tagPos = 0;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\nclass AESGCMDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new AESGCMDecipher(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV);\n    this._len = 0;\n    this._lenBytes = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._tag = Buffer.allocUnsafe(16);\n    this._tagPos = 0;\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read packet length (unencrypted, but AAD)\n      if (this._lenBytes < 4) {\n        let nb = Math.min(4 - this._lenBytes, dataLen - p);\n        this._lenBytes += nb;\n        while (nb--) this._len = (this._len << 8) + data[p++];\n        if (this._lenBytes < 4) return;\n        if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {\n          throw new Error(`Bad packet length: ${this._len}`);\n        }\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        if (p >= dataLen) return;\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      }\n\n      // Read authentication tag\n      {\n        const nb = Math.min(16 - this._tagPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._tag.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._tagPos);\n        } else {\n          this._tag.set(data, this._tagPos);\n        }\n        p += nb;\n        this._tagPos += nb;\n        if (this._tagPos < 16) return;\n      }\n      this._instance.decrypt(this._packet, this._len, this._tag);\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._len = 0;\n      this._lenBytes = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._tagPos = 0;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\n\n// TODO: test incremental .update()s vs. copying to _packet and doing a single\n// .update() after entire packet read -- a single .update() would allow\n// verifying MAC before decrypting for ETM MACs\nclass GenericDecipherNative {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._decipherInstance = createDecipheriv(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV);\n    this._decipherInstance.setAutoPadding(false);\n    this._block = Buffer.allocUnsafe(dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen);\n    this._blockSize = dec.decipherInfo.blockLen;\n    this._blockPos = 0;\n    this._len = 0;\n    this._packet = null;\n    this._packetPos = 0;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);\n    this._macPos = 0;\n    this._macSSLName = dec.macInfo.sslName;\n    this._macKey = dec.macKey;\n    this._macActualLen = dec.macInfo.actualLen;\n    this._macETM = dec.macInfo.isETM;\n    this._macInstance = null;\n    const discardLen = dec.decipherInfo.discardLen;\n    if (discardLen) {\n      let discard = DISCARD_CACHE.get(discardLen);\n      if (discard === undefined) {\n        discard = Buffer.alloc(discardLen);\n        DISCARD_CACHE.set(discardLen, discard);\n      }\n      this._decipherInstance.update(discard);\n    }\n  }\n  free() {}\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read first encrypted block\n      if (this._blockPos < this._block.length) {\n        const nb = Math.min(this._block.length - this._blockPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen || nb < data.length) {\n          this._block.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._blockPos);\n        } else {\n          this._block.set(data, this._blockPos);\n        }\n        p += nb;\n        this._blockPos += nb;\n        if (this._blockPos < this._block.length) return;\n        let decrypted;\n        let need;\n        if (this._macETM) {\n          this._len = need = readUInt32BE(this._block, 0);\n        } else {\n          // Decrypt first block to get packet length\n          decrypted = this._decipherInstance.update(this._block);\n          this._len = readUInt32BE(decrypted, 0);\n          need = 4 + this._len - this._blockSize;\n        }\n        if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {\n          throw new Error('Bad packet length');\n        }\n\n        // Create MAC up front to calculate in parallel with decryption\n        this._macInstance = createHmac(this._macSSLName, this._macKey);\n        writeUInt32BE(BUF_INT, this.inSeqno, 0);\n        this._macInstance.update(BUF_INT);\n        if (this._macETM) {\n          this._macInstance.update(this._block);\n        } else {\n          this._macInstance.update(new Uint8Array(decrypted.buffer, decrypted.byteOffset, 4));\n          this._pktLen = decrypted.length - 4;\n          this._packetPos = this._pktLen;\n          this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(new Uint8Array(decrypted.buffer, decrypted.byteOffset + 4, this._packetPos), 0);\n        }\n        if (p >= dataLen) return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n        if (this._macETM) this._macInstance.update(encrypted);\n        const decrypted = this._decipherInstance.update(encrypted);\n        if (decrypted.length) {\n          if (nb === this._len) {\n            this._packet = decrypted;\n          } else {\n            if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n            this._packet.set(decrypted, this._packetPos);\n          }\n          this._packetPos += decrypted.length;\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      }\n\n      // Read MAC\n      {\n        const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < this._macActualLen) return;\n      }\n\n      // Verify MAC\n      if (!this._macETM) this._macInstance.update(this._packet);\n      let calculated = this._macInstance.digest();\n      if (this._macActualLen < calculated.length) {\n        calculated = new Uint8Array(calculated.buffer, calculated.byteOffset, this._macActualLen);\n      }\n      if (!timingSafeEquals(calculated, this._mac)) throw new Error('Invalid MAC');\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._blockPos = 0;\n      this._len = 0;\n      this._packet = null;\n      this._packetPos = 0;\n      this._pktLen = 0;\n      this._macPos = 0;\n      this._macInstance = null;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\nclass GenericDecipherBinding {\n  constructor(config) {\n    const dec = config.inbound;\n    this.inSeqno = dec.seqno;\n    this._onPayload = dec.onPayload;\n    this._instance = new GenericDecipher(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV, dec.macInfo.sslName, dec.macKey, dec.macInfo.isETM, dec.macInfo.actualLen);\n    this._block = Buffer.allocUnsafe(dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen);\n    this._blockPos = 0;\n    this._len = 0;\n    this._packet = null;\n    this._pktLen = 0;\n    this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);\n    this._macPos = 0;\n    this._macActualLen = dec.macInfo.actualLen;\n    this._macETM = dec.macInfo.isETM;\n  }\n  free() {\n    this._instance.free();\n  }\n  decrypt(data, p, dataLen) {\n    // `data` === encrypted data\n\n    while (p < dataLen) {\n      // Read first encrypted block\n      if (this._blockPos < this._block.length) {\n        const nb = Math.min(this._block.length - this._blockPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen || nb < data.length) {\n          this._block.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._blockPos);\n        } else {\n          this._block.set(data, this._blockPos);\n        }\n        p += nb;\n        this._blockPos += nb;\n        if (this._blockPos < this._block.length) return;\n        let need;\n        if (this._macETM) {\n          this._len = need = readUInt32BE(this._block, 0);\n        } else {\n          // Decrypt first block to get packet length\n          this._instance.decryptBlock(this._block);\n          this._len = readUInt32BE(this._block, 0);\n          need = 4 + this._len - this._block.length;\n        }\n        if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {\n          throw new Error('Bad packet length');\n        }\n        if (!this._macETM) {\n          this._pktLen = this._block.length - 4;\n          if (this._pktLen) {\n            this._packet = Buffer.allocUnsafe(this._len);\n            this._packet.set(new Uint8Array(this._block.buffer, this._block.byteOffset + 4, this._pktLen), 0);\n          }\n        }\n        if (p >= dataLen) return;\n      }\n\n      // Read padding length, payload, and padding\n      if (this._pktLen < this._len) {\n        const nb = Math.min(this._len - this._pktLen, dataLen - p);\n        let encrypted;\n        if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);else encrypted = data;\n        if (nb === this._len) {\n          this._packet = encrypted;\n        } else {\n          if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);\n          this._packet.set(encrypted, this._pktLen);\n        }\n        p += nb;\n        this._pktLen += nb;\n        if (this._pktLen < this._len || p >= dataLen) return;\n      }\n\n      // Read MAC\n      {\n        const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);\n        if (p !== 0 || nb !== dataLen) {\n          this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);\n        } else {\n          this._mac.set(data, this._macPos);\n        }\n        p += nb;\n        this._macPos += nb;\n        if (this._macPos < this._macActualLen) return;\n      }\n\n      // Decrypt and verify MAC\n      this._instance.decrypt(this._packet, this.inSeqno, this._block, this._mac);\n      const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);\n\n      // Prepare for next packet\n      this.inSeqno = this.inSeqno + 1 >>> 0;\n      this._blockPos = 0;\n      this._len = 0;\n      this._packet = null;\n      this._pktLen = 0;\n      this._macPos = 0;\n      this._macInstance = null;\n      {\n        const ret = this._onPayload(payload);\n        if (ret !== undefined) return ret === false ? p : ret;\n      }\n    }\n  }\n}\n\n// Increments unsigned, big endian counter (last 8 bytes) of AES-GCM IV\nfunction ivIncrement(iv) {\n  // eslint-disable-next-line no-unused-expressions\n  ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;\n}\nconst intToBytes = (() => {\n  const ret = Buffer.alloc(4);\n  return n => {\n    ret[0] = n >>> 24;\n    ret[1] = n >>> 16;\n    ret[2] = n >>> 8;\n    ret[3] = n;\n    return ret;\n  };\n})();\nfunction timingSafeEquals(a, b) {\n  if (a.length !== b.length) {\n    timingSafeEqual(a, a);\n    return false;\n  }\n  return timingSafeEqual(a, b);\n}\nfunction createCipher(config) {\n  if (typeof config !== 'object' || config === null) throw new Error('Invalid config');\n  if (typeof config.outbound !== 'object' || config.outbound === null) throw new Error('Invalid outbound');\n  const outbound = config.outbound;\n  if (typeof outbound.onWrite !== 'function') throw new Error('Invalid outbound.onWrite');\n  if (typeof outbound.cipherInfo !== 'object' || outbound.cipherInfo === null) throw new Error('Invalid outbound.cipherInfo');\n  if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {\n    throw new Error('Invalid outbound.cipherKey');\n  }\n  if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {\n    throw new Error('Invalid outbound.cipherIV');\n  }\n  if (typeof outbound.seqno !== 'number' || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {\n    throw new Error('Invalid outbound.seqno');\n  }\n  const forceNative = !!outbound.forceNative;\n  switch (outbound.cipherInfo.sslName) {\n    case 'aes-128-gcm':\n    case 'aes-256-gcm':\n      return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);\n    case 'chacha20':\n      return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);\n    default:\n      {\n        if (typeof outbound.macInfo !== 'object' || outbound.macInfo === null) throw new Error('Invalid outbound.macInfo');\n        if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {\n          throw new Error('Invalid outbound.macKey');\n        }\n        return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);\n      }\n  }\n}\nfunction createDecipher(config) {\n  if (typeof config !== 'object' || config === null) throw new Error('Invalid config');\n  if (typeof config.inbound !== 'object' || config.inbound === null) throw new Error('Invalid inbound');\n  const inbound = config.inbound;\n  if (typeof inbound.onPayload !== 'function') throw new Error('Invalid inbound.onPayload');\n  if (typeof inbound.decipherInfo !== 'object' || inbound.decipherInfo === null) {\n    throw new Error('Invalid inbound.decipherInfo');\n  }\n  if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {\n    throw new Error('Invalid inbound.decipherKey');\n  }\n  if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {\n    throw new Error('Invalid inbound.decipherIV');\n  }\n  if (typeof inbound.seqno !== 'number' || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {\n    throw new Error('Invalid inbound.seqno');\n  }\n  const forceNative = !!inbound.forceNative;\n  switch (inbound.decipherInfo.sslName) {\n    case 'aes-128-gcm':\n    case 'aes-256-gcm':\n      return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);\n    case 'chacha20':\n      return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);\n    default:\n      {\n        if (typeof inbound.macInfo !== 'object' || inbound.macInfo === null) throw new Error('Invalid inbound.macInfo');\n        if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {\n          throw new Error('Invalid inbound.macKey');\n        }\n        return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);\n      }\n  }\n}\nmodule.exports = {\n  CIPHER_INFO,\n  MAC_INFO,\n  bindingAvailable: !!binding,\n  init: (() => {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        POLY1305_WASM_MODULE = await require('./crypto/poly1305.js')();\n        POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);\n        poly1305_auth = POLY1305_WASM_MODULE.cwrap('poly1305_auth', null, ['number', 'array', 'number', 'array', 'number', 'array']);\n      } catch (ex) {\n        return reject(ex);\n      }\n      resolve();\n    });\n  })(),\n  NullCipher,\n  createCipher,\n  NullDecipher,\n  createDecipher\n};","module.exports = __non_webpack_require__(__webpack_require__.ab + \"lib/protocol/crypto/build/Release/sshcrypto.node\")","var createPoly1305 = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;\n  return function (createPoly1305) {\n    createPoly1305 = createPoly1305 || {};\n    var b;\n    b || (b = typeof createPoly1305 !== 'undefined' ? createPoly1305 : {});\n    var q, r;\n    b.ready = new Promise(function (a, c) {\n      q = a;\n      r = c;\n    });\n    var u = {},\n      w;\n    for (w in b) b.hasOwnProperty(w) && (u[w] = b[w]);\n    var x = \"object\" === typeof window,\n      y = \"function\" === typeof importScripts,\n      z = \"object\" === typeof process && \"object\" === typeof process.versions && \"string\" === typeof process.versions.node,\n      B = \"\",\n      C,\n      D,\n      E,\n      F,\n      G;\n    if (z) B = y ? require(\"path\").dirname(B) + \"/\" : __dirname + \"/\", C = function (a, c) {\n      var d = H(a);\n      if (d) return c ? d : d.toString();\n      F || (F = require(\"fs\"));\n      G || (G = require(\"path\"));\n      a = G.normalize(a);\n      return F.readFileSync(a, c ? null : \"utf8\");\n    }, E = function (a) {\n      a = C(a, !0);\n      a.buffer || (a = new Uint8Array(a));\n      assert(a.buffer);\n      return a;\n    }, D = function (a, c, d) {\n      var e = H(a);\n      e && c(e);\n      F || (F = require(\"fs\"));\n      G || (G = require(\"path\"));\n      a = G.normalize(a);\n      F.readFile(a, function (f, l) {\n        f ? d(f) : c(l.buffer);\n      });\n    }, 1 < process.argv.length && process.argv[1].replace(/\\\\/g, \"/\"), process.argv.slice(2), b.inspect = function () {\n      return \"[Emscripten Module object]\";\n    };else if (x || y) y ? B = self.location.href : \"undefined\" !== typeof document && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), 0 !== B.indexOf(\"blob:\") ? B = B.substr(0, B.lastIndexOf(\"/\") + 1) : B = \"\", C = function (a) {\n      try {\n        var c = new XMLHttpRequest();\n        c.open(\"GET\", a, !1);\n        c.send(null);\n        return c.responseText;\n      } catch (f) {\n        if (a = H(a)) {\n          c = [];\n          for (var d = 0; d < a.length; d++) {\n            var e = a[d];\n            255 < e && (ba && assert(!1, \"Character code \" + e + \" (\" + String.fromCharCode(e) + \")  at offset \" + d + \" not in 0x00-0xFF.\"), e &= 255);\n            c.push(String.fromCharCode(e));\n          }\n          return c.join(\"\");\n        }\n        throw f;\n      }\n    }, y && (E = function (a) {\n      try {\n        var c = new XMLHttpRequest();\n        c.open(\"GET\", a, !1);\n        c.responseType = \"arraybuffer\";\n        c.send(null);\n        return new Uint8Array(c.response);\n      } catch (d) {\n        if (a = H(a)) return a;\n        throw d;\n      }\n    }), D = function (a, c, d) {\n      var e = new XMLHttpRequest();\n      e.open(\"GET\", a, !0);\n      e.responseType = \"arraybuffer\";\n      e.onload = function () {\n        if (200 == e.status || 0 == e.status && e.response) c(e.response);else {\n          var f = H(a);\n          f ? c(f.buffer) : d();\n        }\n      };\n      e.onerror = d;\n      e.send(null);\n    };\n    b.print || console.log.bind(console);\n    var I = b.printErr || console.warn.bind(console);\n    for (w in u) u.hasOwnProperty(w) && (b[w] = u[w]);\n    u = null;\n    var J;\n    b.wasmBinary && (J = b.wasmBinary);\n    var noExitRuntime = b.noExitRuntime || !0;\n    \"object\" !== typeof WebAssembly && K(\"no native wasm support detected\");\n    var L,\n      M = !1;\n    function assert(a, c) {\n      a || K(\"Assertion failed: \" + c);\n    }\n    function N(a) {\n      var c = b[\"_\" + a];\n      assert(c, \"Cannot call unknown function \" + a + \", make sure it is exported\");\n      return c;\n    }\n    function ca(a, c, d, e) {\n      var f = {\n          string: function (g) {\n            var p = 0;\n            if (null !== g && void 0 !== g && 0 !== g) {\n              var n = (g.length << 2) + 1;\n              p = O(n);\n              var k = p,\n                h = P;\n              if (0 < n) {\n                n = k + n - 1;\n                for (var v = 0; v < g.length; ++v) {\n                  var m = g.charCodeAt(v);\n                  if (55296 <= m && 57343 >= m) {\n                    var oa = g.charCodeAt(++v);\n                    m = 65536 + ((m & 1023) << 10) | oa & 1023;\n                  }\n                  if (127 >= m) {\n                    if (k >= n) break;\n                    h[k++] = m;\n                  } else {\n                    if (2047 >= m) {\n                      if (k + 1 >= n) break;\n                      h[k++] = 192 | m >> 6;\n                    } else {\n                      if (65535 >= m) {\n                        if (k + 2 >= n) break;\n                        h[k++] = 224 | m >> 12;\n                      } else {\n                        if (k + 3 >= n) break;\n                        h[k++] = 240 | m >> 18;\n                        h[k++] = 128 | m >> 12 & 63;\n                      }\n                      h[k++] = 128 | m >> 6 & 63;\n                    }\n                    h[k++] = 128 | m & 63;\n                  }\n                }\n                h[k] = 0;\n              }\n            }\n            return p;\n          },\n          array: function (g) {\n            var p = O(g.length);\n            Q.set(g, p);\n            return p;\n          }\n        },\n        l = N(a),\n        A = [];\n      a = 0;\n      if (e) for (var t = 0; t < e.length; t++) {\n        var aa = f[d[t]];\n        aa ? (0 === a && (a = da()), A[t] = aa(e[t])) : A[t] = e[t];\n      }\n      d = l.apply(null, A);\n      d = function (g) {\n        if (\"string\" === c) {\n          if (g) {\n            for (var p = P, n = g + NaN, k = g; p[k] && !(k >= n);) ++k;\n            if (16 < k - g && p.subarray && ea) g = ea.decode(p.subarray(g, k));else {\n              for (n = \"\"; g < k;) {\n                var h = p[g++];\n                if (h & 128) {\n                  var v = p[g++] & 63;\n                  if (192 == (h & 224)) n += String.fromCharCode((h & 31) << 6 | v);else {\n                    var m = p[g++] & 63;\n                    h = 224 == (h & 240) ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63;\n                    65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));\n                  }\n                } else n += String.fromCharCode(h);\n              }\n              g = n;\n            }\n          } else g = \"\";\n        } else g = \"boolean\" === c ? !!g : g;\n        return g;\n      }(d);\n      0 !== a && fa(a);\n      return d;\n    }\n    var ea = \"undefined\" !== typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0,\n      ha,\n      Q,\n      P;\n    function ia() {\n      var a = L.buffer;\n      ha = a;\n      b.HEAP8 = Q = new Int8Array(a);\n      b.HEAP16 = new Int16Array(a);\n      b.HEAP32 = new Int32Array(a);\n      b.HEAPU8 = P = new Uint8Array(a);\n      b.HEAPU16 = new Uint16Array(a);\n      b.HEAPU32 = new Uint32Array(a);\n      b.HEAPF32 = new Float32Array(a);\n      b.HEAPF64 = new Float64Array(a);\n    }\n    var R,\n      ja = [],\n      ka = [],\n      la = [];\n    function ma() {\n      var a = b.preRun.shift();\n      ja.unshift(a);\n    }\n    var S = 0,\n      T = null,\n      U = null;\n    b.preloadedImages = {};\n    b.preloadedAudios = {};\n    function K(a) {\n      if (b.onAbort) b.onAbort(a);\n      I(a);\n      M = !0;\n      a = new WebAssembly.RuntimeError(\"abort(\" + a + \"). Build with -s ASSERTIONS=1 for more info.\");\n      r(a);\n      throw a;\n    }\n    var V = \"data:application/octet-stream;base64,\",\n      W;\n    W = \"data:application/octet-stream;base64,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\";\n    if (!W.startsWith(V)) {\n      var na = W;\n      W = b.locateFile ? b.locateFile(na, B) : B + na;\n    }\n    function pa() {\n      var a = W;\n      try {\n        if (a == W && J) return new Uint8Array(J);\n        var c = H(a);\n        if (c) return c;\n        if (E) return E(a);\n        throw \"both async and sync fetching of the wasm failed\";\n      } catch (d) {\n        K(d);\n      }\n    }\n    function qa() {\n      if (!J && (x || y)) {\n        if (\"function\" === typeof fetch && !W.startsWith(\"file://\")) return fetch(W, {\n          credentials: \"same-origin\"\n        }).then(function (a) {\n          if (!a.ok) throw \"failed to load wasm binary file at '\" + W + \"'\";\n          return a.arrayBuffer();\n        }).catch(function () {\n          return pa();\n        });\n        if (D) return new Promise(function (a, c) {\n          D(W, function (d) {\n            a(new Uint8Array(d));\n          }, c);\n        });\n      }\n      return Promise.resolve().then(function () {\n        return pa();\n      });\n    }\n    function X(a) {\n      for (; 0 < a.length;) {\n        var c = a.shift();\n        if (\"function\" == typeof c) c(b);else {\n          var d = c.m;\n          \"number\" === typeof d ? void 0 === c.l ? R.get(d)() : R.get(d)(c.l) : d(void 0 === c.l ? null : c.l);\n        }\n      }\n    }\n    var ba = !1,\n      ra = \"function\" === typeof atob ? atob : function (a) {\n        var c = \"\",\n          d = 0;\n        a = a.replace(/[^A-Za-z0-9\\+\\/=]/g, \"\");\n        do {\n          var e = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));\n          var f = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));\n          var l = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));\n          var A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));\n          e = e << 2 | f >> 4;\n          f = (f & 15) << 4 | l >> 2;\n          var t = (l & 3) << 6 | A;\n          c += String.fromCharCode(e);\n          64 !== l && (c += String.fromCharCode(f));\n          64 !== A && (c += String.fromCharCode(t));\n        } while (d < a.length);\n        return c;\n      };\n    function H(a) {\n      if (a.startsWith(V)) {\n        a = a.slice(V.length);\n        if (\"boolean\" === typeof z && z) {\n          var c = Buffer.from(a, \"base64\");\n          c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);\n        } else try {\n          var d = ra(a),\n            e = new Uint8Array(d.length);\n          for (a = 0; a < d.length; ++a) e[a] = d.charCodeAt(a);\n          c = e;\n        } catch (f) {\n          throw Error(\"Converting base64 string to bytes failed.\");\n        }\n        return c;\n      }\n    }\n    var sa = {\n      a: function (a) {\n        var c = P.length;\n        a >>>= 0;\n        if (2147483648 < a) return !1;\n        for (var d = 1; 4 >= d; d *= 2) {\n          var e = c * (1 + .2 / d);\n          e = Math.min(e, a + 100663296);\n          e = Math.max(a, e);\n          0 < e % 65536 && (e += 65536 - e % 65536);\n          a: {\n            try {\n              L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16);\n              ia();\n              var f = 1;\n              break a;\n            } catch (l) {}\n            f = void 0;\n          }\n          if (f) return !0;\n        }\n        return !1;\n      }\n    };\n    (function () {\n      function a(f) {\n        b.asm = f.exports;\n        L = b.asm.b;\n        ia();\n        R = b.asm.j;\n        ka.unshift(b.asm.c);\n        S--;\n        b.monitorRunDependencies && b.monitorRunDependencies(S);\n        0 == S && (null !== T && (clearInterval(T), T = null), U && (f = U, U = null, f()));\n      }\n      function c(f) {\n        a(f.instance);\n      }\n      function d(f) {\n        return qa().then(function (l) {\n          return WebAssembly.instantiate(l, e);\n        }).then(f, function (l) {\n          I(\"failed to asynchronously prepare wasm: \" + l);\n          K(l);\n        });\n      }\n      var e = {\n        a: sa\n      };\n      S++;\n      b.monitorRunDependencies && b.monitorRunDependencies(S);\n      if (b.instantiateWasm) try {\n        return b.instantiateWasm(e, a);\n      } catch (f) {\n        return I(\"Module.instantiateWasm callback failed with error: \" + f), !1;\n      }\n      (function () {\n        return J || \"function\" !== typeof WebAssembly.instantiateStreaming || W.startsWith(V) || W.startsWith(\"file://\") || \"function\" !== typeof fetch ? d(c) : fetch(W, {\n          credentials: \"same-origin\"\n        }).then(function (f) {\n          return WebAssembly.instantiateStreaming(f, e).then(c, function (l) {\n            I(\"wasm streaming compile failed: \" + l);\n            I(\"falling back to ArrayBuffer instantiation\");\n            return d(c);\n          });\n        });\n      })().catch(r);\n      return {};\n    })();\n    b.___wasm_call_ctors = function () {\n      return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);\n    };\n    b._poly1305_auth = function () {\n      return (b._poly1305_auth = b.asm.d).apply(null, arguments);\n    };\n    var da = b.stackSave = function () {\n        return (da = b.stackSave = b.asm.e).apply(null, arguments);\n      },\n      fa = b.stackRestore = function () {\n        return (fa = b.stackRestore = b.asm.f).apply(null, arguments);\n      },\n      O = b.stackAlloc = function () {\n        return (O = b.stackAlloc = b.asm.g).apply(null, arguments);\n      };\n    b._malloc = function () {\n      return (b._malloc = b.asm.h).apply(null, arguments);\n    };\n    b._free = function () {\n      return (b._free = b.asm.i).apply(null, arguments);\n    };\n    b.cwrap = function (a, c, d, e) {\n      d = d || [];\n      var f = d.every(function (l) {\n        return \"number\" === l;\n      });\n      return \"string\" !== c && f && !e ? N(a) : function () {\n        return ca(a, c, d, arguments);\n      };\n    };\n    var Y;\n    U = function ta() {\n      Y || Z();\n      Y || (U = ta);\n    };\n    function Z() {\n      function a() {\n        if (!Y && (Y = !0, b.calledRun = !0, !M)) {\n          X(ka);\n          q(b);\n          if (b.onRuntimeInitialized) b.onRuntimeInitialized();\n          if (b.postRun) for (\"function\" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length;) {\n            var c = b.postRun.shift();\n            la.unshift(c);\n          }\n          X(la);\n        }\n      }\n      if (!(0 < S)) {\n        if (b.preRun) for (\"function\" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length;) ma();\n        X(ja);\n        0 < S || (b.setStatus ? (b.setStatus(\"Running...\"), setTimeout(function () {\n          setTimeout(function () {\n            b.setStatus(\"\");\n          }, 1);\n          a();\n        }, 1)) : a());\n      }\n    }\n    b.run = Z;\n    if (b.preInit) for (\"function\" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length;) b.preInit.pop()();\n    Z();\n    return createPoly1305.ready;\n  };\n}();\nif (typeof exports === 'object' && typeof module === 'object') module.exports = createPoly1305;else if (typeof define === 'function' && define['amd']) define([], function () {\n  return createPoly1305;\n});else if (typeof exports === 'object') exports[\"createPoly1305\"] = createPoly1305;","'use strict';\n\nconst MESSAGE_HANDLERS = new Array(256);\n[require('./kex.js').HANDLERS, require('./handlers.misc.js')].forEach(handlers => {\n  // eslint-disable-next-line prefer-const\n  for (let [type, handler] of Object.entries(handlers)) {\n    type = +type;\n    if (isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length) MESSAGE_HANDLERS[type] = handler;\n  }\n});\nmodule.exports = MESSAGE_HANDLERS;","'use strict';\n\nconst {\n  bufferSlice,\n  bufferParser,\n  doFatalError,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./utils.js');\nconst {\n  CHANNEL_OPEN_FAILURE,\n  COMPAT,\n  MESSAGE,\n  TERMINAL_MODE\n} = require('./constants.js');\nconst {\n  parseKey\n} = require('./keyParser.js');\nconst TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, [key, value]) => ({\n  ...obj,\n  [key]: value\n}), {});\nmodule.exports = {\n  // Transport layer protocol ==================================================\n  [MESSAGE.DISCONNECT]: (self, payload) => {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    bufferParser.init(payload, 1);\n    const reason = bufferParser.readUInt32BE();\n    const desc = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed DISCONNECT packet');\n    }\n    self._debug && self._debug(`Inbound: Received DISCONNECT (${reason}, \"${desc}\")`);\n    const handler = self._handlers.DISCONNECT;\n    handler && handler(self, reason, desc);\n  },\n  [MESSAGE.IGNORE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n    self._debug && self._debug('Inbound: Received IGNORE');\n  },\n  [MESSAGE.UNIMPLEMENTED]: (self, payload) => {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    bufferParser.init(payload, 1);\n    const seqno = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (seqno === undefined) {\n      return doFatalError(self, 'Inbound: Malformed UNIMPLEMENTED packet');\n    }\n    self._debug && self._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);\n  },\n  [MESSAGE.DEBUG]: (self, payload) => {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const display = bufferParser.readBool();\n    const msg = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed DEBUG packet');\n    }\n    self._debug && self._debug('Inbound: Received DEBUG');\n    const handler = self._handlers.DEBUG;\n    handler && handler(self, display, msg);\n  },\n  [MESSAGE.SERVICE_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    bufferParser.clear();\n    if (name === undefined) {\n      return doFatalError(self, 'Inbound: Malformed SERVICE_REQUEST packet');\n    }\n    self._debug && self._debug(`Inbound: Received SERVICE_REQUEST (${name})`);\n    const handler = self._handlers.SERVICE_REQUEST;\n    handler && handler(self, name);\n  },\n  [MESSAGE.SERVICE_ACCEPT]: (self, payload) => {\n    // S->C\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    bufferParser.clear();\n    if (name === undefined) {\n      return doFatalError(self, 'Inbound: Malformed SERVICE_ACCEPT packet');\n    }\n    self._debug && self._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);\n    const handler = self._handlers.SERVICE_ACCEPT;\n    handler && handler(self, name);\n  },\n  [MESSAGE.EXT_INFO]: (self, payload) => {\n    /*\n      byte       SSH_MSG_EXT_INFO\n      uint32     nr-extensions\n      repeat the following 2 fields \"nr-extensions\" times:\n        string   extension-name\n        string   extension-value (binary)\n    */\n    bufferParser.init(payload, 1);\n    const numExts = bufferParser.readUInt32BE();\n    let exts;\n    if (numExts !== undefined) {\n      exts = [];\n      for (let i = 0; i < numExts; ++i) {\n        const name = bufferParser.readString(true);\n        const data = bufferParser.readString();\n        if (data !== undefined) {\n          switch (name) {\n            case 'server-sig-algs':\n              {\n                const algs = data.latin1Slice(0, data.length).split(',');\n                exts.push({\n                  name,\n                  algs\n                });\n                continue;\n              }\n            default:\n              continue;\n          }\n        }\n        // Malformed\n        exts = undefined;\n        break;\n      }\n    }\n    bufferParser.clear();\n    if (exts === undefined) return doFatalError(self, 'Inbound: Malformed EXT_INFO packet');\n    self._debug && self._debug('Inbound: Received EXT_INFO');\n    const handler = self._handlers.EXT_INFO;\n    handler && handler(self, exts);\n  },\n  // User auth protocol -- generic =============================================\n  [MESSAGE.USERAUTH_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    bufferParser.init(payload, 1);\n    const user = bufferParser.readString(true);\n    const service = bufferParser.readString(true);\n    const method = bufferParser.readString(true);\n    let methodData;\n    let methodDesc;\n    switch (method) {\n      case 'none':\n        methodData = null;\n        break;\n      case 'password':\n        {\n          /*\n            boolean   <new password follows (old) plaintext password?>\n            string    plaintext password in ISO-10646 UTF-8 encoding [RFC3629]\n           [string    new password]\n          */\n          const isChange = bufferParser.readBool();\n          if (isChange !== undefined) {\n            methodData = bufferParser.readString(true);\n            if (methodData !== undefined && isChange) {\n              const newPassword = bufferParser.readString(true);\n              if (newPassword !== undefined) methodData = {\n                oldPassword: methodData,\n                newPassword\n              };else methodData = undefined;\n            }\n          }\n          break;\n        }\n      case 'publickey':\n        {\n          /*\n            boolean   <signature follows public key blob?>\n            string    public key algorithm name\n            string    public key blob\n           [string    signature]\n          */\n          const hasSig = bufferParser.readBool();\n          if (hasSig !== undefined) {\n            const keyAlgo = bufferParser.readString(true);\n            let realKeyAlgo = keyAlgo;\n            const key = bufferParser.readString();\n            let hashAlgo;\n            switch (keyAlgo) {\n              case 'rsa-sha2-256':\n                realKeyAlgo = 'ssh-rsa';\n                hashAlgo = 'sha256';\n                break;\n              case 'rsa-sha2-512':\n                realKeyAlgo = 'ssh-rsa';\n                hashAlgo = 'sha512';\n                break;\n            }\n            if (hasSig) {\n              const blobEnd = bufferParser.pos();\n              let signature = bufferParser.readString();\n              if (signature !== undefined) {\n                if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {\n                  // Skip algoLen + algo + sigLen\n                  signature = bufferSlice(signature, 4 + keyAlgo.length + 4);\n                }\n                signature = sigSSHToASN1(signature, realKeyAlgo);\n                if (signature) {\n                  const sessionID = self._kex.sessionID;\n                  const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);\n                  writeUInt32BE(blob, sessionID.length, 0);\n                  blob.set(sessionID, 4);\n                  blob.set(new Uint8Array(payload.buffer, payload.byteOffset, blobEnd), 4 + sessionID.length);\n                  methodData = {\n                    keyAlgo: realKeyAlgo,\n                    key,\n                    signature,\n                    blob,\n                    hashAlgo\n                  };\n                }\n              }\n            } else {\n              methodData = {\n                keyAlgo: realKeyAlgo,\n                key,\n                hashAlgo\n              };\n              methodDesc = 'publickey -- check';\n            }\n          }\n          break;\n        }\n      case 'hostbased':\n        {\n          /*\n            string    public key algorithm for host key\n            string    public host key and certificates for client host\n            string    client host name expressed as the FQDN in US-ASCII\n            string    user name on the client host in ISO-10646 UTF-8 encoding\n                       [RFC3629]\n            string    signature\n          */\n          const keyAlgo = bufferParser.readString(true);\n          let realKeyAlgo = keyAlgo;\n          const key = bufferParser.readString();\n          const localHostname = bufferParser.readString(true);\n          const localUsername = bufferParser.readString(true);\n          let hashAlgo;\n          switch (keyAlgo) {\n            case 'rsa-sha2-256':\n              realKeyAlgo = 'ssh-rsa';\n              hashAlgo = 'sha256';\n              break;\n            case 'rsa-sha2-512':\n              realKeyAlgo = 'ssh-rsa';\n              hashAlgo = 'sha512';\n              break;\n          }\n          const blobEnd = bufferParser.pos();\n          let signature = bufferParser.readString();\n          if (signature !== undefined) {\n            if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {\n              // Skip algoLen + algo + sigLen\n              signature = bufferSlice(signature, 4 + keyAlgo.length + 4);\n            }\n            signature = sigSSHToASN1(signature, realKeyAlgo);\n            if (signature !== undefined) {\n              const sessionID = self._kex.sessionID;\n              const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);\n              writeUInt32BE(blob, sessionID.length, 0);\n              blob.set(sessionID, 4);\n              blob.set(new Uint8Array(payload.buffer, payload.byteOffset, blobEnd), 4 + sessionID.length);\n              methodData = {\n                keyAlgo: realKeyAlgo,\n                key,\n                signature,\n                blob,\n                localHostname,\n                localUsername,\n                hashAlgo\n              };\n            }\n          }\n          break;\n        }\n      case 'keyboard-interactive':\n        /*\n          string    language tag (as defined in [RFC-3066])\n          string    submethods (ISO-10646 UTF-8)\n        */\n        // Skip/ignore language field -- it's deprecated in RFC 4256\n        bufferParser.skipString();\n        methodData = bufferParser.readList();\n        break;\n      default:\n        if (method !== undefined) methodData = bufferParser.readRaw();\n    }\n    bufferParser.clear();\n    if (methodData === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_REQUEST packet');\n    }\n    if (methodDesc === undefined) methodDesc = method;\n    self._authsQueue.push(method);\n    self._debug && self._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);\n    const handler = self._handlers.USERAUTH_REQUEST;\n    handler && handler(self, user, service, method, methodData);\n  },\n  [MESSAGE.USERAUTH_FAILURE]: (self, payload) => {\n    // S->C\n    /*\n      byte         SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    bufferParser.init(payload, 1);\n    const authMethods = bufferParser.readList();\n    const partialSuccess = bufferParser.readBool();\n    bufferParser.clear();\n    if (partialSuccess === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_FAILURE packet');\n    }\n    self._debug && self._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);\n    self._authsQueue.shift();\n    const handler = self._handlers.USERAUTH_FAILURE;\n    handler && handler(self, authMethods, partialSuccess);\n  },\n  [MESSAGE.USERAUTH_SUCCESS]: (self, payload) => {\n    // S->C\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    self._debug && self._debug('Inbound: Received USERAUTH_SUCCESS');\n    self._authsQueue.shift();\n    const handler = self._handlers.USERAUTH_SUCCESS;\n    handler && handler(self);\n  },\n  [MESSAGE.USERAUTH_BANNER]: (self, payload) => {\n    // S->C\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const msg = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_BANNER packet');\n    }\n    self._debug && self._debug('Inbound: Received USERAUTH_BANNER');\n    const handler = self._handlers.USERAUTH_BANNER;\n    handler && handler(self, msg);\n  },\n  // User auth protocol -- method-specific =====================================\n  60: (self, payload) => {\n    if (!self._authsQueue.length) {\n      self._debug && self._debug('Inbound: Received payload type 60 without auth');\n      return;\n    }\n    switch (self._authsQueue[0]) {\n      case 'password':\n        {\n          // S->C\n          /*\n            byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n            string    prompt in ISO-10646 UTF-8 encoding [RFC3629]\n            string    language tag [RFC3066]\n          */\n          bufferParser.init(payload, 1);\n          const prompt = bufferParser.readString(true);\n          const lang = bufferParser.readString();\n          bufferParser.clear();\n          if (lang === undefined) {\n            return doFatalError(self, 'Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet');\n          }\n          self._debug && self._debug('Inbound: Received USERAUTH_PASSWD_CHANGEREQ');\n          const handler = self._handlers.USERAUTH_PASSWD_CHANGEREQ;\n          handler && handler(self, prompt);\n          break;\n        }\n      case 'publickey':\n        {\n          // S->C\n          /*\n            byte      SSH_MSG_USERAUTH_PK_OK\n            string    public key algorithm name from the request\n            string    public key blob from the request\n          */\n          bufferParser.init(payload, 1);\n          const keyAlgo = bufferParser.readString(true);\n          const key = bufferParser.readString();\n          bufferParser.clear();\n          if (key === undefined) {\n            return doFatalError(self, 'Inbound: Malformed USERAUTH_PK_OK packet');\n          }\n          self._debug && self._debug('Inbound: Received USERAUTH_PK_OK');\n          self._authsQueue.shift();\n          const handler = self._handlers.USERAUTH_PK_OK;\n          handler && handler(self, keyAlgo, key);\n          break;\n        }\n      case 'keyboard-interactive':\n        {\n          // S->C\n          /*\n            byte      SSH_MSG_USERAUTH_INFO_REQUEST\n            string    name (ISO-10646 UTF-8)\n            string    instruction (ISO-10646 UTF-8)\n            string    language tag (as defined in [RFC-3066])\n            int       num-prompts\n            string    prompt[1] (ISO-10646 UTF-8)\n            boolean   echo[1]\n            ...\n            string    prompt[num-prompts] (ISO-10646 UTF-8)\n            boolean   echo[num-prompts]\n          */\n          bufferParser.init(payload, 1);\n          const name = bufferParser.readString(true);\n          const instructions = bufferParser.readString(true);\n          bufferParser.readString(); // skip lang\n          const numPrompts = bufferParser.readUInt32BE();\n          let prompts;\n          if (numPrompts !== undefined) {\n            prompts = new Array(numPrompts);\n            let i;\n            for (i = 0; i < numPrompts; ++i) {\n              const prompt = bufferParser.readString(true);\n              const echo = bufferParser.readBool();\n              if (echo === undefined) break;\n              prompts[i] = {\n                prompt,\n                echo\n              };\n            }\n            if (i !== numPrompts) prompts = undefined;\n          }\n          bufferParser.clear();\n          if (prompts === undefined) {\n            return doFatalError(self, 'Inbound: Malformed USERAUTH_INFO_REQUEST packet');\n          }\n          self._debug && self._debug('Inbound: Received USERAUTH_INFO_REQUEST');\n          const handler = self._handlers.USERAUTH_INFO_REQUEST;\n          handler && handler(self, name, instructions, prompts);\n          break;\n        }\n      default:\n        self._debug && self._debug('Inbound: Received unexpected payload type 60');\n    }\n  },\n  61: (self, payload) => {\n    if (!self._authsQueue.length) {\n      self._debug && self._debug('Inbound: Received payload type 61 without auth');\n      return;\n    }\n    /*\n      byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n      int       num-responses\n      string    response[1] (ISO-10646 UTF-8)\n      ...\n      string    response[num-responses] (ISO-10646 UTF-8)\n    */\n    if (self._authsQueue[0] !== 'keyboard-interactive') {\n      return doFatalError(self, 'Inbound: Received unexpected payload type 61');\n    }\n    bufferParser.init(payload, 1);\n    const numResponses = bufferParser.readUInt32BE();\n    let responses;\n    if (numResponses !== undefined) {\n      responses = new Array(numResponses);\n      let i;\n      for (i = 0; i < numResponses; ++i) {\n        const response = bufferParser.readString(true);\n        if (response === undefined) break;\n        responses[i] = response;\n      }\n      if (i !== numResponses) responses = undefined;\n    }\n    bufferParser.clear();\n    if (responses === undefined) {\n      return doFatalError(self, 'Inbound: Malformed USERAUTH_INFO_RESPONSE packet');\n    }\n    self._debug && self._debug('Inbound: Received USERAUTH_INFO_RESPONSE');\n    const handler = self._handlers.USERAUTH_INFO_RESPONSE;\n    handler && handler(self, responses);\n  },\n  // Connection protocol -- generic ============================================\n  [MESSAGE.GLOBAL_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const name = bufferParser.readString(true);\n    const wantReply = bufferParser.readBool();\n    let data;\n    if (wantReply !== undefined) {\n      switch (name) {\n        case 'tcpip-forward':\n        case 'cancel-tcpip-forward':\n          {\n            /*\n              string    address to bind (e.g., \"0.0.0.0\")\n              uint32    port number to bind\n            */\n            const bindAddr = bufferParser.readString(true);\n            const bindPort = bufferParser.readUInt32BE();\n            if (bindPort !== undefined) data = {\n              bindAddr,\n              bindPort\n            };\n            break;\n          }\n        case 'streamlocal-forward@openssh.com':\n        case 'cancel-streamlocal-forward@openssh.com':\n          {\n            /*\n              string    socket path\n            */\n            const socketPath = bufferParser.readString(true);\n            if (socketPath !== undefined) data = {\n              socketPath\n            };\n            break;\n          }\n        case 'no-more-sessions@openssh.com':\n          data = null;\n          break;\n        case 'hostkeys-00@openssh.com':\n          {\n            data = [];\n            while (bufferParser.avail() > 0) {\n              const keyRaw = bufferParser.readString();\n              if (keyRaw === undefined) {\n                data = undefined;\n                break;\n              }\n              const key = parseKey(keyRaw);\n              if (!(key instanceof Error)) data.push(key);\n            }\n            break;\n          }\n        default:\n          data = bufferParser.readRaw();\n      }\n    }\n    bufferParser.clear();\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed GLOBAL_REQUEST packet');\n    }\n    self._debug && self._debug(`Inbound: GLOBAL_REQUEST (${name})`);\n    const handler = self._handlers.GLOBAL_REQUEST;\n    if (handler) handler(self, name, wantReply, data);else self.requestFailure(); // Auto reject\n  },\n  [MESSAGE.REQUEST_SUCCESS]: (self, payload) => {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....     response specific data\n    */\n    const data = payload.length > 1 ? bufferSlice(payload, 1) : null;\n    self._debug && self._debug('Inbound: REQUEST_SUCCESS');\n    const handler = self._handlers.REQUEST_SUCCESS;\n    handler && handler(self, data);\n  },\n  [MESSAGE.REQUEST_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self._debug && self._debug('Inbound: Received REQUEST_FAILURE');\n    const handler = self._handlers.REQUEST_FAILURE;\n    handler && handler(self);\n  },\n  // Connection protocol -- channel-related ====================================\n  [MESSAGE.CHANNEL_OPEN]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const type = bufferParser.readString(true);\n    const sender = bufferParser.readUInt32BE();\n    const window = bufferParser.readUInt32BE();\n    const packetSize = bufferParser.readUInt32BE();\n    let channelInfo;\n    switch (type) {\n      case 'forwarded-tcpip': // S->C\n      case 'direct-tcpip':\n        {\n          // C->S\n          /*\n            string    address that was connected / host to connect\n            uint32    port that was connected / port to connect\n            string    originator IP address\n            uint32    originator port\n          */\n          const destIP = bufferParser.readString(true);\n          const destPort = bufferParser.readUInt32BE();\n          const srcIP = bufferParser.readString(true);\n          const srcPort = bufferParser.readUInt32BE();\n          if (srcPort !== undefined) {\n            channelInfo = {\n              type,\n              sender,\n              window,\n              packetSize,\n              data: {\n                destIP,\n                destPort,\n                srcIP,\n                srcPort\n              }\n            };\n          }\n          break;\n        }\n      case 'forwarded-streamlocal@openssh.com': // S->C\n      case 'direct-streamlocal@openssh.com':\n        {\n          // C->S\n          /*\n            string    socket path\n            string    reserved for future use\n             (direct-streamlocal@openssh.com additionally has:)\n            uint32    reserved\n          */\n          const socketPath = bufferParser.readString(true);\n          if (socketPath !== undefined) {\n            channelInfo = {\n              type,\n              sender,\n              window,\n              packetSize,\n              data: {\n                socketPath\n              }\n            };\n          }\n          break;\n        }\n      case 'x11':\n        {\n          // S->C\n          /*\n            string    originator address (e.g., \"192.168.7.38\")\n            uint32    originator port\n          */\n          const srcIP = bufferParser.readString(true);\n          const srcPort = bufferParser.readUInt32BE();\n          if (srcPort !== undefined) {\n            channelInfo = {\n              type,\n              sender,\n              window,\n              packetSize,\n              data: {\n                srcIP,\n                srcPort\n              }\n            };\n          }\n          break;\n        }\n      default:\n        // Includes:\n        //   'session' (C->S)\n        //   'auth-agent@openssh.com' (S->C)\n        channelInfo = {\n          type,\n          sender,\n          window,\n          packetSize,\n          data: {}\n        };\n    }\n    bufferParser.clear();\n    if (channelInfo === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_OPEN packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);\n    const handler = self._handlers.CHANNEL_OPEN;\n    if (handler) {\n      handler(self, channelInfo);\n    } else {\n      self.channelOpenFail(channelInfo.sender, CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED, '', '');\n    }\n  },\n  [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const sender = bufferParser.readUInt32BE();\n    const window = bufferParser.readUInt32BE();\n    const packetSize = bufferParser.readUInt32BE();\n    const data = bufferParser.avail() ? bufferParser.readRaw() : undefined;\n    bufferParser.clear();\n    if (packetSize === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`);\n    const handler = self._handlers.CHANNEL_OPEN_CONFIRMATION;\n    if (handler) handler(self, {\n      recipient,\n      sender,\n      window,\n      packetSize,\n      data\n    });\n  },\n  [MESSAGE.CHANNEL_OPEN_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding [RFC3629]\n      string    language tag [RFC3066]\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const reason = bufferParser.readUInt32BE();\n    const description = bufferParser.readString(true);\n    const lang = bufferParser.readString();\n    bufferParser.clear();\n    if (lang === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_OPEN_FAILURE packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_OPEN_FAILURE;\n    handler && handler(self, recipient, reason, description);\n  },\n  [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const bytesToAdd = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (bytesToAdd === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_WINDOW_ADJUST packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`);\n    const handler = self._handlers.CHANNEL_WINDOW_ADJUST;\n    handler && handler(self, recipient, bytesToAdd);\n  },\n  [MESSAGE.CHANNEL_DATA]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const data = bufferParser.readString();\n    bufferParser.clear();\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_DATA packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);\n    const handler = self._handlers.CHANNEL_DATA;\n    handler && handler(self, recipient, data);\n  },\n  [MESSAGE.CHANNEL_EXTENDED_DATA]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const type = bufferParser.readUInt32BE();\n    const data = bufferParser.readString();\n    bufferParser.clear();\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_EXTENDED_DATA packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`);\n    const handler = self._handlers.CHANNEL_EXTENDED_DATA;\n    handler && handler(self, recipient, data, type);\n  },\n  [MESSAGE.CHANNEL_EOF]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_EOF packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_EOF;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_CLOSE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_CLOSE packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_CLOSE;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_REQUEST]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    request type in US-ASCII characters only\n      boolean   want reply\n      ....      type-specific data follows\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    const type = bufferParser.readString(true);\n    const wantReply = bufferParser.readBool();\n    let data;\n    if (wantReply !== undefined) {\n      switch (type) {\n        case 'exit-status':\n          // S->C\n          /*\n            uint32    exit_status\n          */\n          data = bufferParser.readUInt32BE();\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n        case 'exit-signal':\n          {\n            // S->C\n            /*\n              string    signal name (without the \"SIG\" prefix)\n              boolean   core dumped\n              string    error message in ISO-10646 UTF-8 encoding\n              string    language tag\n            */\n            let signal;\n            let coreDumped;\n            if (self._compatFlags & COMPAT.OLD_EXIT) {\n              /*\n                Instead of `signal name` and `core dumped`, we have just:\n                  uint32  signal number\n              */\n              const num = bufferParser.readUInt32BE();\n              switch (num) {\n                case 1:\n                  signal = 'HUP';\n                  break;\n                case 2:\n                  signal = 'INT';\n                  break;\n                case 3:\n                  signal = 'QUIT';\n                  break;\n                case 6:\n                  signal = 'ABRT';\n                  break;\n                case 9:\n                  signal = 'KILL';\n                  break;\n                case 14:\n                  signal = 'ALRM';\n                  break;\n                case 15:\n                  signal = 'TERM';\n                  break;\n                default:\n                  if (num !== undefined) {\n                    // Unknown or OS-specific\n                    signal = `UNKNOWN (${num})`;\n                  }\n              }\n              coreDumped = false;\n            } else {\n              signal = bufferParser.readString(true);\n              coreDumped = bufferParser.readBool();\n              if (coreDumped === undefined) signal = undefined;\n            }\n            const errorMessage = bufferParser.readString(true);\n            if (bufferParser.skipString() !== undefined) data = {\n              signal,\n              coreDumped,\n              errorMessage\n            };\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`);\n            break;\n          }\n        case 'pty-req':\n          {\n            // C->S\n            /*\n              string    TERM environment variable value (e.g., vt100)\n              uint32    terminal width, characters (e.g., 80)\n              uint32    terminal height, rows (e.g., 24)\n              uint32    terminal width, pixels (e.g., 640)\n              uint32    terminal height, pixels (e.g., 480)\n              string    encoded terminal modes\n            */\n            const term = bufferParser.readString(true);\n            const cols = bufferParser.readUInt32BE();\n            const rows = bufferParser.readUInt32BE();\n            const width = bufferParser.readUInt32BE();\n            const height = bufferParser.readUInt32BE();\n            const modesBinary = bufferParser.readString();\n            if (modesBinary !== undefined) {\n              bufferParser.init(modesBinary, 1);\n              let modes = {};\n              while (bufferParser.avail()) {\n                const opcode = bufferParser.readByte();\n                if (opcode === TERMINAL_MODE.TTY_OP_END) break;\n                const name = TERMINAL_MODE_BY_VALUE[opcode];\n                const value = bufferParser.readUInt32BE();\n                if (opcode === undefined || name === undefined || value === undefined) {\n                  modes = undefined;\n                  break;\n                }\n                modes[name] = value;\n              }\n              if (modes !== undefined) data = {\n                term,\n                cols,\n                rows,\n                width,\n                height,\n                modes\n              };\n            }\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n            break;\n          }\n        case 'window-change':\n          {\n            // C->S\n            /*\n              uint32    terminal width, columns\n              uint32    terminal height, rows\n              uint32    terminal width, pixels\n              uint32    terminal height, pixels\n            */\n            const cols = bufferParser.readUInt32BE();\n            const rows = bufferParser.readUInt32BE();\n            const width = bufferParser.readUInt32BE();\n            const height = bufferParser.readUInt32BE();\n            if (height !== undefined) data = {\n              cols,\n              rows,\n              width,\n              height\n            };\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n            break;\n          }\n        case 'x11-req':\n          {\n            // C->S\n            /*\n              boolean   single connection\n              string    x11 authentication protocol\n              string    x11 authentication cookie\n              uint32    x11 screen number\n            */\n            const single = bufferParser.readBool();\n            const protocol = bufferParser.readString(true);\n            const cookie = bufferParser.readString();\n            const screen = bufferParser.readUInt32BE();\n            if (screen !== undefined) data = {\n              single,\n              protocol,\n              cookie,\n              screen\n            };\n            self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n            break;\n          }\n        case 'env':\n          {\n            // C->S\n            /*\n              string    variable name\n              string    variable value\n            */\n            const name = bufferParser.readString(true);\n            const value = bufferParser.readString(true);\n            if (value !== undefined) data = {\n              name,\n              value\n            };\n            if (self._debug) {\n              self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ` + `${name}=${value})`);\n            }\n            break;\n          }\n        case 'shell':\n          // C->S\n          data = null; // No extra data\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n          break;\n        case 'exec':\n          // C->S\n          /*\n            string    command\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n        case 'subsystem':\n          // C->S\n          /*\n            string    subsystem name\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n        case 'signal':\n          // C->S\n          /*\n            string    signal name (without the \"SIG\" prefix)\n          */\n          data = bufferParser.readString(true);\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n        case 'xon-xoff':\n          // C->S\n          /*\n            boolean   client can do\n          */\n          data = bufferParser.readBool();\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);\n          break;\n        case 'auth-agent-req@openssh.com':\n          // C-S\n          data = null; // No extra data\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n          break;\n        default:\n          data = bufferParser.avail() ? bufferParser.readRaw() : null;\n          self._debug && self._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);\n      }\n    }\n    bufferParser.clear();\n    if (data === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_REQUEST packet');\n    }\n    const handler = self._handlers.CHANNEL_REQUEST;\n    handler && handler(self, recipient, type, wantReply, data);\n  },\n  [MESSAGE.CHANNEL_SUCCESS]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_SUCCESS packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_SUCCESS;\n    handler && handler(self, recipient);\n  },\n  [MESSAGE.CHANNEL_FAILURE]: (self, payload) => {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    bufferParser.init(payload, 1);\n    const recipient = bufferParser.readUInt32BE();\n    bufferParser.clear();\n    if (recipient === undefined) {\n      return doFatalError(self, 'Inbound: Malformed CHANNEL_FAILURE packet');\n    }\n    self._debug && self._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);\n    const handler = self._handlers.CHANNEL_FAILURE;\n    handler && handler(self, recipient);\n  }\n};","'use strict';\n\nconst {\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createECDH,\n  createHash,\n  createPublicKey,\n  diffieHellman,\n  generateKeyPairSync,\n  randomFillSync\n} = require('crypto');\nconst {\n  Ber\n} = require('asn1');\nconst {\n  COMPAT,\n  curve25519Supported,\n  DEFAULT_KEX,\n  DEFAULT_SERVER_HOST_KEY,\n  DEFAULT_CIPHER,\n  DEFAULT_MAC,\n  DEFAULT_COMPRESSION,\n  DISCONNECT_REASON,\n  MESSAGE\n} = require('./constants.js');\nconst {\n  CIPHER_INFO,\n  createCipher,\n  createDecipher,\n  MAC_INFO\n} = require('./crypto.js');\nconst {\n  parseDERKey\n} = require('./keyParser.js');\nconst {\n  bufferFill,\n  bufferParser,\n  convertSignature,\n  doFatalError,\n  FastBuffer,\n  sigSSHToASN1,\n  writeUInt32BE\n} = require('./utils.js');\nconst {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n} = require('./zlib.js');\nlet MESSAGE_HANDLERS;\nconst GEX_MIN_BITS = 2048; // RFC 8270\nconst GEX_MAX_BITS = 8192; // RFC 8270\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\n\n// Client/Server\nfunction kexinit(self) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n\n  let payload;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    const entry = self._offer.lists.kex;\n    let kex = entry.array;\n    let found = false;\n    for (let i = 0; i < kex.length; ++i) {\n      if (kex[i].includes('group-exchange')) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          kex = kex.slice();\n        }\n        kex.splice(i--, 1);\n      }\n    }\n    if (found) {\n      let len = 1 + 16 + self._offer.totalSize + 1 + 4;\n      const newKexBuf = Buffer.from(kex.join(','));\n      len -= entry.buffer.length - newKexBuf.length;\n      const all = self._offer.lists.all;\n      const rest = new Uint8Array(all.buffer, all.byteOffset + 4 + entry.buffer.length, all.length - (4 + entry.buffer.length));\n      payload = Buffer.allocUnsafe(len);\n      writeUInt32BE(payload, newKexBuf.length, 17);\n      payload.set(newKexBuf, 17 + 4);\n      payload.set(rest, 17 + 4 + newKexBuf.length);\n    }\n  }\n  if (payload === undefined) {\n    payload = Buffer.allocUnsafe(1 + 16 + self._offer.totalSize + 1 + 4);\n    self._offer.copyAllTo(payload, 17);\n  }\n  self._debug && self._debug('Outbound: Sending KEXINIT');\n  payload[0] = MESSAGE.KEXINIT;\n  randomFillSync(payload, 1, 16);\n\n  // Zero-fill first_kex_packet_follows and reserved bytes\n  bufferFill(payload, 0, payload.length - 5);\n  self._kexinit = payload;\n\n  // Needed to correct the starting position in allocated \"packets\" when packets\n  // will be buffered due to active key exchange\n  self._packetRW.write.allocStart = 0;\n\n  // TODO: only create single buffer and set _kexinit as slice of packet instead\n  {\n    const p = self._packetRW.write.allocStartKEX;\n    const packet = self._packetRW.write.alloc(payload.length, true);\n    packet.set(payload, p);\n    self._cipher.encrypt(self._packetRW.write.finalize(packet, true));\n  }\n}\nfunction handleKexInit(self, payload) {\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  const init = {\n    kex: undefined,\n    serverHostKey: undefined,\n    cs: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined\n    },\n    sc: {\n      cipher: undefined,\n      mac: undefined,\n      compress: undefined,\n      lang: undefined\n    }\n  };\n  bufferParser.init(payload, 17);\n  if ((init.kex = bufferParser.readList()) === undefined || (init.serverHostKey = bufferParser.readList()) === undefined || (init.cs.cipher = bufferParser.readList()) === undefined || (init.sc.cipher = bufferParser.readList()) === undefined || (init.cs.mac = bufferParser.readList()) === undefined || (init.sc.mac = bufferParser.readList()) === undefined || (init.cs.compress = bufferParser.readList()) === undefined || (init.sc.compress = bufferParser.readList()) === undefined || (init.cs.lang = bufferParser.readList()) === undefined || (init.sc.lang = bufferParser.readList()) === undefined) {\n    bufferParser.clear();\n    return doFatalError(self, 'Received malformed KEXINIT', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  const pos = bufferParser.pos();\n  const firstFollows = pos < payload.length && payload[pos] === 1;\n  bufferParser.clear();\n  const local = self._offer;\n  const remote = init;\n  let localKex = local.lists.kex.array;\n  if (self._compatFlags & COMPAT.BAD_DHGEX) {\n    let found = false;\n    for (let i = 0; i < localKex.length; ++i) {\n      if (localKex[i].indexOf('group-exchange') !== -1) {\n        if (!found) {\n          found = true;\n          // Copy array lazily\n          localKex = localKex.slice();\n        }\n        localKex.splice(i--, 1);\n      }\n    }\n  }\n  let clientList;\n  let serverList;\n  let i;\n  const debug = self._debug;\n  debug && debug('Inbound: Handshake in progress');\n\n  // Key exchange method =======================================================\n  debug && debug(`Handshake: (local) KEX method: ${localKex}`);\n  debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);\n  let remoteExtInfoEnabled;\n  if (self._server) {\n    serverList = localKex;\n    clientList = remote.kex;\n    remoteExtInfoEnabled = clientList.indexOf('ext-info-c') !== -1;\n  } else {\n    serverList = remote.kex;\n    clientList = localKex;\n    remoteExtInfoEnabled = serverList.indexOf('ext-info-s') !== -1;\n  }\n  if (self._strictMode === undefined) {\n    if (self._server) {\n      self._strictMode = clientList.indexOf('kex-strict-c-v00@openssh.com') !== -1;\n    } else {\n      self._strictMode = serverList.indexOf('kex-strict-s-v00@openssh.com') !== -1;\n    }\n    // Note: We check for seqno of 1 instead of 0 since we increment before\n    //       calling the packet handler\n    if (self._strictMode) {\n      debug && debug('Handshake: strict KEX mode enabled');\n      if (self._decipher.inSeqno !== 1) {\n        if (debug) debug('Handshake: KEXINIT not first packet in strict KEX mode');\n        return doFatalError(self, 'Handshake failed: KEXINIT not first packet in strict KEX mode', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n    }\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: no matching key exchange algorithm');\n    return doFatalError(self, 'Handshake failed: no matching key exchange algorithm', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.kex = clientList[i];\n  debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`);\n  if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {\n    // Ignore next inbound packet, it was a wrong first guess at KEX algorithm\n    self._skipNextInboundPacket = true;\n  }\n\n  // Server host key format ====================================================\n  const localSrvHostKey = local.lists.serverHostKey.array;\n  debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`);\n  debug && debug(`Handshake: (remote) Host key format: ${remote.serverHostKey}`);\n  if (self._server) {\n    serverList = localSrvHostKey;\n    clientList = remote.serverHostKey;\n  } else {\n    serverList = remote.serverHostKey;\n    clientList = localSrvHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching host key format');\n    return doFatalError(self, 'Handshake failed: no matching host key format', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.serverHostKey = clientList[i];\n  debug && debug(`Handshake: Host key format: ${clientList[i]}`);\n\n  // Client->Server cipher =====================================================\n  const localCSCipher = local.lists.cs.cipher.array;\n  debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`);\n  debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);\n  if (self._server) {\n    serverList = localCSCipher;\n    clientList = remote.cs.cipher;\n  } else {\n    serverList = remote.cs.cipher;\n    clientList = localCSCipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S cipher');\n    return doFatalError(self, 'Handshake failed: no matching C->S cipher', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.cs.cipher = clientList[i];\n  debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);\n\n  // Server->Client cipher =====================================================\n  const localSCCipher = local.lists.sc.cipher.array;\n  debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`);\n  debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);\n  if (self._server) {\n    serverList = localSCCipher;\n    clientList = remote.sc.cipher;\n  } else {\n    serverList = remote.sc.cipher;\n    clientList = localSCCipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C cipher');\n    return doFatalError(self, 'Handshake failed: no matching S->C cipher', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.sc.cipher = clientList[i];\n  debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);\n\n  // Client->Server MAC ========================================================\n  const localCSMAC = local.lists.cs.mac.array;\n  debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`);\n  debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);\n  if (CIPHER_INFO[init.cs.cipher].authLen > 0) {\n    init.cs.mac = '';\n    debug && debug('Handshake: C->S MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localCSMAC;\n      clientList = remote.cs.mac;\n    } else {\n      serverList = remote.cs.mac;\n      clientList = localCSMAC;\n    }\n    // Check for agreeable client->server hmac algorithm\n    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching C->S MAC');\n      return doFatalError(self, 'Handshake failed: no matching C->S MAC', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    }\n    init.cs.mac = clientList[i];\n    debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);\n  }\n\n  // Server->Client MAC ========================================================\n  const localSCMAC = local.lists.sc.mac.array;\n  debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`);\n  debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);\n  if (CIPHER_INFO[init.sc.cipher].authLen > 0) {\n    init.sc.mac = '';\n    debug && debug('Handshake: S->C MAC: <implicit>');\n  } else {\n    if (self._server) {\n      serverList = localSCMAC;\n      clientList = remote.sc.mac;\n    } else {\n      serverList = remote.sc.mac;\n      clientList = localSCMAC;\n    }\n    // Check for agreeable server->client hmac algorithm\n    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n    if (i === clientList.length) {\n      // No suitable match found!\n      debug && debug('Handshake: No matching S->C MAC');\n      return doFatalError(self, 'Handshake failed: no matching S->C MAC', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    }\n    init.sc.mac = clientList[i];\n    debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);\n  }\n\n  // Client->Server compression ================================================\n  const localCSCompress = local.lists.cs.compress.array;\n  debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`);\n  debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);\n  if (self._server) {\n    serverList = localCSCompress;\n    clientList = remote.cs.compress;\n  } else {\n    serverList = remote.cs.compress;\n    clientList = localCSCompress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching C->S compression');\n    return doFatalError(self, 'Handshake failed: no matching C->S compression', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.cs.compress = clientList[i];\n  debug && debug(`Handshake: C->S compression: ${clientList[i]}`);\n\n  // Server->Client compression ================================================\n  const localSCCompress = local.lists.sc.compress.array;\n  debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`);\n  debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);\n  if (self._server) {\n    serverList = localSCCompress;\n    clientList = remote.sc.compress;\n  } else {\n    serverList = remote.sc.compress;\n    clientList = localSCCompress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i);\n  if (i === clientList.length) {\n    // No suitable match found!\n    debug && debug('Handshake: No matching S->C compression');\n    return doFatalError(self, 'Handshake failed: no matching S->C compression', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n  }\n  init.sc.compress = clientList[i];\n  debug && debug(`Handshake: S->C compression: ${clientList[i]}`);\n  init.cs.lang = '';\n  init.sc.lang = '';\n\n  // XXX: hack -- find a better way to do this\n  if (self._kex) {\n    if (!self._kexinit) {\n      // We received a rekey request, but we haven't sent a KEXINIT in response\n      // yet\n      kexinit(self);\n    }\n    self._decipher._onPayload = onKEXPayload.bind(self, {\n      firstPacket: false\n    });\n  }\n  self._kex = createKeyExchange(init, self, payload);\n  self._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;\n  self._kex.start();\n}\nconst createKeyExchange = (() => {\n  function convertToMpint(buf) {\n    let idx = 0;\n    let length = buf.length;\n    while (buf[idx] === 0x00) {\n      ++idx;\n      --length;\n    }\n    let newBuf;\n    if (buf[idx] & 0x80) {\n      newBuf = Buffer.allocUnsafe(1 + length);\n      newBuf[0] = 0;\n      buf.copy(newBuf, 1, idx);\n      buf = newBuf;\n    } else if (length !== buf.length) {\n      newBuf = Buffer.allocUnsafe(length);\n      buf.copy(newBuf, 0, idx);\n      buf = newBuf;\n    }\n    return buf;\n  }\n  class KeyExchange {\n    constructor(negotiated, protocol, remoteKexinit) {\n      this._protocol = protocol;\n      this.sessionID = protocol._kex ? protocol._kex.sessionID : undefined;\n      this.negotiated = negotiated;\n      this.remoteExtInfoEnabled = false;\n      this._step = 1;\n      this._public = null;\n      this._dh = null;\n      this._sentNEWKEYS = false;\n      this._receivedNEWKEYS = false;\n      this._finished = false;\n      this._hostVerified = false;\n\n      // Data needed for initializing cipher/decipher/etc.\n      this._kexinit = protocol._kexinit;\n      this._remoteKexinit = remoteKexinit;\n      this._identRaw = protocol._identRaw;\n      this._remoteIdentRaw = protocol._remoteIdentRaw;\n      this._hostKey = undefined;\n      this._dhData = undefined;\n      this._sig = undefined;\n    }\n    finish(scOnly) {\n      if (this._finished) return false;\n      this._finished = true;\n      const isServer = this._protocol._server;\n      const negotiated = this.negotiated;\n      const pubKey = this.convertPublicKey(this._dhData);\n      let secret = this.computeSecret(this._dhData);\n      if (secret instanceof Error) {\n        secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;\n        secret.level = 'handshake';\n        return doFatalError(this._protocol, secret, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n      const hash = createHash(this.hashName);\n      // V_C\n      hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw);\n      // \"V_S\"\n      hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw);\n      // \"I_C\"\n      hashString(hash, isServer ? this._remoteKexinit : this._kexinit);\n      // \"I_S\"\n      hashString(hash, isServer ? this._kexinit : this._remoteKexinit);\n      // \"K_S\"\n      const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;\n      hashString(hash, serverPublicHostKey);\n      if (this.type === 'groupex') {\n        // Group exchange-specific\n        const params = this.getDHParams();\n        const num = Buffer.allocUnsafe(4);\n        // min (uint32)\n        writeUInt32BE(num, this._minBits, 0);\n        hash.update(num);\n        // preferred (uint32)\n        writeUInt32BE(num, this._prefBits, 0);\n        hash.update(num);\n        // max (uint32)\n        writeUInt32BE(num, this._maxBits, 0);\n        hash.update(num);\n        // prime\n        hashString(hash, params.prime);\n        // generator\n        hashString(hash, params.generator);\n      }\n\n      // method-specific data sent by client\n      hashString(hash, isServer ? pubKey : this.getPublicKey());\n      // method-specific data sent by server\n      const serverPublicKey = isServer ? this.getPublicKey() : pubKey;\n      hashString(hash, serverPublicKey);\n      // shared secret (\"K\")\n      hashString(hash, secret);\n\n      // \"H\"\n      const exchangeHash = hash.digest();\n      if (!isServer) {\n        bufferParser.init(this._sig, 0);\n        const sigType = bufferParser.readString(true);\n        if (!sigType) {\n          return doFatalError(this._protocol, 'Malformed packet while reading signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        if (sigType !== negotiated.serverHostKey) {\n          return doFatalError(this._protocol, `Wrong signature type: ${sigType}, ` + `expected: ${negotiated.serverHostKey}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        // \"s\"\n        let sigValue = bufferParser.readString();\n        bufferParser.clear();\n        if (sigValue === undefined) {\n          return doFatalError(this._protocol, 'Malformed packet while reading signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {\n          return doFatalError(this._protocol, 'Malformed signature', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        let parsedHostKey;\n        {\n          bufferParser.init(this._hostKey, 0);\n          const name = bufferParser.readString(true);\n          const hostKey = this._hostKey.slice(bufferParser.pos());\n          bufferParser.clear();\n          parsedHostKey = parseDERKey(hostKey, name);\n          if (parsedHostKey instanceof Error) {\n            parsedHostKey.level = 'handshake';\n            return doFatalError(this._protocol, parsedHostKey, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n        }\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256':\n            hashAlgo = 'sha256';\n            break;\n          case 'rsa-sha2-512':\n            hashAlgo = 'sha512';\n            break;\n        }\n        this._protocol._debug && this._protocol._debug('Verifying signature ...');\n        const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);\n        if (verified !== true) {\n          if (verified instanceof Error) {\n            this._protocol._debug && this._protocol._debug(`Signature verification failed: ${verified.stack}`);\n          } else {\n            this._protocol._debug && this._protocol._debug('Signature verification failed');\n          }\n          return doFatalError(this._protocol, 'Handshake failed: signature verification failed', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        this._protocol._debug && this._protocol._debug('Verified signature');\n      } else {\n        // Server\n\n        let hashAlgo;\n        // Check if we need to override the default hash algorithm\n        switch (this.negotiated.serverHostKey) {\n          case 'rsa-sha2-256':\n            hashAlgo = 'sha256';\n            break;\n          case 'rsa-sha2-512':\n            hashAlgo = 'sha512';\n            break;\n        }\n        this._protocol._debug && this._protocol._debug('Generating signature ...');\n        let signature = this._hostKey.sign(exchangeHash, hashAlgo);\n        if (signature instanceof Error) {\n          return doFatalError(this._protocol, 'Handshake failed: signature generation failed for ' + `${this._hostKey.type} host key: ${signature.message}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n        signature = convertSignature(signature, this._hostKey.type);\n        if (signature === false) {\n          return doFatalError(this._protocol, 'Handshake failed: signature conversion failed for ' + `${this._hostKey.type} host key`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n        }\n\n        // Send KEX reply\n        /*\n          byte      SSH_MSG_KEXDH_REPLY\n                      / SSH_MSG_KEX_DH_GEX_REPLY\n                      / SSH_MSG_KEX_ECDH_REPLY\n          string    server public host key and certificates (K_S)\n          string    <method-specific data>\n          string    signature of H\n        */\n        const sigType = this.negotiated.serverHostKey;\n        const sigTypeLen = Buffer.byteLength(sigType);\n        const sigLen = 4 + sigTypeLen + 4 + signature.length;\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen, true);\n        packet[p] = MESSAGE.KEXDH_REPLY;\n        writeUInt32BE(packet, serverPublicHostKey.length, ++p);\n        packet.set(serverPublicHostKey, p += 4);\n        writeUInt32BE(packet, serverPublicKey.length, p += serverPublicHostKey.length);\n        packet.set(serverPublicKey, p += 4);\n        writeUInt32BE(packet, sigLen, p += serverPublicKey.length);\n        writeUInt32BE(packet, sigTypeLen, p += 4);\n        packet.utf8Write(sigType, p += 4, sigTypeLen);\n        writeUInt32BE(packet, signature.length, p += sigTypeLen);\n        packet.set(signature, p += 4);\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_REPLY';\n              break;\n            case 'groupex':\n              type = 'KEXDH_GEX_REPLY';\n              break;\n            default:\n              type = 'KEXECDH_REPLY';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n      if (isServer || !scOnly) trySendNEWKEYS(this);\n      let hsCipherConfig;\n      let hsWrite;\n      const completeHandshake = partial => {\n        if (hsCipherConfig) {\n          trySendNEWKEYS(this);\n          hsCipherConfig.outbound.seqno = this._protocol._cipher.outSeqno;\n          this._protocol._cipher.free();\n          this._protocol._cipher = createCipher(hsCipherConfig);\n          this._protocol._packetRW.write = hsWrite;\n          hsCipherConfig = undefined;\n          hsWrite = undefined;\n          this._protocol._onHandshakeComplete(negotiated);\n          return false;\n        }\n        if (!this.sessionID) this.sessionID = exchangeHash;\n        {\n          const newSecret = Buffer.allocUnsafe(4 + secret.length);\n          writeUInt32BE(newSecret, secret.length, 0);\n          newSecret.set(secret, 4);\n          secret = newSecret;\n        }\n\n        // Initialize new ciphers, deciphers, etc.\n\n        const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];\n        const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];\n        const csIV = generateKEXVal(csCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, 'A');\n        const scIV = generateKEXVal(scCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, 'B');\n        const csKey = generateKEXVal(csCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, 'C');\n        const scKey = generateKEXVal(scCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, 'D');\n        let csMacInfo;\n        let csMacKey;\n        if (!csCipherInfo.authLen) {\n          csMacInfo = MAC_INFO[negotiated.cs.mac];\n          csMacKey = generateKEXVal(csMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, 'E');\n        }\n        let scMacInfo;\n        let scMacKey;\n        if (!scCipherInfo.authLen) {\n          scMacInfo = MAC_INFO[negotiated.sc.mac];\n          scMacKey = generateKEXVal(scMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, 'F');\n        }\n        const config = {\n          inbound: {\n            onPayload: this._protocol._onPayload,\n            seqno: this._protocol._decipher.inSeqno,\n            decipherInfo: !isServer ? scCipherInfo : csCipherInfo,\n            decipherIV: !isServer ? scIV : csIV,\n            decipherKey: !isServer ? scKey : csKey,\n            macInfo: !isServer ? scMacInfo : csMacInfo,\n            macKey: !isServer ? scMacKey : csMacKey\n          },\n          outbound: {\n            onWrite: this._protocol._onWrite,\n            seqno: this._protocol._cipher.outSeqno,\n            cipherInfo: isServer ? scCipherInfo : csCipherInfo,\n            cipherIV: isServer ? scIV : csIV,\n            cipherKey: isServer ? scKey : csKey,\n            macInfo: isServer ? scMacInfo : csMacInfo,\n            macKey: isServer ? scMacKey : csMacKey\n          }\n        };\n        this._protocol._decipher.free();\n        hsCipherConfig = config;\n        this._protocol._decipher = createDecipher(config);\n        const rw = {\n          read: undefined,\n          write: undefined\n        };\n        switch (negotiated.cs.compress) {\n          case 'zlib':\n            // starts immediately\n            if (isServer) rw.read = new ZlibPacketReader();else rw.write = new ZlibPacketWriter(this._protocol);\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer) rw.read = new ZlibPacketReader();else rw.write = new ZlibPacketWriter(this._protocol);\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer) rw.read = new PacketReader();else rw.write = new PacketWriter(this._protocol);\n        }\n        switch (negotiated.sc.compress) {\n          case 'zlib':\n            // starts immediately\n            if (isServer) rw.write = new ZlibPacketWriter(this._protocol);else rw.read = new ZlibPacketReader();\n            break;\n          case 'zlib@openssh.com':\n            // Starts after successful user authentication\n\n            if (this._protocol._authenticated) {\n              // If a rekey happens and this compression method is selected and\n              // we already authenticated successfully, we need to start\n              // immediately instead\n              if (isServer) rw.write = new ZlibPacketWriter(this._protocol);else rw.read = new ZlibPacketReader();\n              break;\n            }\n          // FALLTHROUGH\n          default:\n            // none -- never any compression/decompression\n\n            if (isServer) rw.write = new PacketWriter(this._protocol);else rw.read = new PacketReader();\n        }\n        this._protocol._packetRW.read.cleanup();\n        this._protocol._packetRW.write.cleanup();\n        this._protocol._packetRW.read = rw.read;\n        hsWrite = rw.write;\n\n        // Cleanup/reset various state\n        this._public = null;\n        this._dh = null;\n        this._kexinit = this._protocol._kexinit = undefined;\n        this._remoteKexinit = undefined;\n        this._identRaw = undefined;\n        this._remoteIdentRaw = undefined;\n        this._hostKey = undefined;\n        this._dhData = undefined;\n        this._sig = undefined;\n        if (!partial) return completeHandshake();\n        return false;\n      };\n      if (isServer || scOnly) this.finish = completeHandshake;\n      if (!isServer) return completeHandshake(scOnly);\n    }\n    start() {\n      if (!this._protocol._server) {\n        if (this._protocol._debug) {\n          let type;\n          switch (this.type) {\n            case 'group':\n              type = 'KEXDH_INIT';\n              break;\n            default:\n              type = 'KEXECDH_INIT';\n          }\n          this._protocol._debug(`Outbound: Sending ${type}`);\n        }\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n    }\n    getPublicKey() {\n      this.generateKeys();\n      const key = this._public;\n      if (key) return this.convertPublicKey(key);\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n      try {\n        return convertToMpint(this._dh.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          if (this._protocol._server) {\n            // Server\n            if (type !== MESSAGE.KEXDH_INIT) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH Init');\n            /*\n              byte     SSH_MSG_KEXDH_INIT\n                         / SSH_MSG_KEX_ECDH_INIT\n              string   <method-specific data>\n            */\n            bufferParser.init(payload, 1);\n            const dhData = bufferParser.readString();\n            bufferParser.clear();\n            if (dhData === undefined) {\n              return doFatalError(this._protocol, 'Received malformed KEX*_INIT', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n\n            // Client public key\n            this._dhData = dhData;\n            let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];\n            if (Array.isArray(hostKey)) hostKey = hostKey[0];\n            this._hostKey = hostKey;\n            this.finish();\n          } else {\n            // Client\n            if (type !== MESSAGE.KEXDH_REPLY) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH Reply');\n            /*\n              byte      SSH_MSG_KEXDH_REPLY\n                          / SSH_MSG_KEX_DH_GEX_REPLY\n                          / SSH_MSG_KEX_ECDH_REPLY\n              string    server public host key and certificates (K_S)\n              string    <method-specific data>\n              string    signature of H\n            */\n            bufferParser.init(payload, 1);\n            let hostPubKey;\n            let dhData;\n            let sig;\n            if ((hostPubKey = bufferParser.readString()) === undefined || (dhData = bufferParser.readString()) === undefined || (sig = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(this._protocol, 'Received malformed KEX*_REPLY', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            bufferParser.clear();\n\n            // Check that the host public key type matches what was negotiated\n            // during KEXINIT swap\n            bufferParser.init(hostPubKey, 0);\n            const hostPubKeyType = bufferParser.readString(true);\n            bufferParser.clear();\n            if (hostPubKeyType === undefined) {\n              return doFatalError(this._protocol, 'Received malformed host public key', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            if (hostPubKeyType !== this.negotiated.serverHostKey) {\n              // Check if we need to make an exception\n              switch (this.negotiated.serverHostKey) {\n                case 'rsa-sha2-256':\n                case 'rsa-sha2-512':\n                  if (hostPubKeyType === 'ssh-rsa') break;\n                // FALLTHROUGH\n                default:\n                  return doFatalError(this._protocol, 'Host key does not match negotiated type', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n              }\n            }\n            this._hostKey = hostPubKey;\n            this._dhData = dhData;\n            this._sig = sig;\n            let checked = false;\n            let ret;\n            if (this._protocol._hostVerifier === undefined) {\n              ret = true;\n              this._protocol._debug && this._protocol._debug('Host accepted by default (no verification)');\n            } else {\n              ret = this._protocol._hostVerifier(hostPubKey, permitted => {\n                if (checked) return;\n                checked = true;\n                if (permitted === false) {\n                  this._protocol._debug && this._protocol._debug('Host denied (verification failed)');\n                  return doFatalError(this._protocol, 'Host denied (verification failed)', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n                }\n                this._protocol._debug && this._protocol._debug('Host accepted (verified)');\n                this._hostVerified = true;\n                if (this._receivedNEWKEYS) this.finish();else trySendNEWKEYS(this);\n              });\n            }\n            if (ret === undefined) {\n              // Async host verification\n              ++this._step;\n              return;\n            }\n            checked = true;\n            if (ret === false) {\n              this._protocol._debug && this._protocol._debug('Host denied (verification failed)');\n              return doFatalError(this._protocol, 'Host denied (verification failed)', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Host accepted (verified)');\n            this._hostVerified = true;\n            trySendNEWKEYS(this);\n          }\n          ++this._step;\n          break;\n        case 2:\n          if (type !== MESSAGE.NEWKEYS) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n          this._protocol._debug && this._protocol._debug('Inbound: NEWKEYS');\n          this._receivedNEWKEYS = true;\n          if (this._protocol._strictMode) this._protocol._decipher.inSeqno = 0;\n          ++this._step;\n          return this.finish(!this._protocol._server && !this._hostVerified);\n        default:\n          return doFatalError(this._protocol, `Received unexpected packet ${type} after NEWKEYS`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n    }\n  }\n  class Curve25519Exchange extends KeyExchange {\n    constructor(hashName, ...args) {\n      super(...args);\n      this.type = '25519';\n      this.hashName = hashName;\n      this._keys = null;\n    }\n    generateKeys() {\n      if (!this._keys) this._keys = generateKeyPairSync('x25519');\n    }\n    getPublicKey() {\n      this.generateKeys();\n      const key = this._keys.publicKey.export({\n        type: 'spki',\n        format: 'der'\n      });\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    }\n    convertPublicKey(key) {\n      let newKey;\n      let idx = 0;\n      let len = key.length;\n      while (key[idx] === 0x00) {\n        ++idx;\n        --len;\n      }\n      if (key.length === 32) return key;\n      if (len !== key.length) {\n        newKey = Buffer.allocUnsafe(len);\n        key.copy(newKey, 0, idx);\n        key = newKey;\n      }\n      return key;\n    }\n    computeSecret(otherPublicKey) {\n      this.generateKeys();\n      try {\n        const asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n        // algorithm\n        asnWriter.startSequence();\n        asnWriter.writeOID('1.3.101.110'); // id-X25519\n        asnWriter.endSequence();\n\n        // PublicKey\n        asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00);\n        // XXX: hack to write a raw buffer without a tag -- yuck\n        asnWriter._ensure(otherPublicKey.length);\n        otherPublicKey.copy(asnWriter._buf, asnWriter._offset, 0, otherPublicKey.length);\n        asnWriter._offset += otherPublicKey.length;\n        asnWriter.endSequence();\n        asnWriter.endSequence();\n        return convertToMpint(diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der'\n          })\n        }));\n      } catch (ex) {\n        return ex;\n      }\n    }\n  }\n  class ECDHExchange extends KeyExchange {\n    constructor(curveName, hashName, ...args) {\n      super(...args);\n      this.type = 'ecdh';\n      this.curveName = curveName;\n      this.hashName = hashName;\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createECDH(this.curveName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n  }\n  class DHGroupExchange extends KeyExchange {\n    constructor(hashName, ...args) {\n      super(...args);\n      this.type = 'groupex';\n      this.hashName = hashName;\n      this._prime = null;\n      this._generator = null;\n      this._minBits = GEX_MIN_BITS;\n      this._prefBits = dhEstimate(this.negotiated);\n      if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE) this._prefBits = Math.min(this._prefBits, 4096);\n      this._maxBits = GEX_MAX_BITS;\n    }\n    start() {\n      if (this._protocol._server) return;\n      this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_GEX_REQUEST');\n      let p = this._protocol._packetRW.write.allocStartKEX;\n      const packet = this._protocol._packetRW.write.alloc(1 + 4 + 4 + 4, true);\n      packet[p] = MESSAGE.KEXDH_GEX_REQUEST;\n      writeUInt32BE(packet, this._minBits, ++p);\n      writeUInt32BE(packet, this._prefBits, p += 4);\n      writeUInt32BE(packet, this._maxBits, p += 4);\n      this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n    }\n    generateKeys() {\n      if (!this._dh && this._prime && this._generator) {\n        this._dh = createDiffieHellman(this._prime, this._generator);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    setDHParams(prime, generator) {\n      if (!Buffer.isBuffer(prime)) throw new Error('Invalid prime value');\n      if (!Buffer.isBuffer(generator)) throw new Error('Invalid generator value');\n      this._prime = prime;\n      this._generator = generator;\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator())\n        };\n      }\n    }\n    parse(payload) {\n      const type = payload[0];\n      switch (this._step) {\n        case 1:\n          {\n            if (this._protocol._server) {\n              if (type !== MESSAGE.KEXDH_GEX_REQUEST) {\n                return doFatalError(this._protocol, `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n              }\n              // TODO: allow user implementation to provide safe prime and\n              // generator on demand to support group exchange on server side\n              return doFatalError(this._protocol, 'Group exchange not implemented for server', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            if (type !== MESSAGE.KEXDH_GEX_GROUP) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH GEX Group');\n\n            /*\n              byte    SSH_MSG_KEX_DH_GEX_GROUP\n              mpint   p, safe prime\n              mpint   g, generator for subgroup in GF(p)\n            */\n            bufferParser.init(payload, 1);\n            let prime;\n            let gen;\n            if ((prime = bufferParser.readString()) === undefined || (gen = bufferParser.readString()) === undefined) {\n              bufferParser.clear();\n              return doFatalError(this._protocol, 'Received malformed KEXDH_GEX_GROUP', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            bufferParser.clear();\n\n            // TODO: validate prime\n            this.setDHParams(prime, gen);\n            this.generateKeys();\n            const pubkey = this.getPublicKey();\n            this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_GEX_INIT');\n            let p = this._protocol._packetRW.write.allocStartKEX;\n            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);\n            packet[p] = MESSAGE.KEXDH_GEX_INIT;\n            writeUInt32BE(packet, pubkey.length, ++p);\n            packet.set(pubkey, p += 4);\n            this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n            ++this._step;\n            break;\n          }\n        case 2:\n          if (this._protocol._server) {\n            if (type !== MESSAGE.KEXDH_GEX_INIT) {\n              return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n            }\n            this._protocol._debug && this._protocol._debug('Received DH GEX Init');\n            return doFatalError(this._protocol, 'Group exchange not implemented for server', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {\n            return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n          }\n          this._protocol._debug && this._protocol._debug('Received DH GEX Reply');\n          this._step = 1;\n          payload[0] = MESSAGE.KEXDH_REPLY;\n          this.parse = KeyExchange.prototype.parse;\n          this.parse(payload);\n      }\n    }\n  }\n  class DHExchange extends KeyExchange {\n    constructor(groupName, hashName, ...args) {\n      super(...args);\n      this.type = 'group';\n      this.groupName = groupName;\n      this.hashName = hashName;\n    }\n    start() {\n      if (!this._protocol._server) {\n        this._protocol._debug && this._protocol._debug('Outbound: Sending KEXDH_INIT');\n        const pubKey = this.getPublicKey();\n        let p = this._protocol._packetRW.write.allocStartKEX;\n        const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);\n        packet[p] = MESSAGE.KEXDH_INIT;\n        writeUInt32BE(packet, pubKey.length, ++p);\n        packet.set(pubKey, p += 4);\n        this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));\n      }\n    }\n    generateKeys() {\n      if (!this._dh) {\n        this._dh = createDiffieHellmanGroup(this.groupName);\n        this._public = this._dh.generateKeys();\n      }\n    }\n    getDHParams() {\n      if (this._dh) {\n        return {\n          prime: convertToMpint(this._dh.getPrime()),\n          generator: convertToMpint(this._dh.getGenerator())\n        };\n      }\n    }\n  }\n  return (negotiated, ...args) => {\n    if (typeof negotiated !== 'object' || negotiated === null) throw new Error('Invalid negotiated argument');\n    const kexType = negotiated.kex;\n    if (typeof kexType === 'string') {\n      args = [negotiated, ...args];\n      switch (kexType) {\n        case 'curve25519-sha256':\n        case 'curve25519-sha256@libssh.org':\n          if (!curve25519Supported) break;\n          return new Curve25519Exchange('sha256', ...args);\n        case 'ecdh-sha2-nistp256':\n          return new ECDHExchange('prime256v1', 'sha256', ...args);\n        case 'ecdh-sha2-nistp384':\n          return new ECDHExchange('secp384r1', 'sha384', ...args);\n        case 'ecdh-sha2-nistp521':\n          return new ECDHExchange('secp521r1', 'sha512', ...args);\n        case 'diffie-hellman-group1-sha1':\n          return new DHExchange('modp2', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha1':\n          return new DHExchange('modp14', 'sha1', ...args);\n        case 'diffie-hellman-group14-sha256':\n          return new DHExchange('modp14', 'sha256', ...args);\n        case 'diffie-hellman-group15-sha512':\n          return new DHExchange('modp15', 'sha512', ...args);\n        case 'diffie-hellman-group16-sha512':\n          return new DHExchange('modp16', 'sha512', ...args);\n        case 'diffie-hellman-group17-sha512':\n          return new DHExchange('modp17', 'sha512', ...args);\n        case 'diffie-hellman-group18-sha512':\n          return new DHExchange('modp18', 'sha512', ...args);\n        case 'diffie-hellman-group-exchange-sha1':\n          return new DHGroupExchange('sha1', ...args);\n        case 'diffie-hellman-group-exchange-sha256':\n          return new DHGroupExchange('sha256', ...args);\n      }\n      throw new Error(`Unsupported key exchange algorithm: ${kexType}`);\n    }\n    throw new Error(`Invalid key exchange type: ${kexType}`);\n  };\n})();\nconst KexInit = (() => {\n  const KEX_PROPERTY_NAMES = ['kex', 'serverHostKey', ['cs', 'cipher'], ['sc', 'cipher'], ['cs', 'mac'], ['sc', 'mac'], ['cs', 'compress'], ['sc', 'compress'], ['cs', 'lang'], ['sc', 'lang']];\n  return class KexInit {\n    constructor(obj) {\n      if (typeof obj !== 'object' || obj === null) throw new TypeError('Argument must be an object');\n      const lists = {\n        kex: undefined,\n        serverHostKey: undefined,\n        cs: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined\n        },\n        sc: {\n          cipher: undefined,\n          mac: undefined,\n          compress: undefined,\n          lang: undefined\n        },\n        all: undefined\n      };\n      let totalSize = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let base;\n        let val;\n        let desc;\n        let key;\n        if (typeof prop === 'string') {\n          base = lists;\n          val = obj[prop];\n          desc = key = prop;\n        } else {\n          const parent = prop[0];\n          base = lists[parent];\n          key = prop[1];\n          val = obj[parent][key];\n          desc = `${parent}.${key}`;\n        }\n        const entry = {\n          array: undefined,\n          buffer: undefined\n        };\n        if (Buffer.isBuffer(val)) {\n          entry.array = ('' + val).split(',');\n          entry.buffer = val;\n          totalSize += 4 + val.length;\n        } else {\n          if (typeof val === 'string') val = val.split(',');\n          if (Array.isArray(val)) {\n            entry.array = val;\n            entry.buffer = Buffer.from(val.join(','));\n          } else {\n            throw new TypeError(`Invalid \\`${desc}\\` type: ${typeof val}`);\n          }\n          totalSize += 4 + entry.buffer.length;\n        }\n        base[key] = entry;\n      }\n      const all = Buffer.allocUnsafe(totalSize);\n      lists.all = all;\n      let allPos = 0;\n      for (const prop of KEX_PROPERTY_NAMES) {\n        let data;\n        if (typeof prop === 'string') data = lists[prop].buffer;else data = lists[prop[0]][prop[1]].buffer;\n        allPos = writeUInt32BE(all, data.length, allPos);\n        all.set(data, allPos);\n        allPos += data.length;\n      }\n      this.totalSize = totalSize;\n      this.lists = lists;\n    }\n    copyAllTo(buf, offset) {\n      const src = this.lists.all;\n      if (typeof offset !== 'number') throw new TypeError(`Invalid offset value: ${typeof offset}`);\n      if (buf.length - offset < src.length) throw new Error('Insufficient space to copy list');\n      buf.set(src, offset);\n      return src.length;\n    }\n  };\n})();\nconst hashString = (() => {\n  const LEN = Buffer.allocUnsafe(4);\n  return (hash, buf) => {\n    writeUInt32BE(LEN, buf.length, 0);\n    hash.update(LEN);\n    hash.update(buf);\n  };\n})();\nfunction generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {\n  let ret;\n  if (len) {\n    let digest = createHash(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();\n    while (digest.length < len) {\n      const chunk = createHash(hashName).update(secret).update(exchangeHash).update(digest).digest();\n      const extended = Buffer.allocUnsafe(digest.length + chunk.length);\n      extended.set(digest, 0);\n      extended.set(chunk, digest.length);\n      digest = extended;\n    }\n    if (digest.length === len) ret = digest;else ret = new FastBuffer(digest.buffer, digest.byteOffset, len);\n  } else {\n    ret = EMPTY_BUFFER;\n  }\n  return ret;\n}\nfunction onKEXPayload(state, payload) {\n  // XXX: move this to the Decipher implementations?\n  if (payload.length === 0) {\n    this._debug && this._debug('Inbound: Skipping empty packet payload');\n    return;\n  }\n  if (this._skipNextInboundPacket) {\n    this._skipNextInboundPacket = false;\n    return;\n  }\n  payload = this._packetRW.read.read(payload);\n  const type = payload[0];\n  if (!this._strictMode) {\n    switch (type) {\n      case MESSAGE.IGNORE:\n      case MESSAGE.UNIMPLEMENTED:\n      case MESSAGE.DEBUG:\n        if (!MESSAGE_HANDLERS) MESSAGE_HANDLERS = require('./handlers.js');\n        return MESSAGE_HANDLERS[type](this, payload);\n    }\n  }\n  switch (type) {\n    case MESSAGE.DISCONNECT:\n      if (!MESSAGE_HANDLERS) MESSAGE_HANDLERS = require('./handlers.js');\n      return MESSAGE_HANDLERS[type](this, payload);\n    case MESSAGE.KEXINIT:\n      if (!state.firstPacket) {\n        return doFatalError(this, 'Received extra KEXINIT during handshake', 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n      state.firstPacket = false;\n      return handleKexInit(this, payload);\n    default:\n      // Ensure packet is either an algorithm negotiation or KEX\n      // algorithm-specific packet\n      if (type < 20 || type > 49) {\n        return doFatalError(this, `Received unexpected packet type ${type}`, 'handshake', DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      }\n  }\n  return this._kex.parse(payload);\n}\nfunction dhEstimate(neg) {\n  const csCipher = CIPHER_INFO[neg.cs.cipher];\n  const scCipher = CIPHER_INFO[neg.sc.cipher];\n  // XXX: if OpenSSH's `umac-*` MACs are ever supported, their key lengths will\n  // also need to be considered when calculating `bits`\n  const bits = Math.max(0, csCipher.sslName === 'des-ede3-cbc' ? 14 : csCipher.keyLen, csCipher.blockLen, csCipher.ivLen, scCipher.sslName === 'des-ede3-cbc' ? 14 : scCipher.keyLen, scCipher.blockLen, scCipher.ivLen) * 8;\n  if (bits <= 112) return 2048;\n  if (bits <= 128) return 3072;\n  if (bits <= 192) return 7680;\n  return 8192;\n}\nfunction trySendNEWKEYS(kex) {\n  if (!kex._sentNEWKEYS) {\n    kex._protocol._debug && kex._protocol._debug('Outbound: Sending NEWKEYS');\n    const p = kex._protocol._packetRW.write.allocStartKEX;\n    const packet = kex._protocol._packetRW.write.alloc(1, true);\n    packet[p] = MESSAGE.NEWKEYS;\n    kex._protocol._cipher.encrypt(kex._protocol._packetRW.write.finalize(packet, true));\n    kex._sentNEWKEYS = true;\n    if (kex._protocol._strictMode) kex._protocol._cipher.outSeqno = 0;\n  }\n}\nmodule.exports = {\n  KexInit,\n  kexinit,\n  onKEXPayload,\n  DEFAULT_KEXINIT_CLIENT: new KexInit({\n    kex: DEFAULT_KEX.concat(['ext-info-c', 'kex-strict-c-v00@openssh.com']),\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    }\n  }),\n  DEFAULT_KEXINIT_SERVER: new KexInit({\n    kex: DEFAULT_KEX.concat(['kex-strict-s-v00@openssh.com']),\n    serverHostKey: DEFAULT_SERVER_HOST_KEY,\n    cs: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    },\n    sc: {\n      cipher: DEFAULT_CIPHER,\n      mac: DEFAULT_MAC,\n      compress: DEFAULT_COMPRESSION,\n      lang: []\n    }\n  }),\n  HANDLERS: {\n    [MESSAGE.KEXINIT]: handleKexInit\n  }\n};","// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n'use strict';\n\nconst {\n  createDecipheriv,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  sign: sign_,\n  verify: verify_\n} = require('crypto');\nconst supportedOpenSSLCiphers = getCiphers();\nconst {\n  Ber\n} = require('asn1');\nconst bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\nconst {\n  CIPHER_INFO\n} = require('./crypto.js');\nconst {\n  eddsaSupported,\n  SUPPORTED_CIPHER\n} = require('./constants.js');\nconst {\n  bufferSlice,\n  makeBufferParser,\n  readString,\n  readUInt32BE,\n  writeUInt32BE\n} = require('./utils.js');\nconst SYM_HASH_ALGO = Symbol('Hash Algorithm');\nconst SYM_PRIV_PEM = Symbol('Private key PEM');\nconst SYM_PUB_PEM = Symbol('Public key PEM');\nconst SYM_PUB_SSH = Symbol('Public key SSH');\nconst SYM_DECRYPTED = Symbol('Decrypted Key');\n\n// Create OpenSSL cipher name -> SSH cipher name conversion table\nconst CIPHER_INFO_OPENSSL = Object.create(null);\n{\n  const keys = Object.keys(CIPHER_INFO);\n  for (let i = 0; i < keys.length; ++i) {\n    const cipherName = CIPHER_INFO[keys[i]].sslName;\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName]) continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n}\nconst binaryKeyParser = makeBufferParser();\nfunction makePEM(type, data) {\n  data = data.base64Slice(0, data.length);\n  let formatted = data.replace(/.{64}/g, '$&\\n');\n  if (data.length & 63) formatted += '\\n';\n  return `-----BEGIN ${type} KEY-----\\n${formatted}-----END ${type} KEY-----`;\n}\nfunction combineBuffers(buf1, buf2) {\n  const result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  result.set(buf1, 0);\n  result.set(buf2, buf1.length);\n  return result;\n}\nfunction skipFields(buf, nfields) {\n  const bufLen = buf.length;\n  let pos = buf._pos || 0;\n  for (let i = 0; i < nfields; ++i) {\n    const left = bufLen - pos;\n    if (pos >= bufLen || left < 4) return false;\n    const len = readUInt32BE(buf, pos);\n    if (left < 4 + len) return false;\n    pos += 4 + len;\n  }\n  buf._pos = pos;\n  return true;\n}\nfunction genOpenSSLRSAPub(n, e) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n  // algorithm parameters (RSA has none)\n  asnWriter.writeNull();\n  asnWriter.endSequence();\n\n  // subjectPublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(n, Ber.Integer);\n  asnWriter.writeBuffer(e, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHRSAPub(n, e) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-rsa', 4, 7);\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  publicKey.set(e, i += 4);\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  publicKey.set(n, i + 4);\n  return publicKey;\n}\nconst genOpenSSLRSAPriv = (() => {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    const asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(n, Ber.Integer);\n    asnWriter.writeBuffer(e, Ber.Integer);\n    asnWriter.writeBuffer(d, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(dmp1, Ber.Integer);\n    asnWriter.writeBuffer(dmq1, Ber.Integer);\n    asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n  function bigIntFromBuffer(buf) {\n    return BigInt(`0x${buf.hexSlice(0, buf.length)}`);\n  }\n  function bigIntToBuffer(bn) {\n    let hex = bn.toString(16);\n    if ((hex.length & 1) !== 0) {\n      hex = `0${hex}`;\n    } else {\n      const sigbit = hex.charCodeAt(0);\n      // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n      if (sigbit === 56 /* '8' */ || sigbit === 57 /* '9' */ || sigbit >= 97 /* 'a' */ && sigbit <= 102 /* 'f' */) {\n        hex = `00${hex}`;\n      }\n    }\n    return Buffer.from(hex, 'hex');\n  }\n  return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n    const bn_d = bigIntFromBuffer(d);\n    const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));\n    const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));\n    return makePEM('RSA PRIVATE', genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n  };\n})();\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n  // algorithm parameters\n  asnWriter.startSequence();\n  asnWriter.writeBuffer(p, Ber.Integer);\n  asnWriter.writeBuffer(q, Ber.Integer);\n  asnWriter.writeBuffer(g, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n\n  // subjectPublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  asnWriter.writeBuffer(y, Ber.Integer);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length);\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.utf8Write('ssh-dss', 4, 7);\n  let i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  publicKey.set(p, i += 4);\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  publicKey.set(q, i += 4);\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  publicKey.set(g, i += 4);\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  publicKey.set(y, i + 4);\n  return publicKey;\n}\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  asnWriter.writeInt(0x00, Ber.Integer);\n  asnWriter.writeBuffer(p, Ber.Integer);\n  asnWriter.writeBuffer(q, Ber.Integer);\n  asnWriter.writeBuffer(g, Ber.Integer);\n  asnWriter.writeBuffer(y, Ber.Integer);\n  asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\nfunction genOpenSSLEdPub(pub) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n  asnWriter.endSequence();\n\n  // PublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  // XXX: hack to write a raw buffer without a tag -- yuck\n  asnWriter._ensure(pub.length);\n  asnWriter._buf.set(pub, asnWriter._offset);\n  asnWriter._offset += pub.length;\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHEdPub(pub) {\n  const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.utf8Write('ssh-ed25519', 4, 11);\n  writeUInt32BE(publicKey, pub.length, 15);\n  publicKey.set(pub, 19);\n  return publicKey;\n}\nfunction genOpenSSLEdPriv(priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // version\n  asnWriter.writeInt(0x00, Ber.Integer);\n\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n  asnWriter.endSequence();\n\n  // PrivateKey\n  asnWriter.startSequence(Ber.OctetString);\n  asnWriter.writeBuffer(priv, Ber.OctetString);\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\nfunction genOpenSSLECDSAPub(oid, Q) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // algorithm\n  asnWriter.startSequence();\n  asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n  // algorithm parameters (namedCurve)\n  asnWriter.writeOID(oid);\n  asnWriter.endSequence();\n\n  // subjectPublicKey\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  // XXX: hack to write a raw buffer without a tag -- yuck\n  asnWriter._ensure(Q.length);\n  asnWriter._buf.set(Q, asnWriter._offset);\n  asnWriter._offset += Q.length;\n  // end hack\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\nfunction genOpenSSHECDSAPub(oid, Q) {\n  let curveName;\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n    default:\n      return;\n  }\n  const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.utf8Write(curveName, 27, 8);\n  writeUInt32BE(publicKey, Q.length, 35);\n  publicKey.set(Q, 39);\n  return publicKey;\n}\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  const asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n  // version\n  asnWriter.writeInt(0x01, Ber.Integer);\n  // privateKey\n  asnWriter.writeBuffer(priv, Ber.OctetString);\n  // parameters (optional)\n  asnWriter.startSequence(0xA0);\n  asnWriter.writeOID(oid);\n  asnWriter.endSequence();\n  // publicKey (optional)\n  asnWriter.startSequence(0xA1);\n  asnWriter.startSequence(Ber.BitString);\n  asnWriter.writeByte(0x00);\n  // XXX: hack to write a raw buffer without a tag -- yuck\n  asnWriter._ensure(pub.length);\n  asnWriter._buf.set(pub, asnWriter._offset);\n  asnWriter._offset += pub.length;\n  // end hack\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  const tempECDH = createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\nconst BaseKey = {\n  sign: (() => {\n    if (typeof sign_ === 'function') {\n      return function sign(data, algo) {\n        const pem = this[SYM_PRIV_PEM];\n        if (pem === null) return new Error('No private key available');\n        if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n        try {\n          return sign_(algo, data, pem);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function sign(data, algo) {\n      const pem = this[SYM_PRIV_PEM];\n      if (pem === null) return new Error('No private key available');\n      if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n      const signature = createSign(algo);\n      signature.update(data);\n      try {\n        return signature.sign(pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  verify: (() => {\n    if (typeof verify_ === 'function') {\n      return function verify(data, signature, algo) {\n        const pem = this[SYM_PUB_PEM];\n        if (pem === null) return new Error('No public key available');\n        if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n        try {\n          return verify_(algo, data, pem, signature);\n        } catch (ex) {\n          return ex;\n        }\n      };\n    }\n    return function verify(data, signature, algo) {\n      const pem = this[SYM_PUB_PEM];\n      if (pem === null) return new Error('No public key available');\n      if (!algo || typeof algo !== 'string') algo = this[SYM_HASH_ALGO];\n      const verifier = createVerify(algo);\n      verifier.update(data);\n      try {\n        return verifier.verify(pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  })(),\n  isPrivateKey: function isPrivateKey() {\n    return this[SYM_PRIV_PEM] !== null;\n  },\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n  equals: function equals(key) {\n    const parsed = parseKey(key);\n    if (parsed instanceof Error) return false;\n    return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH].equals(parsed[SYM_PUB_SSH]);\n  }\n};\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n  OpenSSH_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    let ret;\n    const data = Buffer.from(m[1], 'base64');\n    if (data.length < 31)\n      // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    const magic = data.utf8Slice(0, 15);\n    if (magic !== 'openssh-key-v1\\0') return new Error(`Unsupported OpenSSH key magic: ${magic}`);\n    const cipherName = readString(data, 15, true);\n    if (cipherName === undefined) return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1) return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);\n    const kdfName = readString(data, data._pos, true);\n    if (kdfName === undefined) return new Error('Malformed OpenSSH private key');\n    if (kdfName !== 'none') {\n      if (cipherName === 'none') return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt') return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);\n      if (!passphrase) {\n        return new Error('Encrypted private OpenSSH key detected, but no passphrase given');\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n    let encInfo;\n    let cipherKey;\n    let cipherIV;\n    if (cipherName !== 'none') encInfo = CIPHER_INFO[cipherName];\n    const kdfOptions = readString(data, data._pos);\n    if (kdfOptions === undefined) return new Error('Malformed OpenSSH private key');\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n        case 'bcrypt':\n          {\n            /*\n              string salt\n              uint32 rounds\n            */\n            const salt = readString(kdfOptions, 0);\n            if (salt === undefined || kdfOptions._pos + 4 > kdfOptions.length) return new Error('Malformed OpenSSH private key');\n            const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n            const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n            const r = bcrypt_pbkdf(passphrase, passphrase.length, salt, salt.length, gen, gen.length, rounds);\n            if (r !== 0) return new Error('Failed to generate information to decrypt key');\n            cipherKey = bufferSlice(gen, 0, encInfo.keyLen);\n            cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);\n            break;\n          }\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n    if (data._pos + 3 >= data.length) return new Error('Malformed OpenSSH private key');\n    const keyCount = readUInt32BE(data, data._pos);\n    data._pos += 4;\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n\n      // Read public keys first\n      for (let i = 0; i < keyCount; ++i) {\n        const pubData = readString(data, data._pos);\n        if (pubData === undefined) return new Error('Malformed OpenSSH private key');\n        const type = readString(pubData, 0, true);\n        if (type === undefined) return new Error('Malformed OpenSSH private key');\n      }\n      let privBlob = readString(data, data._pos);\n      if (privBlob === undefined) return new Error('Malformed OpenSSH private key');\n      if (cipherKey !== undefined) {\n        // Encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n        try {\n          const options = {\n            authTagLength: encInfo.authLen\n          };\n          const decipher = createDecipheriv(encInfo.sslName, cipherKey, cipherIV, options);\n          decipher.setAutoPadding(false);\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen) return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(bufferSlice(data, data._pos, data._pos += encInfo.authLen));\n          }\n          privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      }\n      // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n      if (data._pos !== data.length) return new Error('Malformed OpenSSH private key');\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n    if (ret instanceof Error) return ret;\n    // This will need to change if/when OpenSSH ever starts storing multiple\n    // keys in their key files\n    return ret[0];\n  };\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    const keys = [];\n    /*\n      uint32  checkint\n      uint32  checkint\n      string  privatekey1\n      string  comment1\n      string  privatekey2\n      string  comment2\n      ...\n      string  privatekeyN\n      string  commentN\n      char  1\n      char  2\n      char  3\n      ...\n      char  padlen % 255\n    */\n    if (data.length < 8) return new Error('Malformed OpenSSH private key');\n    const check1 = readUInt32BE(data, 0);\n    const check2 = readUInt32BE(data, 4);\n    if (check1 !== check2) {\n      if (decrypted) {\n        return new Error('OpenSSH key integrity check failed -- bad passphrase?');\n      }\n      return new Error('OpenSSH key integrity check failed');\n    }\n    data._pos = 8;\n    let i;\n    let oid;\n    for (i = 0; i < nkeys; ++i) {\n      let algo;\n      let privPEM;\n      let pubPEM;\n      let pubSSH;\n      // The OpenSSH documentation for the key format actually lies, the\n      // entirety of the private key content is not contained with a string\n      // field, it's actually the literal contents of the private key, so to be\n      // able to find the end of the key data you need to know the layout/format\n      // of each key type ...\n      const type = readString(data, data._pos, true);\n      if (type === undefined) return new Error('Malformed OpenSSH private key');\n      switch (type) {\n        case 'ssh-rsa':\n          {\n            /*\n              string  n -- public\n              string  e -- public\n              string  d -- private\n              string  iqmp -- private\n              string  p -- private\n              string  q -- private\n            */\n            const n = readString(data, data._pos);\n            if (n === undefined) return new Error('Malformed OpenSSH private key');\n            const e = readString(data, data._pos);\n            if (e === undefined) return new Error('Malformed OpenSSH private key');\n            const d = readString(data, data._pos);\n            if (d === undefined) return new Error('Malformed OpenSSH private key');\n            const iqmp = readString(data, data._pos);\n            if (iqmp === undefined) return new Error('Malformed OpenSSH private key');\n            const p = readString(data, data._pos);\n            if (p === undefined) return new Error('Malformed OpenSSH private key');\n            const q = readString(data, data._pos);\n            if (q === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLRSAPub(n, e);\n            pubSSH = genOpenSSHRSAPub(n, e);\n            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n            algo = 'sha1';\n            break;\n          }\n        case 'ssh-dss':\n          {\n            /*\n              string  p -- public\n              string  q -- public\n              string  g -- public\n              string  y -- public\n              string  x -- private\n            */\n            const p = readString(data, data._pos);\n            if (p === undefined) return new Error('Malformed OpenSSH private key');\n            const q = readString(data, data._pos);\n            if (q === undefined) return new Error('Malformed OpenSSH private key');\n            const g = readString(data, data._pos);\n            if (g === undefined) return new Error('Malformed OpenSSH private key');\n            const y = readString(data, data._pos);\n            if (y === undefined) return new Error('Malformed OpenSSH private key');\n            const x = readString(data, data._pos);\n            if (x === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLDSAPub(p, q, g, y);\n            pubSSH = genOpenSSHDSAPub(p, q, g, y);\n            privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n            algo = 'sha1';\n            break;\n          }\n        case 'ssh-ed25519':\n          {\n            if (!eddsaSupported) return new Error(`Unsupported OpenSSH private key type: ${type}`);\n            /*\n              * string  public key\n              * string  private key + public key\n            */\n            const edpub = readString(data, data._pos);\n            if (edpub === undefined || edpub.length !== 32) return new Error('Malformed OpenSSH private key');\n            const edpriv = readString(data, data._pos);\n            if (edpriv === undefined || edpriv.length !== 64) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLEdPub(edpub);\n            pubSSH = genOpenSSHEdPub(edpub);\n            privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));\n            algo = null;\n            break;\n          }\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n        // FALLTHROUGH\n        case 'ecdsa-sha2-nistp521':\n          {\n            if (algo === undefined) {\n              algo = 'sha512';\n              oid = '1.3.132.0.35';\n            }\n            /*\n              string  curve name\n              string  Q -- public\n              string  d -- private\n            */\n            // TODO: validate curve name against type\n            if (!skipFields(data, 1))\n              // Skip curve name\n              return new Error('Malformed OpenSSH private key');\n            const ecpub = readString(data, data._pos);\n            if (ecpub === undefined) return new Error('Malformed OpenSSH private key');\n            const ecpriv = readString(data, data._pos);\n            if (ecpriv === undefined) return new Error('Malformed OpenSSH private key');\n            pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n            pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n            privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n            break;\n          }\n        default:\n          return new Error(`Unsupported OpenSSH private key type: ${type}`);\n      }\n      const privComment = readString(data, data._pos, true);\n      if (privComment === undefined) return new Error('Malformed OpenSSH private key');\n      keys.push(new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo, decrypted));\n    }\n    let cnt = 0;\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== ++cnt % 255) return new Error('Malformed OpenSSH private key');\n    }\n    return keys;\n  }\n}\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Old_Private.prototype = BaseKey;\n{\n  const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n  OpenSSH_Old_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    let privBlob = Buffer.from(m[3], 'base64');\n    let headers = m[2];\n    let decrypted = false;\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n      for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        let sepIdx = header.indexOf(':');\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          const val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1) continue;\n          const cipherName = val.slice(0, sepIdx).toLowerCase();\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(`Cipher (${cipherName}) not supported ` + 'for encrypted OpenSSH private key');\n          }\n          const encInfo = CIPHER_INFO_OPENSSL[cipherName];\n          if (!encInfo) {\n            return new Error(`Cipher (${cipherName}) not supported ` + 'for encrypted OpenSSH private key');\n          }\n          const cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen) return new Error('Malformed encrypted OpenSSH private key');\n          if (!passphrase) {\n            return new Error('Encrypted OpenSSH private key detected, but no passphrase given');\n          }\n          const ivSlice = bufferSlice(cipherIV, 0, 8);\n          let cipherKey = createHash('md5').update(passphrase).update(ivSlice).digest();\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(cipherKey, createHash('md5').update(cipherKey).update(passphrase).update(ivSlice).digest());\n          }\n          if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n          try {\n            const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n    let type;\n    let privPEM;\n    let pubPEM;\n    let pubSSH;\n    let algo;\n    let reader;\n    let errMsg = 'Malformed OpenSSH private key';\n    if (decrypted) errMsg += '. Bad passphrase?';\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const n = reader.readString(Ber.Integer, true);\n          if (n === null) return new Error(errMsg);\n          const e = reader.readString(Ber.Integer, true);\n          if (e === null) return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          const p = reader.readString(Ber.Integer, true);\n          if (p === null) return new Error(errMsg);\n          const q = reader.readString(Ber.Integer, true);\n          if (q === null) return new Error(errMsg);\n          const g = reader.readString(Ber.Integer, true);\n          if (g === null) return new Error(errMsg);\n          const y = reader.readString(Ber.Integer, true);\n          if (y === null) return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'EC':\n        {\n          let ecSSLName;\n          let ecPriv;\n          let ecOID;\n          try {\n            reader = new Ber.Reader(privBlob);\n            reader.readSequence();\n            reader.readInt(); // skip version\n            ecPriv = reader.readString(Ber.OctetString, true);\n            reader.readByte(); // Skip \"complex\" context type byte\n            const offset = reader.readLength(); // Skip context length\n            if (offset !== null) {\n              reader._offset = offset;\n              ecOID = reader.readOID();\n              if (ecOID === null) return new Error(errMsg);\n              switch (ecOID) {\n                case '1.2.840.10045.3.1.7':\n                  // prime256v1/secp256r1\n                  ecSSLName = 'prime256v1';\n                  type = 'ecdsa-sha2-nistp256';\n                  algo = 'sha256';\n                  break;\n                case '1.3.132.0.34':\n                  // secp384r1\n                  ecSSLName = 'secp384r1';\n                  type = 'ecdsa-sha2-nistp384';\n                  algo = 'sha384';\n                  break;\n                case '1.3.132.0.35':\n                  // secp521r1\n                  ecSSLName = 'secp521r1';\n                  type = 'ecdsa-sha2-nistp521';\n                  algo = 'sha512';\n                  break;\n                default:\n                  return new Error(`Unsupported private key EC OID: ${ecOID}`);\n              }\n            } else {\n              return new Error(errMsg);\n            }\n          } catch {\n            return new Error(errMsg);\n          }\n          privPEM = makePEM('EC PRIVATE', privBlob);\n          const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n          pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);\n          pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);\n          break;\n        }\n    }\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo, decrypted);\n  };\n}\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nPPK_Private.prototype = BaseKey;\n{\n  const EMPTY_PASSPHRASE = Buffer.alloc(0);\n  const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  const PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  const PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n  PPK_Private.parse = (str, passphrase) => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n    const cipherName = m[2];\n    const encrypted = cipherName !== 'none';\n    if (encrypted && !passphrase) {\n      return new Error('Encrypted PPK private key detected, but no passphrase given');\n    }\n    let privBlob = Buffer.from(m[5], 'base64');\n    if (encrypted) {\n      const encInfo = CIPHER_INFO[cipherName];\n      let cipherKey = combineBuffers(createHash('sha1').update(PPK_PP1).update(passphrase).digest(), createHash('sha1').update(PPK_PP2).update(passphrase).digest());\n      if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);\n      try {\n        const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob), decipher.final());\n      } catch (ex) {\n        return ex;\n      }\n    }\n    const type = m[1];\n    const comment = m[3];\n    const pubBlob = Buffer.from(m[4], 'base64');\n    const mac = m[6];\n    const typeLen = type.length;\n    const cipherNameLen = cipherName.length;\n    const commentLen = Buffer.byteLength(comment);\n    const pubLen = pubBlob.length;\n    const privLen = privBlob.length;\n    const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);\n    let p = 0;\n    writeUInt32BE(macData, typeLen, p);\n    macData.utf8Write(type, p += 4, typeLen);\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.utf8Write(cipherName, p += 4, cipherNameLen);\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.utf8Write(comment, p += 4, commentLen);\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    macData.set(pubBlob, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    macData.set(privBlob, p + 4);\n    if (!passphrase) passphrase = EMPTY_PASSPHRASE;\n    const calcMAC = createHmac('sha1', createHash('sha1').update('putty-private-key-file-mac-key').update(passphrase).digest()).update(macData).digest('hex');\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error('PPK private key integrity check failed -- bad passphrase?');\n      }\n      return new Error('PPK private key integrity check failed');\n    }\n    let pubPEM;\n    let pubSSH;\n    let privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n    switch (type) {\n      case 'ssh-rsa':\n        {\n          const e = readString(pubBlob, pubBlob._pos);\n          if (e === undefined) return new Error('Malformed PPK public key');\n          const n = readString(pubBlob, pubBlob._pos);\n          if (n === undefined) return new Error('Malformed PPK public key');\n          const d = readString(privBlob, 0);\n          if (d === undefined) return new Error('Malformed PPK private key');\n          const p = readString(privBlob, privBlob._pos);\n          if (p === undefined) return new Error('Malformed PPK private key');\n          const q = readString(privBlob, privBlob._pos);\n          if (q === undefined) return new Error('Malformed PPK private key');\n          const iqmp = readString(privBlob, privBlob._pos);\n          if (iqmp === undefined) return new Error('Malformed PPK private key');\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          break;\n        }\n      case 'ssh-dss':\n        {\n          const p = readString(pubBlob, pubBlob._pos);\n          if (p === undefined) return new Error('Malformed PPK public key');\n          const q = readString(pubBlob, pubBlob._pos);\n          if (q === undefined) return new Error('Malformed PPK public key');\n          const g = readString(pubBlob, pubBlob._pos);\n          if (g === undefined) return new Error('Malformed PPK public key');\n          const y = readString(pubBlob, pubBlob._pos);\n          if (y === undefined) return new Error('Malformed PPK public key');\n          const x = readString(privBlob, 0);\n          if (x === undefined) return new Error('Malformed PPK private key');\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          break;\n        }\n    }\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1', encrypted);\n  };\n}\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nOpenSSH_Public.prototype = BaseKey;\n{\n  let regexp;\n  if (eddsaSupported) regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;else regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  OpenSSH_Public.parse = str => {\n    const m = regexp.exec(str);\n    if (m === null) return null;\n    // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    const fullType = m[1];\n    const baseType = m[2];\n    const data = Buffer.from(m[3], 'base64');\n    const comment = m[4] || '';\n    const type = readString(data, data._pos, true);\n    if (type === undefined || type.indexOf(baseType) !== 0) return new Error('Malformed OpenSSH public key');\n    return parseDER(data, baseType, comment, fullType);\n  };\n}\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nRFC4716_Public.prototype = BaseKey;\n{\n  const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r?\\n)((?:.{0,72}\\r?\\n)+)---- END SSH2 PUBLIC KEY ----$/;\n  const RE_DATA = /^[A-Z0-9a-z/+=\\r\\n]+$/;\n  const RE_HEADER = /^([\\x21-\\x39\\x3B-\\x7E]{1,64}): ((?:[^\\\\]*\\\\\\r?\\n)*[^\\r\\n]+)\\r?\\n/gm;\n  const RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n  RFC4716_Public.parse = str => {\n    let m = regexp.exec(str);\n    if (m === null) return null;\n    const body = m[1];\n    let dataStart = 0;\n    let comment = '';\n    while (m = RE_HEADER.exec(body)) {\n      const headerName = m[1];\n      const headerValue = m[2].replace(RE_HEADER_ENDS, '');\n      if (headerValue.length > 1024) {\n        RE_HEADER.lastIndex = 0;\n        return new Error('Malformed RFC4716 public key');\n      }\n      dataStart = RE_HEADER.lastIndex;\n      if (headerName.toLowerCase() === 'comment') {\n        comment = headerValue;\n        if (comment.length > 1 && comment.charCodeAt(0) === 34 /* '\"' */ && comment.charCodeAt(comment.length - 1) === 34 /* '\"' */) {\n          comment = comment.slice(1, -1);\n        }\n      }\n    }\n    let data = body.slice(dataStart);\n    if (!RE_DATA.test(data)) return new Error('Malformed RFC4716 public key');\n    data = Buffer.from(data, 'base64');\n    const type = readString(data, 0, true);\n    if (type === undefined) return new Error('Malformed RFC4716 public key');\n    let pubPEM = null;\n    let pubSSH = null;\n    switch (type) {\n      case 'ssh-rsa':\n        {\n          const e = readString(data, data._pos);\n          if (e === undefined) return new Error('Malformed RFC4716 public key');\n          const n = readString(data, data._pos);\n          if (n === undefined) return new Error('Malformed RFC4716 public key');\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          break;\n        }\n      case 'ssh-dss':\n        {\n          const p = readString(data, data._pos);\n          if (p === undefined) return new Error('Malformed RFC4716 public key');\n          const q = readString(data, data._pos);\n          if (q === undefined) return new Error('Malformed RFC4716 public key');\n          const g = readString(data, data._pos);\n          if (g === undefined) return new Error('Malformed RFC4716 public key');\n          const y = readString(data, data._pos);\n          if (y === undefined) return new Error('Malformed RFC4716 public key');\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          break;\n        }\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n}\nfunction parseDER(data, baseType, comment, fullType) {\n  if (!isSupportedKeyType(baseType)) return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  let algo;\n  let oid;\n  let pubPEM = null;\n  let pubSSH = null;\n  switch (baseType) {\n    case 'ssh-rsa':\n      {\n        const e = readString(data, data._pos || 0);\n        if (e === undefined) return new Error('Malformed OpenSSH public key');\n        const n = readString(data, data._pos);\n        if (n === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        algo = 'sha1';\n        break;\n      }\n    case 'ssh-dss':\n      {\n        const p = readString(data, data._pos || 0);\n        if (p === undefined) return new Error('Malformed OpenSSH public key');\n        const q = readString(data, data._pos);\n        if (q === undefined) return new Error('Malformed OpenSSH public key');\n        const g = readString(data, data._pos);\n        if (g === undefined) return new Error('Malformed OpenSSH public key');\n        const y = readString(data, data._pos);\n        if (y === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        algo = 'sha1';\n        break;\n      }\n    case 'ssh-ed25519':\n      {\n        const edpub = readString(data, data._pos || 0);\n        if (edpub === undefined || edpub.length !== 32) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLEdPub(edpub);\n        pubSSH = genOpenSSHEdPub(edpub);\n        algo = null;\n        break;\n      }\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n    // FALLTHROUGH\n    case 'ecdsa-sha2-nistp521':\n      {\n        if (algo === undefined) {\n          algo = 'sha512';\n          oid = '1.3.132.0.35';\n        }\n        // TODO: validate curve name against type\n        if (!skipFields(data, 1))\n          // Skip curve name\n          return new Error('Malformed OpenSSH public key');\n        const ecpub = readString(data, data._pos || 0);\n        if (ecpub === undefined) return new Error('Malformed OpenSSH public key');\n        pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n        pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n        break;\n      }\n    default:\n      return new Error(`Unsupported OpenSSH public key type: ${baseType}`);\n  }\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\nfunction isSupportedKeyType(type) {\n  switch (type) {\n    case 'ssh-rsa':\n    case 'ssh-dss':\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return true;\n    case 'ssh-ed25519':\n      if (eddsaSupported) return true;\n    // FALLTHROUGH\n    default:\n      return false;\n  }\n}\nfunction isParsedKey(val) {\n  if (!val) return false;\n  return typeof val[SYM_DECRYPTED] === 'boolean';\n}\nfunction parseKey(data, passphrase) {\n  if (isParsedKey(data)) return data;\n  let origBuffer;\n  if (Buffer.isBuffer(data)) {\n    origBuffer = data;\n    data = data.utf8Slice(0, data.length).trim();\n  } else if (typeof data === 'string') {\n    data = data.trim();\n  } else {\n    return new Error('Key data must be a Buffer or string');\n  }\n\n  // eslint-disable-next-line eqeqeq\n  if (passphrase != undefined) {\n    if (typeof passphrase === 'string') passphrase = Buffer.from(passphrase);else if (!Buffer.isBuffer(passphrase)) return new Error('Passphrase must be a string or Buffer when supplied');\n  }\n  let ret;\n\n  // First try as printable string format (e.g. PEM)\n\n  // Private keys\n  if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null) return ret;\n  if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null) return ret;\n  if ((ret = PPK_Private.parse(data, passphrase)) !== null) return ret;\n\n  // Public keys\n  if ((ret = OpenSSH_Public.parse(data)) !== null) return ret;\n  if ((ret = RFC4716_Public.parse(data)) !== null) return ret;\n\n  // Finally try as a binary format if we were originally passed binary data\n  if (origBuffer) {\n    binaryKeyParser.init(origBuffer, 0);\n    const type = binaryKeyParser.readString(true);\n    if (type !== undefined) {\n      data = binaryKeyParser.readRaw();\n      if (data !== undefined) {\n        ret = parseDER(data, type, '', type);\n        // Ignore potentially useless errors in case the data was not actually\n        // in the binary format\n        if (ret instanceof Error) ret = null;\n      }\n    }\n    binaryKeyParser.clear();\n  }\n  if (ret) return ret;\n  return new Error('Unsupported key format');\n}\nmodule.exports = {\n  isParsedKey,\n  isSupportedKeyType,\n  parseDERKey: (data, type) => parseDER(data, type, '', type),\n  parseKey\n};","'use strict';\n\nconst assert = require('assert');\nconst {\n  inspect\n} = require('util');\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) res = `_${val.slice(i - 3, i)}${res}`;\n  return `${val.slice(0, i)}${res}`;\n}\nfunction oneOf(expected, thing) {\n  assert(typeof thing === 'string', '`thing` has to be of type string');\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    assert(len > 0, 'At least one expected value needs to be specified');\n    expected = expected.map(i => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    }\n    return `of ${thing} ${expected[0]}`;\n  }\n  return `of ${thing} ${String(expected)}`;\n}\nexports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {\n  constructor(message) {\n    super();\n    Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);\n    const suffix = 'This is caused by either a bug in ssh2 ' + 'or incorrect usage of ssh2 internals.\\n' + 'Please open an issue with this stack trace at ' + 'https://github.com/mscdex/ssh2/issues\\n';\n    this.message = message === undefined ? suffix : `${message}\\n${suffix}`;\n  }\n};\nconst MAX_32BIT_INT = 2 ** 32;\nconst MAX_32BIT_BIGINT = (() => {\n  try {\n    return new Function('return 2n ** 32n')();\n  } catch {}\n})();\nexports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {\n  constructor(str, range, input, replaceDefaultBoolean) {\n    super();\n    Error.captureStackTrace(this, ERR_OUT_OF_RANGE);\n    assert(range, 'Missing \"range\" argument');\n    let msg = replaceDefaultBoolean ? str : `The value of \"${str}\" is out of range.`;\n    let received;\n    if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT) received = addNumericalSeparator(received);\n      received += 'n';\n    } else {\n      received = inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    this.message = msg;\n  }\n};\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super();\n    Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE);\n    assert(typeof name === 'string', `'name' must be a string`);\n\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.startsWith('not ')) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n    let msg;\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n    } else {\n      const type = name.includes('.') ? 'property' : 'argument';\n      msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n    }\n    msg += `. Received type ${typeof actual}`;\n    this.message = msg;\n  }\n}\nexports.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;\nexports.validateNumber = function validateNumber(value, name) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n};","'use strict';\n\nconst Ber = require('asn1').Ber;\nlet DISCONNECT_REASON;\nconst FastBuffer = Buffer[Symbol.species];\nconst TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;\nfunction readUInt32BE(buf, offset) {\n  return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];\n}\nfunction bufferCopy(src, dest, srcStart, srcEnd, destStart) {\n  if (!destStart) destStart = 0;\n  if (srcEnd > src.length) srcEnd = src.length;\n  let nb = srcEnd - srcStart;\n  const destLeft = dest.length - destStart;\n  if (nb > destLeft) nb = destLeft;\n  dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb), destStart);\n  return nb;\n}\nfunction bufferSlice(buf, start, end) {\n  if (end === undefined) end = buf.length;\n  return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);\n}\nfunction makeBufferParser() {\n  let pos = 0;\n  let buffer;\n  const self = {\n    init: (buf, start) => {\n      buffer = buf;\n      pos = typeof start === 'number' ? start : 0;\n    },\n    pos: () => pos,\n    length: () => buffer ? buffer.length : 0,\n    avail: () => buffer && pos < buffer.length ? buffer.length - pos : 0,\n    clear: () => {\n      buffer = undefined;\n    },\n    readUInt32BE: () => {\n      if (!buffer || pos + 3 >= buffer.length) return;\n      return buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];\n    },\n    readUInt64BE: behavior => {\n      if (!buffer || pos + 7 >= buffer.length) return;\n      switch (behavior) {\n        case 'always':\n          return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        case 'maybe':\n          if (buffer[pos] > 0x1F) return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);\n        // FALLTHROUGH\n        default:\n          return buffer[pos++] * 72057594037927940 + buffer[pos++] * 281474976710656 + buffer[pos++] * 1099511627776 + buffer[pos++] * 4294967296 + buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];\n      }\n    },\n    skip: n => {\n      if (buffer && n > 0) pos += n;\n    },\n    skipString: () => {\n      const len = self.readUInt32BE();\n      if (len === undefined) return;\n      pos += len;\n      return pos <= buffer.length ? len : undefined;\n    },\n    readByte: () => {\n      if (buffer && pos < buffer.length) return buffer[pos++];\n    },\n    readBool: () => {\n      if (buffer && pos < buffer.length) return !!buffer[pos++];\n    },\n    readList: () => {\n      const list = self.readString(true);\n      if (list === undefined) return;\n      return list ? list.split(',') : [];\n    },\n    readString: (dest, maxLen) => {\n      if (typeof dest === 'number') {\n        maxLen = dest;\n        dest = undefined;\n      }\n      const len = self.readUInt32BE();\n      if (len === undefined) return;\n      if (buffer.length - pos < len || typeof maxLen === 'number' && len > maxLen) {\n        return;\n      }\n      if (dest) {\n        if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, pos, pos += len);\n        return buffer.utf8Slice(pos, pos += len);\n      }\n      return bufferSlice(buffer, pos, pos += len);\n    },\n    readRaw: len => {\n      if (!buffer) return;\n      if (typeof len !== 'number') return bufferSlice(buffer, pos, pos += buffer.length - pos);\n      if (buffer.length - pos >= len) return bufferSlice(buffer, pos, pos += len);\n    }\n  };\n  return self;\n}\nfunction makeError(msg, level, fatal) {\n  const err = new Error(msg);\n  if (typeof level === 'boolean') {\n    fatal = level;\n    err.level = 'protocol';\n  } else {\n    err.level = level || 'protocol';\n  }\n  err.fatal = !!fatal;\n  return err;\n}\nfunction writeUInt32BE(buf, value, offset) {\n  buf[offset++] = value >>> 24;\n  buf[offset++] = value >>> 16;\n  buf[offset++] = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\nconst utilBufferParser = makeBufferParser();\nmodule.exports = {\n  bufferCopy,\n  bufferSlice,\n  FastBuffer,\n  bufferFill: (buf, value, start, end) => {\n    return TypedArrayFill.call(buf, value, start, end);\n  },\n  makeError,\n  doFatalError: (protocol, msg, level, reason) => {\n    let err;\n    if (DISCONNECT_REASON === undefined) ({\n      DISCONNECT_REASON\n    } = require('./constants.js'));\n    if (msg instanceof Error) {\n      // doFatalError(protocol, err[, reason])\n      err = msg;\n      if (typeof level !== 'number') reason = DISCONNECT_REASON.PROTOCOL_ERROR;else reason = level;\n    } else {\n      // doFatalError(protocol, msg[, level[, reason]])\n      err = makeError(msg, level, true);\n    }\n    if (typeof reason !== 'number') reason = DISCONNECT_REASON.PROTOCOL_ERROR;\n    protocol.disconnect(reason);\n    protocol._destruct();\n    protocol._onError(err);\n    return Infinity;\n  },\n  readUInt32BE,\n  writeUInt32BE,\n  writeUInt32LE: (buf, value, offset) => {\n    buf[offset++] = value;\n    buf[offset++] = value >>> 8;\n    buf[offset++] = value >>> 16;\n    buf[offset++] = value >>> 24;\n    return offset;\n  },\n  makeBufferParser,\n  bufferParser: makeBufferParser(),\n  readString: (buffer, start, dest, maxLen) => {\n    if (typeof dest === 'number') {\n      maxLen = dest;\n      dest = undefined;\n    }\n    if (start === undefined) start = 0;\n    const left = buffer.length - start;\n    if (start < 0 || start >= buffer.length || left < 4) return;\n    const len = readUInt32BE(buffer, start);\n    if (left < 4 + len || typeof maxLen === 'number' && len > maxLen) return;\n    start += 4;\n    const end = start + len;\n    buffer._pos = end;\n    if (dest) {\n      if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, start, end);\n      return buffer.utf8Slice(start, end);\n    }\n    return bufferSlice(buffer, start, end);\n  },\n  sigSSHToASN1: (sig, type) => {\n    switch (type) {\n      case 'ssh-dss':\n        {\n          if (sig.length > 40) return sig;\n          // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n          const asnWriter = new Ber.Writer();\n          asnWriter.startSequence();\n          let r = sig.slice(0, 20);\n          let s = sig.slice(20);\n          if (r[0] & 0x80) {\n            const rNew = Buffer.allocUnsafe(21);\n            rNew[0] = 0x00;\n            r.copy(rNew, 1);\n            r = rNew;\n          } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n            r = r.slice(1);\n          }\n          if (s[0] & 0x80) {\n            const sNew = Buffer.allocUnsafe(21);\n            sNew[0] = 0x00;\n            s.copy(sNew, 1);\n            s = sNew;\n          } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n            s = s.slice(1);\n          }\n          asnWriter.writeBuffer(r, Ber.Integer);\n          asnWriter.writeBuffer(s, Ber.Integer);\n          asnWriter.endSequence();\n          return asnWriter.buffer;\n        }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521':\n        {\n          utilBufferParser.init(sig, 0);\n          const r = utilBufferParser.readString();\n          const s = utilBufferParser.readString();\n          utilBufferParser.clear();\n          if (r === undefined || s === undefined) return;\n          const asnWriter = new Ber.Writer();\n          asnWriter.startSequence();\n          asnWriter.writeBuffer(r, Ber.Integer);\n          asnWriter.writeBuffer(s, Ber.Integer);\n          asnWriter.endSequence();\n          return asnWriter.buffer;\n        }\n      default:\n        return sig;\n    }\n  },\n  convertSignature: (signature, keyType) => {\n    switch (keyType) {\n      case 'ssh-dss':\n        {\n          if (signature.length <= 40) return signature;\n          // This is a quick and dirty way to get from BER encoded r and s that\n          // OpenSSL gives us, to just the bare values back to back (40 bytes\n          // total) like OpenSSH (and possibly others) are expecting\n          const asnReader = new Ber.Reader(signature);\n          asnReader.readSequence();\n          let r = asnReader.readString(Ber.Integer, true);\n          let s = asnReader.readString(Ber.Integer, true);\n          let rOffset = 0;\n          let sOffset = 0;\n          if (r.length < 20) {\n            const rNew = Buffer.allocUnsafe(20);\n            rNew.set(r, 1);\n            r = rNew;\n            r[0] = 0;\n          }\n          if (s.length < 20) {\n            const sNew = Buffer.allocUnsafe(20);\n            sNew.set(s, 1);\n            s = sNew;\n            s[0] = 0;\n          }\n          if (r.length > 20 && r[0] === 0) rOffset = 1;\n          if (s.length > 20 && s[0] === 0) sOffset = 1;\n          const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));\n          bufferCopy(r, newSig, rOffset, r.length, 0);\n          bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);\n          return newSig;\n        }\n      case 'ecdsa-sha2-nistp256':\n      case 'ecdsa-sha2-nistp384':\n      case 'ecdsa-sha2-nistp521':\n        {\n          if (signature[0] === 0) return signature;\n          // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n          const asnReader = new Ber.Reader(signature);\n          asnReader.readSequence();\n          const r = asnReader.readString(Ber.Integer, true);\n          const s = asnReader.readString(Ber.Integer, true);\n          if (r === null || s === null) return;\n          const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n          writeUInt32BE(newSig, r.length, 0);\n          newSig.set(r, 4);\n          writeUInt32BE(newSig, s.length, 4 + r.length);\n          newSig.set(s, 4 + 4 + r.length);\n          return newSig;\n        }\n    }\n    return signature;\n  },\n  sendPacket: (proto, packet, bypass) => {\n    if (!bypass && proto._kexinit !== undefined) {\n      // We're currently in the middle of a handshake\n\n      if (proto._queue === undefined) proto._queue = [];\n      proto._queue.push(packet);\n      proto._debug && proto._debug('Outbound: ... packet queued');\n      return false;\n    }\n    proto._cipher.encrypt(packet);\n    return true;\n  }\n};","'use strict';\n\nconst {\n  kMaxLength\n} = require('buffer');\nconst {\n  createInflate,\n  constants: {\n    DEFLATE,\n    INFLATE,\n    Z_DEFAULT_CHUNK,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_MEMLEVEL,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFAULT_WINDOWBITS,\n    Z_PARTIAL_FLUSH\n  }\n} = require('zlib');\nconst ZlibHandle = createInflate()._handle.constructor;\nfunction processCallback() {\n  throw new Error('Should not get here');\n}\nfunction zlibOnError(message, errno, code) {\n  const self = this._owner;\n  // There is no way to cleanly recover.\n  // Continuing only obscures problems.\n\n  const error = new Error(message);\n  error.errno = errno;\n  error.code = code;\n  self._err = error;\n}\nfunction _close(engine) {\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n  engine._handle.close();\n  engine._handle = null;\n}\nclass Zlib {\n  constructor(mode) {\n    const windowBits = Z_DEFAULT_WINDOWBITS;\n    const level = Z_DEFAULT_COMPRESSION;\n    const memLevel = Z_DEFAULT_MEMLEVEL;\n    const strategy = Z_DEFAULT_STRATEGY;\n    const dictionary = undefined;\n    this._err = undefined;\n    this._writeState = new Uint32Array(2);\n    this._chunkSize = Z_DEFAULT_CHUNK;\n    this._maxOutputLength = kMaxLength;\n    this._outBuffer = Buffer.allocUnsafe(this._chunkSize);\n    this._outOffset = 0;\n    this._handle = new ZlibHandle(mode);\n    this._handle._owner = this;\n    this._handle.onerror = zlibOnError;\n    this._handle.init(windowBits, level, memLevel, strategy, this._writeState, processCallback, dictionary);\n  }\n  writeSync(chunk, retChunks) {\n    const handle = this._handle;\n    if (!handle) throw new Error('Invalid Zlib instance');\n    let availInBefore = chunk.length;\n    let availOutBefore = this._chunkSize - this._outOffset;\n    let inOff = 0;\n    let availOutAfter;\n    let availInAfter;\n    let buffers;\n    let nread = 0;\n    const state = this._writeState;\n    let buffer = this._outBuffer;\n    let offset = this._outOffset;\n    const chunkSize = this._chunkSize;\n    while (true) {\n      handle.writeSync(Z_PARTIAL_FLUSH, chunk,\n      // in\n      inOff,\n      // in_off\n      availInBefore,\n      // in_len\n      buffer,\n      // out\n      offset,\n      // out_off\n      availOutBefore); // out_len\n      if (this._err) throw this._err;\n      availOutAfter = state[0];\n      availInAfter = state[1];\n      const inDelta = availInBefore - availInAfter;\n      const have = availOutBefore - availOutAfter;\n      if (have > 0) {\n        const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);\n        offset += have;\n        if (!buffers) buffers = out;else if (buffers.push === undefined) buffers = [buffers, out];else buffers.push(out);\n        nread += out.byteLength;\n        if (nread > this._maxOutputLength) {\n          _close(this);\n          throw new Error(`Output length exceeded maximum of ${this._maxOutputLength}`);\n        }\n      } else if (have !== 0) {\n        throw new Error('have should not go down');\n      }\n\n      // Exhausted the output buffer, or used all the input create a new one.\n      if (availOutAfter === 0 || offset >= chunkSize) {\n        availOutBefore = chunkSize;\n        offset = 0;\n        buffer = Buffer.allocUnsafe(chunkSize);\n      }\n      if (availOutAfter === 0) {\n        // Not actually done. Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += inDelta;\n        availInBefore = availInAfter;\n      } else {\n        break;\n      }\n    }\n    this._outBuffer = buffer;\n    this._outOffset = offset;\n    if (nread === 0) buffers = Buffer.alloc(0);\n    if (retChunks) {\n      buffers.totalLen = nread;\n      return buffers;\n    }\n    if (buffers.push === undefined) return buffers;\n    const output = Buffer.allocUnsafe(nread);\n    for (let i = 0, p = 0; i < buffers.length; ++i) {\n      const buf = buffers[i];\n      output.set(buf, p);\n      p += buf.length;\n    }\n    return output;\n  }\n}\nclass ZlibPacketWriter {\n  constructor(protocol) {\n    this.allocStart = 0;\n    this.allocStartKEX = 0;\n    this._protocol = protocol;\n    this._zlib = new Zlib(DEFLATE);\n  }\n  cleanup() {\n    if (this._zlib) _close(this._zlib);\n  }\n  alloc(payloadSize, force) {\n    return Buffer.allocUnsafe(payloadSize);\n  }\n  finalize(payload, force) {\n    if (this._protocol._kexinit === undefined || force) {\n      const output = this._zlib.writeSync(payload, true);\n      const packet = this._protocol._cipher.allocPacket(output.totalLen);\n      if (output.push === undefined) {\n        packet.set(output, 5);\n      } else {\n        for (let i = 0, p = 5; i < output.length; ++i) {\n          const chunk = output[i];\n          packet.set(chunk, p);\n          p += chunk.length;\n        }\n      }\n      return packet;\n    }\n    return payload;\n  }\n}\nclass PacketWriter {\n  constructor(protocol) {\n    this.allocStart = 5;\n    this.allocStartKEX = 5;\n    this._protocol = protocol;\n  }\n  cleanup() {}\n  alloc(payloadSize, force) {\n    if (this._protocol._kexinit === undefined || force) return this._protocol._cipher.allocPacket(payloadSize);\n    return Buffer.allocUnsafe(payloadSize);\n  }\n  finalize(packet, force) {\n    return packet;\n  }\n}\nclass ZlibPacketReader {\n  constructor() {\n    this._zlib = new Zlib(INFLATE);\n  }\n  cleanup() {\n    if (this._zlib) _close(this._zlib);\n  }\n  read(data) {\n    return this._zlib.writeSync(data, false);\n  }\n}\nclass PacketReader {\n  cleanup() {}\n  read(data) {\n    return data;\n  }\n}\nmodule.exports = {\n  PacketReader,\n  PacketWriter,\n  ZlibPacketReader,\n  ZlibPacketWriter\n};","// TODO:\n//   * convert listenerCount() usage to emit() return value checking?\n//   * emit error when connection severed early (e.g. before handshake)\n//   * add '.connected' or similar property to connection objects to allow\n//     immediate connection status checking\n'use strict';\n\nconst {\n  Server: netServer\n} = require('net');\nconst EventEmitter = require('events');\nconst {\n  listenerCount\n} = EventEmitter;\nconst {\n  CHANNEL_OPEN_FAILURE,\n  DEFAULT_CIPHER,\n  DEFAULT_COMPRESSION,\n  DEFAULT_KEX,\n  DEFAULT_MAC,\n  DEFAULT_SERVER_HOST_KEY,\n  DISCONNECT_REASON,\n  DISCONNECT_REASON_BY_VALUE,\n  SUPPORTED_CIPHER,\n  SUPPORTED_COMPRESSION,\n  SUPPORTED_KEX,\n  SUPPORTED_MAC,\n  SUPPORTED_SERVER_HOST_KEY\n} = require('./protocol/constants.js');\nconst {\n  init: cryptoInit\n} = require('./protocol/crypto.js');\nconst {\n  KexInit\n} = require('./protocol/kex.js');\nconst {\n  parseKey\n} = require('./protocol/keyParser.js');\nconst Protocol = require('./protocol/Protocol.js');\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst {\n  writeUInt32BE\n} = require('./protocol/utils.js');\nconst {\n  Channel,\n  MAX_WINDOW,\n  PACKET_SIZE,\n  windowAdjust,\n  WINDOW_THRESHOLD\n} = require('./Channel.js');\nconst {\n  ChannelManager,\n  generateAlgorithmList,\n  isWritable,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE\n} = require('./utils.js');\nconst MAX_PENDING_AUTHS = 10;\nclass AuthContext extends EventEmitter {\n  constructor(protocol, username, service, method, cb) {\n    super();\n    this.username = this.user = username;\n    this.service = service;\n    this.method = method;\n    this._initialResponse = false;\n    this._finalResponse = false;\n    this._multistep = false;\n    this._cbfinal = (allowed, methodsLeft, isPartial) => {\n      if (!this._finalResponse) {\n        this._finalResponse = true;\n        cb(this, allowed, methodsLeft, isPartial);\n      }\n    };\n    this._protocol = protocol;\n  }\n  accept() {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(true);\n  }\n  reject(methodsLeft, isPartial) {\n    this._cleanup && this._cleanup();\n    this._initialResponse = true;\n    this._cbfinal(false, methodsLeft, isPartial);\n  }\n}\nclass KeyboardAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, submethods, cb) {\n    super(protocol, username, service, method, cb);\n    this._multistep = true;\n    this._cb = undefined;\n    this._onInfoResponse = responses => {\n      const callback = this._cb;\n      if (callback) {\n        this._cb = undefined;\n        callback(responses);\n      }\n    };\n    this.submethods = submethods;\n    this.on('abort', () => {\n      this._cb && this._cb(new Error('Authentication request aborted'));\n    });\n  }\n  prompt(prompts, title, instructions, cb) {\n    if (!Array.isArray(prompts)) prompts = [prompts];\n    if (typeof title === 'function') {\n      cb = title;\n      title = instructions = undefined;\n    } else if (typeof instructions === 'function') {\n      cb = instructions;\n      instructions = undefined;\n    } else if (typeof cb !== 'function') {\n      cb = undefined;\n    }\n    for (let i = 0; i < prompts.length; ++i) {\n      if (typeof prompts[i] === 'string') {\n        prompts[i] = {\n          prompt: prompts[i],\n          echo: true\n        };\n      }\n    }\n    this._cb = cb;\n    this._initialResponse = true;\n    this._protocol.authInfoReq(title, instructions, prompts);\n  }\n}\nclass PKAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n    this.key = {\n      algo: pkInfo.keyAlgo,\n      data: pkInfo.key\n    };\n    this.hashAlgo = pkInfo.hashAlgo;\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n  }\n  accept() {\n    if (!this.signature) {\n      this._initialResponse = true;\n      this._protocol.authPKOK(this.key.algo, this.key.data);\n    } else {\n      AuthContext.prototype.accept.call(this);\n    }\n  }\n}\nclass HostbasedAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, pkInfo, cb) {\n    super(protocol, username, service, method, cb);\n    this.key = {\n      algo: pkInfo.keyAlgo,\n      data: pkInfo.key\n    };\n    this.hashAlgo = pkInfo.hashAlgo;\n    this.signature = pkInfo.signature;\n    this.blob = pkInfo.blob;\n    this.localHostname = pkInfo.localHostname;\n    this.localUsername = pkInfo.localUsername;\n  }\n}\nclass PwdAuthContext extends AuthContext {\n  constructor(protocol, username, service, method, password, cb) {\n    super(protocol, username, service, method, cb);\n    this.password = password;\n    this._changeCb = undefined;\n  }\n  requestChange(prompt, cb) {\n    if (this._changeCb) throw new Error('Change request already in progress');\n    if (typeof prompt !== 'string') throw new Error('prompt argument must be a string');\n    if (typeof cb !== 'function') throw new Error('Callback argument must be a function');\n    this._changeCb = cb;\n    this._protocol.authPasswdChg(prompt);\n  }\n}\nclass Session extends EventEmitter {\n  constructor(client, info, localChan) {\n    super();\n    this.type = 'session';\n    this.subtype = undefined;\n    this.server = true;\n    this._ending = false;\n    this._channel = undefined;\n    this._chanInfo = {\n      type: 'session',\n      incoming: {\n        id: localChan,\n        window: MAX_WINDOW,\n        packetSize: PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n  }\n}\nclass Server extends EventEmitter {\n  constructor(cfg, listener) {\n    super();\n    if (typeof cfg !== 'object' || cfg === null) throw new Error('Missing configuration object');\n    const hostKeys = Object.create(null);\n    const hostKeyAlgoOrder = [];\n    const hostKeys_ = cfg.hostKeys;\n    if (!Array.isArray(hostKeys_)) throw new Error('hostKeys must be an array');\n    const cfgAlgos = typeof cfg.algorithms === 'object' && cfg.algorithms !== null ? cfg.algorithms : {};\n    const hostKeyAlgos = generateAlgorithmList(cfgAlgos.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);\n    for (let i = 0; i < hostKeys_.length; ++i) {\n      let privateKey;\n      if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string') privateKey = parseKey(hostKeys_[i]);else privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n      if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);\n      if (Array.isArray(privateKey)) {\n        // OpenSSH's newer format only stores 1 key for now\n        privateKey = privateKey[0];\n      }\n      if (privateKey.getPrivatePEM() === null) throw new Error('privateKey value contains an invalid private key');\n\n      // Discard key if we already found a key of the same type\n      if (hostKeyAlgoOrder.includes(privateKey.type)) continue;\n      if (privateKey.type === 'ssh-rsa') {\n        // SSH supports multiple signature hashing algorithms for RSA, so we add\n        // the algorithms in the desired order\n        let sha1Pos = hostKeyAlgos.indexOf('ssh-rsa');\n        const sha256Pos = hostKeyAlgos.indexOf('rsa-sha2-256');\n        const sha512Pos = hostKeyAlgos.indexOf('rsa-sha2-512');\n        if (sha1Pos === -1) {\n          // Fall back to giving SHA1 the lowest priority\n          sha1Pos = Infinity;\n        }\n        [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach(pos => {\n          if (pos === -1) return;\n          let type;\n          switch (pos) {\n            case sha1Pos:\n              type = 'ssh-rsa';\n              break;\n            case sha256Pos:\n              type = 'rsa-sha2-256';\n              break;\n            case sha512Pos:\n              type = 'rsa-sha2-512';\n              break;\n            default:\n              return;\n          }\n\n          // Store same RSA key under each hash algorithm name for convenience\n          hostKeys[type] = privateKey;\n          hostKeyAlgoOrder.push(type);\n        });\n      } else {\n        hostKeys[privateKey.type] = privateKey;\n        hostKeyAlgoOrder.push(privateKey.type);\n      }\n    }\n    const algorithms = {\n      kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX).concat(['kex-strict-s-v00@openssh.com']),\n      serverHostKey: hostKeyAlgoOrder,\n      cs: {\n        cipher: generateAlgorithmList(cfgAlgos.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER),\n        mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),\n        compress: generateAlgorithmList(cfgAlgos.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION),\n        lang: []\n      },\n      sc: undefined\n    };\n    algorithms.sc = algorithms.cs;\n    if (typeof listener === 'function') this.on('connection', listener);\n    const origDebug = typeof cfg.debug === 'function' ? cfg.debug : undefined;\n    const ident = cfg.ident ? Buffer.from(cfg.ident) : undefined;\n    const offer = new KexInit(algorithms);\n    this._srv = new netServer(socket => {\n      if (this._connections >= this.maxConnections) {\n        socket.destroy();\n        return;\n      }\n      ++this._connections;\n      socket.once('close', () => {\n        --this._connections;\n      });\n      let debug;\n      if (origDebug) {\n        // Prepend debug output with a unique identifier in case there are\n        // multiple clients connected at the same time\n        const debugPrefix = `[${process.hrtime().join('.')}] `;\n        debug = msg => {\n          origDebug(`${debugPrefix}${msg}`);\n        };\n      }\n\n      // eslint-disable-next-line no-use-before-define\n      new Client(socket, hostKeys, ident, offer, debug, this, cfg);\n    }).on('error', err => {\n      this.emit('error', err);\n    }).on('listening', () => {\n      this.emit('listening');\n    }).on('close', () => {\n      this.emit('close');\n    });\n    this._connections = 0;\n    this.maxConnections = Infinity;\n  }\n  injectSocket(socket) {\n    this._srv.emit('connection', socket);\n  }\n  listen(...args) {\n    this._srv.listen(...args);\n    return this;\n  }\n  address() {\n    return this._srv.address();\n  }\n  getConnections(cb) {\n    this._srv.getConnections(cb);\n    return this;\n  }\n  close(cb) {\n    this._srv.close(cb);\n    return this;\n  }\n  ref() {\n    this._srv.ref();\n    return this;\n  }\n  unref() {\n    this._srv.unref();\n    return this;\n  }\n}\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\nclass Client extends EventEmitter {\n  constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {\n    super();\n    let exchanges = 0;\n    let acceptedAuthSvc = false;\n    let pendingAuths = [];\n    let authCtx;\n    let kaTimer;\n    let onPacket;\n    const unsentGlobalRequestsReplies = [];\n    this._sock = socket;\n    this._chanMgr = new ChannelManager(this);\n    this._debug = debug;\n    this.noMoreSessions = false;\n    this.authenticated = false;\n\n    // Silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    this.on('error', onClientPreHeaderError);\n    const DEBUG_HANDLER = !debug ? undefined : (p, display, msg) => {\n      debug(`Debug output from client: ${JSON.stringify(msg)}`);\n    };\n    const kaIntvl = typeof srvCfg.keepaliveInterval === 'number' && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === 'number' && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;\n    const kaCountMax = typeof srvCfg.keepaliveCountMax === 'number' && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === 'number' && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;\n    let kaCurCount = 0;\n    if (kaIntvl !== -1 && kaCountMax !== -1) {\n      this.once('ready', () => {\n        const onClose = () => {\n          clearInterval(kaTimer);\n        };\n        this.on('close', onClose).on('end', onClose);\n        kaTimer = setInterval(() => {\n          if (++kaCurCount > kaCountMax) {\n            clearInterval(kaTimer);\n            const err = new Error('Keepalive timeout');\n            err.level = 'client-timeout';\n            this.emit('error', err);\n            this.end();\n          } else {\n            // XXX: if the server ever starts sending real global requests to\n            //      the client, we will need to add a dummy callback here to\n            //      keep the correct reply order\n            proto.ping();\n          }\n        }, kaIntvl);\n      });\n      // TODO: re-verify keepalive behavior with OpenSSH\n      onPacket = () => {\n        kaTimer && kaTimer.refresh();\n        kaCurCount = 0;\n      };\n    }\n    const proto = this._protocol = new Protocol({\n      server: true,\n      hostKeys,\n      ident,\n      offer,\n      onPacket,\n      greeting: srvCfg.greeting,\n      banner: srvCfg.banner,\n      onWrite: data => {\n        if (isWritable(socket)) socket.write(data);\n      },\n      onError: err => {\n        if (!proto._destruct) socket.removeAllListeners('data');\n        this.emit('error', err);\n        try {\n          socket.end();\n        } catch {}\n      },\n      onHeader: header => {\n        this.removeListener('error', onClientPreHeaderError);\n        const info = {\n          ip: socket.remoteAddress,\n          family: socket.remoteFamily,\n          port: socket.remotePort,\n          header\n        };\n        if (!server.emit('connection', this, info)) {\n          // auto reject\n          proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n          socket.end();\n          return;\n        }\n        if (header.greeting) this.emit('greeting', header.greeting);\n      },\n      onHandshakeComplete: negotiated => {\n        if (++exchanges > 1) this.emit('rekey');\n        this.emit('handshake', negotiated);\n      },\n      debug,\n      messageHandlers: {\n        DEBUG: DEBUG_HANDLER,\n        DISCONNECT: (p, reason, desc) => {\n          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {\n            if (!desc) {\n              desc = DISCONNECT_REASON_BY_VALUE[reason];\n              if (desc === undefined) desc = `Unexpected disconnection reason: ${reason}`;\n            }\n            const err = new Error(desc);\n            err.code = reason;\n            this.emit('error', err);\n          }\n          socket.end();\n        },\n        CHANNEL_OPEN: (p, info) => {\n          // Handle incoming requests from client\n\n          // Do early reject in some cases to prevent wasteful channel\n          // allocation\n          if (info.type === 'session' && this.noMoreSessions || !this.authenticated) {\n            const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            return proto.channelOpenFail(info.sender, reasonCode);\n          }\n          let localChan = -1;\n          let reason;\n          let replied = false;\n          let accept;\n          const reject = () => {\n            if (replied) return;\n            replied = true;\n            if (reason === undefined) {\n              if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n            }\n            if (localChan !== -1) this._chanMgr.remove(localChan);\n            proto.channelOpenFail(info.sender, reason, '');\n          };\n          const reserveChannel = () => {\n            localChan = this._chanMgr.add();\n            if (localChan === -1) {\n              reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n              if (debug) {\n                debug('Automatic rejection of incoming channel open: ' + 'no channels available');\n              }\n            }\n            return localChan !== -1;\n          };\n          const data = info.data;\n          switch (info.type) {\n            case 'session':\n              if (listenerCount(this, 'session') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const instance = new Session(this, info, localChan);\n                  this._chanMgr.update(localChan, instance);\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return instance;\n                };\n                this.emit('session', accept, reject);\n                return;\n              }\n              break;\n            case 'direct-tcpip':\n              if (listenerCount(this, 'tcpip') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n                  const stream = new Channel(this, chanInfo, {\n                    server: true\n                  });\n                  this._chanMgr.update(localChan, stream);\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return stream;\n                };\n                this.emit('tcpip', accept, reject, data);\n                return;\n              }\n              break;\n            case 'direct-streamlocal@openssh.com':\n              if (listenerCount(this, 'openssh.streamlocal') && reserveChannel()) {\n                accept = () => {\n                  if (replied) return;\n                  replied = true;\n                  const chanInfo = {\n                    type: undefined,\n                    incoming: {\n                      id: localChan,\n                      window: MAX_WINDOW,\n                      packetSize: PACKET_SIZE,\n                      state: 'open'\n                    },\n                    outgoing: {\n                      id: info.sender,\n                      window: info.window,\n                      packetSize: info.packetSize,\n                      state: 'open'\n                    }\n                  };\n                  const stream = new Channel(this, chanInfo, {\n                    server: true\n                  });\n                  this._chanMgr.update(localChan, stream);\n                  proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);\n                  return stream;\n                };\n                this.emit('openssh.streamlocal', accept, reject, data);\n                return;\n              }\n              break;\n            default:\n              // Automatically reject any unsupported channel open requests\n              reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n              if (debug) {\n                debug('Automatic rejection of unsupported incoming channel open' + ` type: ${info.type}`);\n              }\n          }\n          if (reason === undefined) {\n            reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n            if (debug) {\n              debug('Automatic rejection of unexpected incoming channel open' + ` for: ${info.type}`);\n            }\n          }\n          reject();\n        },\n        CHANNEL_OPEN_CONFIRMATION: (p, info) => {\n          const channel = this._chanMgr.get(info.recipient);\n          if (typeof channel !== 'function') return;\n          const chanInfo = {\n            type: channel.type,\n            incoming: {\n              id: info.recipient,\n              window: MAX_WINDOW,\n              packetSize: PACKET_SIZE,\n              state: 'open'\n            },\n            outgoing: {\n              id: info.sender,\n              window: info.window,\n              packetSize: info.packetSize,\n              state: 'open'\n            }\n          };\n          const instance = new Channel(this, chanInfo, {\n            server: true\n          });\n          this._chanMgr.update(info.recipient, instance);\n          channel(undefined, instance);\n        },\n        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {\n          const channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'function') return;\n          const info = {\n            reason,\n            description\n          };\n          onChannelOpenFailure(this, recipient, info, channel);\n        },\n        CHANNEL_DATA: (p, recipient, data) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          // The remote party should not be sending us data if there is no\n          // window space available ...\n          // TODO: raise error on data with not enough window?\n          if (channel.incoming.window === 0) return;\n          channel.incoming.window -= data.length;\n          if (channel.push(data) === false) {\n            channel._waitChanDrain = true;\n            return;\n          }\n          if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);\n        },\n        CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {\n          // NOOP -- should not be sent by client\n        },\n        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n\n          // The other side is allowing us to send `amount` more bytes of data\n          channel.outgoing.window += amount;\n          if (channel._waitWindow) {\n            channel._waitWindow = false;\n            if (channel._chunk) {\n              channel._write(channel._chunk, null, channel._chunkcb);\n            } else if (channel._chunkcb) {\n              channel._chunkcb();\n            } else if (channel._chunkErr) {\n              channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);\n            } else if (channel._chunkcbErr) {\n              channel._chunkcbErr();\n            }\n          }\n        },\n        CHANNEL_SUCCESS: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          if (channel._callbacks.length) channel._callbacks.shift()(false);\n        },\n        CHANNEL_FAILURE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          if (channel._callbacks.length) channel._callbacks.shift()(true);\n        },\n        CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {\n          const session = this._chanMgr.get(recipient);\n          if (typeof session !== 'object' || session === null) return;\n          let replied = false;\n          let accept;\n          let reject;\n          if (session.constructor !== Session) {\n            // normal Channel instance\n            if (wantReply) proto.channelFailure(session.outgoing.id);\n            return;\n          }\n          if (wantReply) {\n            // \"real session\" requests will have custom accept behaviors\n            if (type !== 'shell' && type !== 'exec' && type !== 'subsystem') {\n              accept = () => {\n                if (replied || session._ending || session._channel) return;\n                replied = true;\n                proto.channelSuccess(session._chanInfo.outgoing.id);\n              };\n            }\n            reject = () => {\n              if (replied || session._ending || session._channel) return;\n              replied = true;\n              proto.channelFailure(session._chanInfo.outgoing.id);\n            };\n          }\n          if (session._ending) {\n            reject && reject();\n            return;\n          }\n          switch (type) {\n            // \"pre-real session start\" requests\n            case 'env':\n              if (listenerCount(session, 'env')) {\n                session.emit('env', accept, reject, {\n                  key: data.name,\n                  val: data.value\n                });\n                return;\n              }\n              break;\n            case 'pty-req':\n              if (listenerCount(session, 'pty')) {\n                session.emit('pty', accept, reject, data);\n                return;\n              }\n              break;\n            case 'window-change':\n              if (listenerCount(session, 'window-change')) session.emit('window-change', accept, reject, data);else reject && reject();\n              break;\n            case 'x11-req':\n              if (listenerCount(session, 'x11')) {\n                session.emit('x11', accept, reject, data);\n                return;\n              }\n              break;\n            // \"post-real session start\" requests\n            case 'signal':\n              if (listenerCount(session, 'signal')) {\n                session.emit('signal', accept, reject, {\n                  name: data\n                });\n                return;\n              }\n              break;\n            // XXX: is `auth-agent-req@openssh.com` really \"post-real session\n            // start\"?\n            case 'auth-agent-req@openssh.com':\n              if (listenerCount(session, 'auth-agent')) {\n                session.emit('auth-agent', accept, reject);\n                return;\n              }\n              break;\n            // \"real session start\" requests\n            case 'shell':\n              if (listenerCount(session, 'shell')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  const channel = new Channel(this, session._chanInfo, {\n                    server: true\n                  });\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n                  return channel;\n                };\n                session.emit('shell', accept, reject);\n                return;\n              }\n              break;\n            case 'exec':\n              if (listenerCount(session, 'exec')) {\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  const channel = new Channel(this, session._chanInfo, {\n                    server: true\n                  });\n                  channel.subtype = session.subtype = type;\n                  session._channel = channel;\n                  return channel;\n                };\n                session.emit('exec', accept, reject, {\n                  command: data\n                });\n                return;\n              }\n              break;\n            case 'subsystem':\n              {\n                let useSFTP = data === 'sftp';\n                accept = () => {\n                  if (replied || session._ending || session._channel) return;\n                  replied = true;\n                  if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);\n                  let instance;\n                  if (useSFTP) {\n                    instance = new SFTP(this, session._chanInfo, {\n                      server: true,\n                      debug\n                    });\n                  } else {\n                    instance = new Channel(this, session._chanInfo, {\n                      server: true\n                    });\n                    instance.subtype = session.subtype = `${type}:${data}`;\n                  }\n                  session._channel = instance;\n                  return instance;\n                };\n                if (data === 'sftp') {\n                  if (listenerCount(session, 'sftp')) {\n                    session.emit('sftp', accept, reject);\n                    return;\n                  }\n                  useSFTP = false;\n                }\n                if (listenerCount(session, 'subsystem')) {\n                  session.emit('subsystem', accept, reject, {\n                    name: data\n                  });\n                  return;\n                }\n                break;\n              }\n          }\n          debug && debug(`Automatic rejection of incoming channel request: ${type}`);\n          reject && reject();\n        },\n        CHANNEL_EOF: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            if (!channel._ending) {\n              channel._ending = true;\n              channel.emit('eof');\n              channel.emit('end');\n            }\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          if (channel.incoming.state !== 'open') return;\n          channel.incoming.state = 'eof';\n          if (channel.readable) channel.push(null);\n        },\n        CHANNEL_CLOSE: (p, recipient) => {\n          let channel = this._chanMgr.get(recipient);\n          if (typeof channel !== 'object' || channel === null) return;\n          if (channel.constructor === Session) {\n            channel._ending = true;\n            channel.emit('close');\n            channel = channel._channel;\n            if (!channel) return;\n          }\n          onCHANNEL_CLOSE(this, recipient, channel);\n        },\n        // Begin service/auth-related ==========================================\n        SERVICE_REQUEST: (p, service) => {\n          if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== 'ssh-userauth') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n          acceptedAuthSvc = true;\n          proto.serviceAccept(service);\n        },\n        USERAUTH_REQUEST: (p, username, service, method, methodData) => {\n          if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service)\n          // TODO: support hostbased auth\n          || method !== 'password' && method !== 'publickey' && method !== 'hostbased' && method !== 'keyboard-interactive' && method !== 'none' || pendingAuths.length === MAX_PENDING_AUTHS) {\n            proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n            socket.end();\n            return;\n          } else if (service !== 'ssh-connection') {\n            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n            socket.end();\n            return;\n          }\n          let ctx;\n          switch (method) {\n            case 'keyboard-interactive':\n              ctx = new KeyboardAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'publickey':\n              ctx = new PKAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'hostbased':\n              ctx = new HostbasedAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'password':\n              if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {\n                const cb = authCtx._changeCb;\n                authCtx._changeCb = undefined;\n                cb(methodData.newPassword);\n                return;\n              }\n              ctx = new PwdAuthContext(proto, username, service, method, methodData, onAuthDecide);\n              break;\n            case 'none':\n              ctx = new AuthContext(proto, username, service, method, onAuthDecide);\n              break;\n          }\n          if (authCtx) {\n            if (!authCtx._initialResponse) {\n              return pendingAuths.push(ctx);\n            } else if (authCtx._multistep && !authCtx._finalResponse) {\n              // RFC 4252 says to silently abort the current auth request if a\n              // new auth request comes in before the final response from an\n              // auth method that requires additional request/response exchanges\n              // -- this means keyboard-interactive for now ...\n              authCtx._cleanup && authCtx._cleanup();\n              authCtx.emit('abort');\n            }\n          }\n          authCtx = ctx;\n          if (listenerCount(this, 'authentication')) this.emit('authentication', authCtx);else authCtx.reject();\n        },\n        USERAUTH_INFO_RESPONSE: (p, responses) => {\n          if (authCtx && authCtx instanceof KeyboardAuthContext) authCtx._onInfoResponse(responses);\n        },\n        // End service/auth-related ============================================\n        GLOBAL_REQUEST: (p, name, wantReply, data) => {\n          const reply = {\n            type: null,\n            buf: null\n          };\n          function setReply(type, buf) {\n            reply.type = type;\n            reply.buf = buf;\n            sendReplies();\n          }\n          if (wantReply) unsentGlobalRequestsReplies.push(reply);\n          if ((name === 'tcpip-forward' || name === 'cancel-tcpip-forward' || name === 'no-more-sessions@openssh.com' || name === 'streamlocal-forward@openssh.com' || name === 'cancel-streamlocal-forward@openssh.com') && listenerCount(this, 'request') && this.authenticated) {\n            let accept;\n            let reject;\n            if (wantReply) {\n              let replied = false;\n              accept = chosenPort => {\n                if (replied) return;\n                replied = true;\n                let bufPort;\n                if (name === 'tcpip-forward' && data.bindPort === 0 && typeof chosenPort === 'number') {\n                  bufPort = Buffer.allocUnsafe(4);\n                  writeUInt32BE(bufPort, chosenPort, 0);\n                }\n                setReply('SUCCESS', bufPort);\n              };\n              reject = () => {\n                if (replied) return;\n                replied = true;\n                setReply('FAILURE');\n              };\n            }\n            if (name === 'no-more-sessions@openssh.com') {\n              this.noMoreSessions = true;\n              accept && accept();\n              return;\n            }\n            this.emit('request', accept, reject, name, data);\n          } else if (wantReply) {\n            setReply('FAILURE');\n          }\n        }\n      }\n    });\n    socket.pause();\n    cryptoInit.then(() => {\n      proto.start();\n      socket.on('data', data => {\n        try {\n          proto.parse(data, 0, data.length);\n        } catch (ex) {\n          this.emit('error', ex);\n          try {\n            if (isWritable(socket)) socket.end();\n          } catch {}\n        }\n      });\n      socket.resume();\n    }).catch(err => {\n      this.emit('error', err);\n      try {\n        if (isWritable(socket)) socket.end();\n      } catch {}\n    });\n    socket.on('error', err => {\n      err.level = 'socket';\n      this.emit('error', err);\n    }).once('end', () => {\n      debug && debug('Socket ended');\n      proto.cleanup();\n      this.emit('end');\n    }).once('close', () => {\n      debug && debug('Socket closed');\n      proto.cleanup();\n      this.emit('close');\n      const err = new Error('No response from server');\n\n      // Simulate error for pending channels and close any open channels\n      this._chanMgr.cleanup(err);\n    });\n    const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {\n      if (authCtx === ctx && !this.authenticated) {\n        if (allowed) {\n          authCtx = undefined;\n          this.authenticated = true;\n          proto.authSuccess();\n          pendingAuths = [];\n          this.emit('ready');\n        } else {\n          proto.authFailure(methodsLeft, isPartial);\n          if (pendingAuths.length) {\n            authCtx = pendingAuths.pop();\n            if (listenerCount(this, 'authentication')) this.emit('authentication', authCtx);else authCtx.reject();\n          }\n        }\n      }\n    };\n    function sendReplies() {\n      while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {\n        const reply = unsentGlobalRequestsReplies.shift();\n        if (reply.type === 'SUCCESS') proto.requestSuccess(reply.buf);\n        if (reply.type === 'FAILURE') proto.requestFailure();\n      }\n    }\n  }\n  end() {\n    if (this._sock && isWritable(this._sock)) {\n      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      this._sock.end();\n    }\n    return this;\n  }\n  x11(originAddr, originPort, cb) {\n    const opts = {\n      originAddr,\n      originPort\n    };\n    openChannel(this, 'x11', opts, cb);\n    return this;\n  }\n  forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {\n    const opts = {\n      boundAddr,\n      boundPort,\n      remoteAddr,\n      remotePort\n    };\n    openChannel(this, 'forwarded-tcpip', opts, cb);\n    return this;\n  }\n  openssh_forwardOutStreamLocal(socketPath, cb) {\n    const opts = {\n      socketPath\n    };\n    openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n    return this;\n  }\n  rekey(cb) {\n    let error;\n    try {\n      this._protocol.rekey();\n    } catch (ex) {\n      error = ex;\n    }\n\n    // TODO: re-throw error if no callback?\n\n    if (typeof cb === 'function') {\n      if (error) process.nextTick(cb, error);else this.once('rekey', cb);\n    }\n  }\n  setNoDelay(noDelay) {\n    if (this._sock && typeof this._sock.setNoDelay === 'function') this._sock.setNoDelay(noDelay);\n    return this;\n  }\n}\nfunction openChannel(self, type, opts, cb) {\n  // Ask the client to open a channel for some purpose (e.g. a forwarded TCP\n  // connection)\n  const initWindow = MAX_WINDOW;\n  const maxPacket = PACKET_SIZE;\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  const wrapper = (err, stream) => {\n    cb(err, stream);\n  };\n  wrapper.type = type;\n  const localChan = self._chanMgr.add(wrapper);\n  if (localChan === -1) {\n    cb(new Error('No free channels available'));\n    return;\n  }\n  switch (type) {\n    case 'forwarded-tcpip':\n      self._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'x11':\n      self._protocol.x11(localChan, initWindow, maxPacket, opts);\n      break;\n    case 'forwarded-streamlocal@openssh.com':\n      self._protocol.openssh_forwardedStreamLocal(localChan, initWindow, maxPacket, opts);\n      break;\n    default:\n      throw new Error(`Unsupported channel type: ${type}`);\n  }\n}\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;","'use strict';\n\nconst {\n  SFTP\n} = require('./protocol/SFTP.js');\nconst MAX_CHANNEL = 2 ** 32 - 1;\nfunction onChannelOpenFailure(self, recipient, info, cb) {\n  self._chanMgr.remove(recipient);\n  if (typeof cb !== 'function') return;\n  let err;\n  if (info instanceof Error) {\n    err = info;\n  } else if (typeof info === 'object' && info !== null) {\n    err = new Error(`(SSH) Channel open failure: ${info.description}`);\n    err.reason = info.reason;\n  } else {\n    err = new Error('(SSH) Channel open failure: server closed channel unexpectedly');\n    err.reason = '';\n  }\n  cb(err);\n}\nfunction onCHANNEL_CLOSE(self, recipient, channel, err, dead) {\n  if (typeof channel === 'function') {\n    // We got CHANNEL_CLOSE instead of CHANNEL_OPEN_FAILURE when\n    // requesting to open a channel\n    onChannelOpenFailure(self, recipient, err, channel);\n    return;\n  }\n  if (typeof channel !== 'object' || channel === null) return;\n  if (channel.incoming && channel.incoming.state === 'closed') return;\n  self._chanMgr.remove(recipient);\n  if (channel.server && channel.constructor.name === 'Session') return;\n  channel.incoming.state = 'closed';\n  if (channel.readable) channel.push(null);\n  if (channel.server) {\n    if (channel.stderr.writable) channel.stderr.end();\n  } else if (channel.stderr.readable) {\n    channel.stderr.push(null);\n  }\n  if (channel.constructor !== SFTP && (channel.outgoing.state === 'open' || channel.outgoing.state === 'eof') && !dead) {\n    channel.close();\n  }\n  if (channel.outgoing.state === 'closing') channel.outgoing.state = 'closed';\n  const readState = channel._readableState;\n  const writeState = channel._writableState;\n  if (writeState && !writeState.ending && !writeState.finished && !dead) channel.end();\n\n  // Take care of any outstanding channel requests\n  const chanCallbacks = channel._callbacks;\n  channel._callbacks = [];\n  for (let i = 0; i < chanCallbacks.length; ++i) chanCallbacks[i](true);\n  if (channel.server) {\n    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {\n      channel.emit('close');\n    } else {\n      channel.once('end', () => channel.emit('close'));\n    }\n  } else {\n    let doClose;\n    switch (channel.type) {\n      case 'direct-streamlocal@openssh.com':\n      case 'direct-tcpip':\n        doClose = () => channel.emit('close');\n        break;\n      default:\n        {\n          // Align more with node child processes, where the close event gets\n          // the same arguments as the exit event\n          const exit = channel._exit;\n          doClose = () => {\n            if (exit.code === null) channel.emit('close', exit.code, exit.signal, exit.dump, exit.desc);else channel.emit('close', exit.code);\n          };\n        }\n    }\n    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {\n      doClose();\n    } else {\n      channel.once('end', doClose);\n    }\n    const errReadState = channel.stderr._readableState;\n    if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {\n      channel.stderr.emit('close');\n    } else {\n      channel.stderr.once('end', () => channel.stderr.emit('close'));\n    }\n  }\n}\nclass ChannelManager {\n  constructor(client) {\n    this._client = client;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n  }\n  add(val) {\n    // Attempt to reserve an id\n\n    let id;\n    // Optimized paths\n    if (this._cur < MAX_CHANNEL) {\n      id = ++this._cur;\n    } else if (this._count === 0) {\n      // Revert and reset back to fast path once we no longer have any channels\n      // open\n      this._cur = 0;\n      id = 0;\n    } else {\n      // Slower lookup path\n\n      // This path is triggered we have opened at least MAX_CHANNEL channels\n      // while having at least one channel open at any given time, so we have\n      // to search for a free id.\n      const channels = this._channels;\n      for (let i = 0; i < MAX_CHANNEL; ++i) {\n        if (channels[i] === undefined) {\n          id = i;\n          break;\n        }\n      }\n    }\n    if (id === undefined) return -1;\n    this._channels[id] = val || true;\n    ++this._count;\n    return id;\n  }\n  update(id, val) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    if (val && this._channels[id]) this._channels[id] = val;\n  }\n  get(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    return this._channels[id];\n  }\n  remove(id) {\n    if (typeof id !== 'number' || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);\n    if (this._channels[id]) {\n      delete this._channels[id];\n      if (this._count) --this._count;\n    }\n  }\n  cleanup(err) {\n    const channels = this._channels;\n    this._channels = {};\n    this._cur = -1;\n    this._count = 0;\n    const chanIDs = Object.keys(channels);\n    const client = this._client;\n    for (let i = 0; i < chanIDs.length; ++i) {\n      const id = +chanIDs[i];\n      const channel = channels[id];\n      onCHANNEL_CLOSE(client, id, channel._channel || channel, err, true);\n    }\n  }\n}\nconst isRegExp = (() => {\n  const toString = Object.prototype.toString;\n  return val => toString.call(val) === '[object RegExp]';\n})();\nfunction generateAlgorithmList(algoList, defaultList, supportedList) {\n  if (Array.isArray(algoList) && algoList.length > 0) {\n    // Exact list\n    for (let i = 0; i < algoList.length; ++i) {\n      if (supportedList.indexOf(algoList[i]) === -1) throw new Error(`Unsupported algorithm: ${algoList[i]}`);\n    }\n    return algoList;\n  }\n  if (typeof algoList === 'object' && algoList !== null) {\n    // Operations based on the default list\n    const keys = Object.keys(algoList);\n    let list = defaultList;\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      let val = algoList[key];\n      switch (key) {\n        case 'append':\n          if (!Array.isArray(val)) val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const append = val[j];\n              if (typeof append === 'string') {\n                if (!append || list.indexOf(append) !== -1) continue;\n                if (supportedList.indexOf(append) === -1) throw new Error(`Unsupported algorithm: ${append}`);\n                if (list === defaultList) list = list.slice();\n                list.push(append);\n              } else if (isRegExp(append)) {\n                for (let k = 0; k < supportedList.length; ++k) {\n                  const algo = supportedList[k];\n                  if (append.test(algo)) {\n                    if (list.indexOf(algo) !== -1) continue;\n                    if (list === defaultList) list = list.slice();\n                    list.push(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'prepend':\n          if (!Array.isArray(val)) val = [val];\n          if (Array.isArray(val)) {\n            for (let j = val.length; j >= 0; --j) {\n              const prepend = val[j];\n              if (typeof prepend === 'string') {\n                if (!prepend || list.indexOf(prepend) !== -1) continue;\n                if (supportedList.indexOf(prepend) === -1) throw new Error(`Unsupported algorithm: ${prepend}`);\n                if (list === defaultList) list = list.slice();\n                list.unshift(prepend);\n              } else if (isRegExp(prepend)) {\n                for (let k = supportedList.length; k >= 0; --k) {\n                  const algo = supportedList[k];\n                  if (prepend.test(algo)) {\n                    if (list.indexOf(algo) !== -1) continue;\n                    if (list === defaultList) list = list.slice();\n                    list.unshift(algo);\n                  }\n                }\n              }\n            }\n          }\n          break;\n        case 'remove':\n          if (!Array.isArray(val)) val = [val];\n          if (Array.isArray(val)) {\n            for (let j = 0; j < val.length; ++j) {\n              const search = val[j];\n              if (typeof search === 'string') {\n                if (!search) continue;\n                const idx = list.indexOf(search);\n                if (idx === -1) continue;\n                if (list === defaultList) list = list.slice();\n                list.splice(idx, 1);\n              } else if (isRegExp(search)) {\n                for (let k = 0; k < list.length; ++k) {\n                  if (search.test(list[k])) {\n                    if (list === defaultList) list = list.slice();\n                    list.splice(k, 1);\n                    --k;\n                  }\n                }\n              }\n            }\n          }\n          break;\n      }\n    }\n    return list;\n  }\n  return defaultList;\n}\nmodule.exports = {\n  ChannelManager,\n  generateAlgorithmList,\n  onChannelOpenFailure,\n  onCHANNEL_CLOSE,\n  isWritable: stream => {\n    // XXX: hack to workaround regression in node\n    // See: https://github.com/nodejs/node/issues/36029\n    return stream && stream.writable && stream._readableState && stream._readableState.ended === false;\n  }\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n;\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","(function (nacl) {\n  'use strict';\n\n  // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n  // Public domain.\n  //\n  // Implementation derived from TweetNaCl version 20140427.\n  // See for details: http://tweetnacl.cr.yp.to/\n  var gf = function (init) {\n    var i,\n      r = new Float64Array(16);\n    if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n    return r;\n  };\n\n  //  Pluggable, initialized in high-level API below.\n  var randombytes = function /* x, n */ () {\n    throw new Error('no PRNG');\n  };\n  var _0 = new Uint8Array(16);\n  var _9 = new Uint8Array(32);\n  _9[0] = 9;\n  var gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n  function ts64(x, i, h, l) {\n    x[i] = h >> 24 & 0xff;\n    x[i + 1] = h >> 16 & 0xff;\n    x[i + 2] = h >> 8 & 0xff;\n    x[i + 3] = h & 0xff;\n    x[i + 4] = l >> 24 & 0xff;\n    x[i + 5] = l >> 16 & 0xff;\n    x[i + 6] = l >> 8 & 0xff;\n    x[i + 7] = l & 0xff;\n  }\n  function vn(x, xi, y, yi, n) {\n    var i,\n      d = 0;\n    for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];\n    return (1 & d - 1 >>> 8) - 1;\n  }\n  function crypto_verify_16(x, xi, y, yi) {\n    return vn(x, xi, y, yi, 16);\n  }\n  function crypto_verify_32(x, xi, y, yi) {\n    return vn(x, xi, y, yi, 32);\n  }\n  function core_salsa20(o, p, k, c) {\n    var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,\n      j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,\n      j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,\n      j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,\n      j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,\n      j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,\n      j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,\n      j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,\n      j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,\n      j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,\n      j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,\n      j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,\n      j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,\n      j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,\n      j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,\n      j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;\n    var x0 = j0,\n      x1 = j1,\n      x2 = j2,\n      x3 = j3,\n      x4 = j4,\n      x5 = j5,\n      x6 = j6,\n      x7 = j7,\n      x8 = j8,\n      x9 = j9,\n      x10 = j10,\n      x11 = j11,\n      x12 = j12,\n      x13 = j13,\n      x14 = j14,\n      x15 = j15,\n      u;\n    for (var i = 0; i < 20; i += 2) {\n      u = x0 + x12 | 0;\n      x4 ^= u << 7 | u >>> 32 - 7;\n      u = x4 + x0 | 0;\n      x8 ^= u << 9 | u >>> 32 - 9;\n      u = x8 + x4 | 0;\n      x12 ^= u << 13 | u >>> 32 - 13;\n      u = x12 + x8 | 0;\n      x0 ^= u << 18 | u >>> 32 - 18;\n      u = x5 + x1 | 0;\n      x9 ^= u << 7 | u >>> 32 - 7;\n      u = x9 + x5 | 0;\n      x13 ^= u << 9 | u >>> 32 - 9;\n      u = x13 + x9 | 0;\n      x1 ^= u << 13 | u >>> 32 - 13;\n      u = x1 + x13 | 0;\n      x5 ^= u << 18 | u >>> 32 - 18;\n      u = x10 + x6 | 0;\n      x14 ^= u << 7 | u >>> 32 - 7;\n      u = x14 + x10 | 0;\n      x2 ^= u << 9 | u >>> 32 - 9;\n      u = x2 + x14 | 0;\n      x6 ^= u << 13 | u >>> 32 - 13;\n      u = x6 + x2 | 0;\n      x10 ^= u << 18 | u >>> 32 - 18;\n      u = x15 + x11 | 0;\n      x3 ^= u << 7 | u >>> 32 - 7;\n      u = x3 + x15 | 0;\n      x7 ^= u << 9 | u >>> 32 - 9;\n      u = x7 + x3 | 0;\n      x11 ^= u << 13 | u >>> 32 - 13;\n      u = x11 + x7 | 0;\n      x15 ^= u << 18 | u >>> 32 - 18;\n      u = x0 + x3 | 0;\n      x1 ^= u << 7 | u >>> 32 - 7;\n      u = x1 + x0 | 0;\n      x2 ^= u << 9 | u >>> 32 - 9;\n      u = x2 + x1 | 0;\n      x3 ^= u << 13 | u >>> 32 - 13;\n      u = x3 + x2 | 0;\n      x0 ^= u << 18 | u >>> 32 - 18;\n      u = x5 + x4 | 0;\n      x6 ^= u << 7 | u >>> 32 - 7;\n      u = x6 + x5 | 0;\n      x7 ^= u << 9 | u >>> 32 - 9;\n      u = x7 + x6 | 0;\n      x4 ^= u << 13 | u >>> 32 - 13;\n      u = x4 + x7 | 0;\n      x5 ^= u << 18 | u >>> 32 - 18;\n      u = x10 + x9 | 0;\n      x11 ^= u << 7 | u >>> 32 - 7;\n      u = x11 + x10 | 0;\n      x8 ^= u << 9 | u >>> 32 - 9;\n      u = x8 + x11 | 0;\n      x9 ^= u << 13 | u >>> 32 - 13;\n      u = x9 + x8 | 0;\n      x10 ^= u << 18 | u >>> 32 - 18;\n      u = x15 + x14 | 0;\n      x12 ^= u << 7 | u >>> 32 - 7;\n      u = x12 + x15 | 0;\n      x13 ^= u << 9 | u >>> 32 - 9;\n      u = x13 + x12 | 0;\n      x14 ^= u << 13 | u >>> 32 - 13;\n      u = x14 + x13 | 0;\n      x15 ^= u << 18 | u >>> 32 - 18;\n    }\n    x0 = x0 + j0 | 0;\n    x1 = x1 + j1 | 0;\n    x2 = x2 + j2 | 0;\n    x3 = x3 + j3 | 0;\n    x4 = x4 + j4 | 0;\n    x5 = x5 + j5 | 0;\n    x6 = x6 + j6 | 0;\n    x7 = x7 + j7 | 0;\n    x8 = x8 + j8 | 0;\n    x9 = x9 + j9 | 0;\n    x10 = x10 + j10 | 0;\n    x11 = x11 + j11 | 0;\n    x12 = x12 + j12 | 0;\n    x13 = x13 + j13 | 0;\n    x14 = x14 + j14 | 0;\n    x15 = x15 + j15 | 0;\n    o[0] = x0 >>> 0 & 0xff;\n    o[1] = x0 >>> 8 & 0xff;\n    o[2] = x0 >>> 16 & 0xff;\n    o[3] = x0 >>> 24 & 0xff;\n    o[4] = x1 >>> 0 & 0xff;\n    o[5] = x1 >>> 8 & 0xff;\n    o[6] = x1 >>> 16 & 0xff;\n    o[7] = x1 >>> 24 & 0xff;\n    o[8] = x2 >>> 0 & 0xff;\n    o[9] = x2 >>> 8 & 0xff;\n    o[10] = x2 >>> 16 & 0xff;\n    o[11] = x2 >>> 24 & 0xff;\n    o[12] = x3 >>> 0 & 0xff;\n    o[13] = x3 >>> 8 & 0xff;\n    o[14] = x3 >>> 16 & 0xff;\n    o[15] = x3 >>> 24 & 0xff;\n    o[16] = x4 >>> 0 & 0xff;\n    o[17] = x4 >>> 8 & 0xff;\n    o[18] = x4 >>> 16 & 0xff;\n    o[19] = x4 >>> 24 & 0xff;\n    o[20] = x5 >>> 0 & 0xff;\n    o[21] = x5 >>> 8 & 0xff;\n    o[22] = x5 >>> 16 & 0xff;\n    o[23] = x5 >>> 24 & 0xff;\n    o[24] = x6 >>> 0 & 0xff;\n    o[25] = x6 >>> 8 & 0xff;\n    o[26] = x6 >>> 16 & 0xff;\n    o[27] = x6 >>> 24 & 0xff;\n    o[28] = x7 >>> 0 & 0xff;\n    o[29] = x7 >>> 8 & 0xff;\n    o[30] = x7 >>> 16 & 0xff;\n    o[31] = x7 >>> 24 & 0xff;\n    o[32] = x8 >>> 0 & 0xff;\n    o[33] = x8 >>> 8 & 0xff;\n    o[34] = x8 >>> 16 & 0xff;\n    o[35] = x8 >>> 24 & 0xff;\n    o[36] = x9 >>> 0 & 0xff;\n    o[37] = x9 >>> 8 & 0xff;\n    o[38] = x9 >>> 16 & 0xff;\n    o[39] = x9 >>> 24 & 0xff;\n    o[40] = x10 >>> 0 & 0xff;\n    o[41] = x10 >>> 8 & 0xff;\n    o[42] = x10 >>> 16 & 0xff;\n    o[43] = x10 >>> 24 & 0xff;\n    o[44] = x11 >>> 0 & 0xff;\n    o[45] = x11 >>> 8 & 0xff;\n    o[46] = x11 >>> 16 & 0xff;\n    o[47] = x11 >>> 24 & 0xff;\n    o[48] = x12 >>> 0 & 0xff;\n    o[49] = x12 >>> 8 & 0xff;\n    o[50] = x12 >>> 16 & 0xff;\n    o[51] = x12 >>> 24 & 0xff;\n    o[52] = x13 >>> 0 & 0xff;\n    o[53] = x13 >>> 8 & 0xff;\n    o[54] = x13 >>> 16 & 0xff;\n    o[55] = x13 >>> 24 & 0xff;\n    o[56] = x14 >>> 0 & 0xff;\n    o[57] = x14 >>> 8 & 0xff;\n    o[58] = x14 >>> 16 & 0xff;\n    o[59] = x14 >>> 24 & 0xff;\n    o[60] = x15 >>> 0 & 0xff;\n    o[61] = x15 >>> 8 & 0xff;\n    o[62] = x15 >>> 16 & 0xff;\n    o[63] = x15 >>> 24 & 0xff;\n  }\n  function core_hsalsa20(o, p, k, c) {\n    var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,\n      j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,\n      j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,\n      j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,\n      j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,\n      j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,\n      j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,\n      j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,\n      j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,\n      j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,\n      j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,\n      j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,\n      j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,\n      j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,\n      j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,\n      j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;\n    var x0 = j0,\n      x1 = j1,\n      x2 = j2,\n      x3 = j3,\n      x4 = j4,\n      x5 = j5,\n      x6 = j6,\n      x7 = j7,\n      x8 = j8,\n      x9 = j9,\n      x10 = j10,\n      x11 = j11,\n      x12 = j12,\n      x13 = j13,\n      x14 = j14,\n      x15 = j15,\n      u;\n    for (var i = 0; i < 20; i += 2) {\n      u = x0 + x12 | 0;\n      x4 ^= u << 7 | u >>> 32 - 7;\n      u = x4 + x0 | 0;\n      x8 ^= u << 9 | u >>> 32 - 9;\n      u = x8 + x4 | 0;\n      x12 ^= u << 13 | u >>> 32 - 13;\n      u = x12 + x8 | 0;\n      x0 ^= u << 18 | u >>> 32 - 18;\n      u = x5 + x1 | 0;\n      x9 ^= u << 7 | u >>> 32 - 7;\n      u = x9 + x5 | 0;\n      x13 ^= u << 9 | u >>> 32 - 9;\n      u = x13 + x9 | 0;\n      x1 ^= u << 13 | u >>> 32 - 13;\n      u = x1 + x13 | 0;\n      x5 ^= u << 18 | u >>> 32 - 18;\n      u = x10 + x6 | 0;\n      x14 ^= u << 7 | u >>> 32 - 7;\n      u = x14 + x10 | 0;\n      x2 ^= u << 9 | u >>> 32 - 9;\n      u = x2 + x14 | 0;\n      x6 ^= u << 13 | u >>> 32 - 13;\n      u = x6 + x2 | 0;\n      x10 ^= u << 18 | u >>> 32 - 18;\n      u = x15 + x11 | 0;\n      x3 ^= u << 7 | u >>> 32 - 7;\n      u = x3 + x15 | 0;\n      x7 ^= u << 9 | u >>> 32 - 9;\n      u = x7 + x3 | 0;\n      x11 ^= u << 13 | u >>> 32 - 13;\n      u = x11 + x7 | 0;\n      x15 ^= u << 18 | u >>> 32 - 18;\n      u = x0 + x3 | 0;\n      x1 ^= u << 7 | u >>> 32 - 7;\n      u = x1 + x0 | 0;\n      x2 ^= u << 9 | u >>> 32 - 9;\n      u = x2 + x1 | 0;\n      x3 ^= u << 13 | u >>> 32 - 13;\n      u = x3 + x2 | 0;\n      x0 ^= u << 18 | u >>> 32 - 18;\n      u = x5 + x4 | 0;\n      x6 ^= u << 7 | u >>> 32 - 7;\n      u = x6 + x5 | 0;\n      x7 ^= u << 9 | u >>> 32 - 9;\n      u = x7 + x6 | 0;\n      x4 ^= u << 13 | u >>> 32 - 13;\n      u = x4 + x7 | 0;\n      x5 ^= u << 18 | u >>> 32 - 18;\n      u = x10 + x9 | 0;\n      x11 ^= u << 7 | u >>> 32 - 7;\n      u = x11 + x10 | 0;\n      x8 ^= u << 9 | u >>> 32 - 9;\n      u = x8 + x11 | 0;\n      x9 ^= u << 13 | u >>> 32 - 13;\n      u = x9 + x8 | 0;\n      x10 ^= u << 18 | u >>> 32 - 18;\n      u = x15 + x14 | 0;\n      x12 ^= u << 7 | u >>> 32 - 7;\n      u = x12 + x15 | 0;\n      x13 ^= u << 9 | u >>> 32 - 9;\n      u = x13 + x12 | 0;\n      x14 ^= u << 13 | u >>> 32 - 13;\n      u = x14 + x13 | 0;\n      x15 ^= u << 18 | u >>> 32 - 18;\n    }\n    o[0] = x0 >>> 0 & 0xff;\n    o[1] = x0 >>> 8 & 0xff;\n    o[2] = x0 >>> 16 & 0xff;\n    o[3] = x0 >>> 24 & 0xff;\n    o[4] = x5 >>> 0 & 0xff;\n    o[5] = x5 >>> 8 & 0xff;\n    o[6] = x5 >>> 16 & 0xff;\n    o[7] = x5 >>> 24 & 0xff;\n    o[8] = x10 >>> 0 & 0xff;\n    o[9] = x10 >>> 8 & 0xff;\n    o[10] = x10 >>> 16 & 0xff;\n    o[11] = x10 >>> 24 & 0xff;\n    o[12] = x15 >>> 0 & 0xff;\n    o[13] = x15 >>> 8 & 0xff;\n    o[14] = x15 >>> 16 & 0xff;\n    o[15] = x15 >>> 24 & 0xff;\n    o[16] = x6 >>> 0 & 0xff;\n    o[17] = x6 >>> 8 & 0xff;\n    o[18] = x6 >>> 16 & 0xff;\n    o[19] = x6 >>> 24 & 0xff;\n    o[20] = x7 >>> 0 & 0xff;\n    o[21] = x7 >>> 8 & 0xff;\n    o[22] = x7 >>> 16 & 0xff;\n    o[23] = x7 >>> 24 & 0xff;\n    o[24] = x8 >>> 0 & 0xff;\n    o[25] = x8 >>> 8 & 0xff;\n    o[26] = x8 >>> 16 & 0xff;\n    o[27] = x8 >>> 24 & 0xff;\n    o[28] = x9 >>> 0 & 0xff;\n    o[29] = x9 >>> 8 & 0xff;\n    o[30] = x9 >>> 16 & 0xff;\n    o[31] = x9 >>> 24 & 0xff;\n  }\n  function crypto_core_salsa20(out, inp, k, c) {\n    core_salsa20(out, inp, k, c);\n  }\n  function crypto_core_hsalsa20(out, inp, k, c) {\n    core_hsalsa20(out, inp, k, c);\n  }\n  var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n  // \"expand 32-byte k\"\n\n  function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n    var z = new Uint8Array(16),\n      x = new Uint8Array(64);\n    var u, i;\n    for (i = 0; i < 16; i++) z[i] = 0;\n    for (i = 0; i < 8; i++) z[i] = n[i];\n    while (b >= 64) {\n      crypto_core_salsa20(x, z, k, sigma);\n      for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];\n      u = 1;\n      for (i = 8; i < 16; i++) {\n        u = u + (z[i] & 0xff) | 0;\n        z[i] = u & 0xff;\n        u >>>= 8;\n      }\n      b -= 64;\n      cpos += 64;\n      mpos += 64;\n    }\n    if (b > 0) {\n      crypto_core_salsa20(x, z, k, sigma);\n      for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];\n    }\n    return 0;\n  }\n  function crypto_stream_salsa20(c, cpos, b, n, k) {\n    var z = new Uint8Array(16),\n      x = new Uint8Array(64);\n    var u, i;\n    for (i = 0; i < 16; i++) z[i] = 0;\n    for (i = 0; i < 8; i++) z[i] = n[i];\n    while (b >= 64) {\n      crypto_core_salsa20(x, z, k, sigma);\n      for (i = 0; i < 64; i++) c[cpos + i] = x[i];\n      u = 1;\n      for (i = 8; i < 16; i++) {\n        u = u + (z[i] & 0xff) | 0;\n        z[i] = u & 0xff;\n        u >>>= 8;\n      }\n      b -= 64;\n      cpos += 64;\n    }\n    if (b > 0) {\n      crypto_core_salsa20(x, z, k, sigma);\n      for (i = 0; i < b; i++) c[cpos + i] = x[i];\n    }\n    return 0;\n  }\n  function crypto_stream(c, cpos, d, n, k) {\n    var s = new Uint8Array(32);\n    crypto_core_hsalsa20(s, n, k, sigma);\n    var sn = new Uint8Array(8);\n    for (var i = 0; i < 8; i++) sn[i] = n[i + 16];\n    return crypto_stream_salsa20(c, cpos, d, sn, s);\n  }\n  function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n    var s = new Uint8Array(32);\n    crypto_core_hsalsa20(s, n, k, sigma);\n    var sn = new Uint8Array(8);\n    for (var i = 0; i < 8; i++) sn[i] = n[i + 16];\n    return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);\n  }\n\n  /*\n  * Port of Andrew Moon's Poly1305-donna-16. Public domain.\n  * https://github.com/floodyberry/poly1305-donna\n  */\n\n  var poly1305 = function (key) {\n    this.buffer = new Uint8Array(16);\n    this.r = new Uint16Array(10);\n    this.h = new Uint16Array(10);\n    this.pad = new Uint16Array(8);\n    this.leftover = 0;\n    this.fin = 0;\n    var t0, t1, t2, t3, t4, t5, t6, t7;\n    t0 = key[0] & 0xff | (key[1] & 0xff) << 8;\n    this.r[0] = t0 & 0x1fff;\n    t1 = key[2] & 0xff | (key[3] & 0xff) << 8;\n    this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n    t2 = key[4] & 0xff | (key[5] & 0xff) << 8;\n    this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n    t3 = key[6] & 0xff | (key[7] & 0xff) << 8;\n    this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n    t4 = key[8] & 0xff | (key[9] & 0xff) << 8;\n    this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n    this.r[5] = t4 >>> 1 & 0x1ffe;\n    t5 = key[10] & 0xff | (key[11] & 0xff) << 8;\n    this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n    t6 = key[12] & 0xff | (key[13] & 0xff) << 8;\n    this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n    t7 = key[14] & 0xff | (key[15] & 0xff) << 8;\n    this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n    this.r[9] = t7 >>> 5 & 0x007f;\n    this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n    this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n    this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n    this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n    this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n    this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n    this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n    this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n  };\n  poly1305.prototype.blocks = function (m, mpos, bytes) {\n    var hibit = this.fin ? 0 : 1 << 11;\n    var t0, t1, t2, t3, t4, t5, t6, t7, c;\n    var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n    var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n    var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n    while (bytes >= 16) {\n      t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;\n      h0 += t0 & 0x1fff;\n      t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;\n      h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;\n      t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;\n      h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;\n      t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;\n      h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;\n      t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;\n      h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;\n      h5 += t4 >>> 1 & 0x1fff;\n      t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;\n      h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;\n      t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;\n      h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;\n      t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;\n      h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;\n      h9 += t7 >>> 5 | hibit;\n      c = 0;\n      d0 = c;\n      d0 += h0 * r0;\n      d0 += h1 * (5 * r9);\n      d0 += h2 * (5 * r8);\n      d0 += h3 * (5 * r7);\n      d0 += h4 * (5 * r6);\n      c = d0 >>> 13;\n      d0 &= 0x1fff;\n      d0 += h5 * (5 * r5);\n      d0 += h6 * (5 * r4);\n      d0 += h7 * (5 * r3);\n      d0 += h8 * (5 * r2);\n      d0 += h9 * (5 * r1);\n      c += d0 >>> 13;\n      d0 &= 0x1fff;\n      d1 = c;\n      d1 += h0 * r1;\n      d1 += h1 * r0;\n      d1 += h2 * (5 * r9);\n      d1 += h3 * (5 * r8);\n      d1 += h4 * (5 * r7);\n      c = d1 >>> 13;\n      d1 &= 0x1fff;\n      d1 += h5 * (5 * r6);\n      d1 += h6 * (5 * r5);\n      d1 += h7 * (5 * r4);\n      d1 += h8 * (5 * r3);\n      d1 += h9 * (5 * r2);\n      c += d1 >>> 13;\n      d1 &= 0x1fff;\n      d2 = c;\n      d2 += h0 * r2;\n      d2 += h1 * r1;\n      d2 += h2 * r0;\n      d2 += h3 * (5 * r9);\n      d2 += h4 * (5 * r8);\n      c = d2 >>> 13;\n      d2 &= 0x1fff;\n      d2 += h5 * (5 * r7);\n      d2 += h6 * (5 * r6);\n      d2 += h7 * (5 * r5);\n      d2 += h8 * (5 * r4);\n      d2 += h9 * (5 * r3);\n      c += d2 >>> 13;\n      d2 &= 0x1fff;\n      d3 = c;\n      d3 += h0 * r3;\n      d3 += h1 * r2;\n      d3 += h2 * r1;\n      d3 += h3 * r0;\n      d3 += h4 * (5 * r9);\n      c = d3 >>> 13;\n      d3 &= 0x1fff;\n      d3 += h5 * (5 * r8);\n      d3 += h6 * (5 * r7);\n      d3 += h7 * (5 * r6);\n      d3 += h8 * (5 * r5);\n      d3 += h9 * (5 * r4);\n      c += d3 >>> 13;\n      d3 &= 0x1fff;\n      d4 = c;\n      d4 += h0 * r4;\n      d4 += h1 * r3;\n      d4 += h2 * r2;\n      d4 += h3 * r1;\n      d4 += h4 * r0;\n      c = d4 >>> 13;\n      d4 &= 0x1fff;\n      d4 += h5 * (5 * r9);\n      d4 += h6 * (5 * r8);\n      d4 += h7 * (5 * r7);\n      d4 += h8 * (5 * r6);\n      d4 += h9 * (5 * r5);\n      c += d4 >>> 13;\n      d4 &= 0x1fff;\n      d5 = c;\n      d5 += h0 * r5;\n      d5 += h1 * r4;\n      d5 += h2 * r3;\n      d5 += h3 * r2;\n      d5 += h4 * r1;\n      c = d5 >>> 13;\n      d5 &= 0x1fff;\n      d5 += h5 * r0;\n      d5 += h6 * (5 * r9);\n      d5 += h7 * (5 * r8);\n      d5 += h8 * (5 * r7);\n      d5 += h9 * (5 * r6);\n      c += d5 >>> 13;\n      d5 &= 0x1fff;\n      d6 = c;\n      d6 += h0 * r6;\n      d6 += h1 * r5;\n      d6 += h2 * r4;\n      d6 += h3 * r3;\n      d6 += h4 * r2;\n      c = d6 >>> 13;\n      d6 &= 0x1fff;\n      d6 += h5 * r1;\n      d6 += h6 * r0;\n      d6 += h7 * (5 * r9);\n      d6 += h8 * (5 * r8);\n      d6 += h9 * (5 * r7);\n      c += d6 >>> 13;\n      d6 &= 0x1fff;\n      d7 = c;\n      d7 += h0 * r7;\n      d7 += h1 * r6;\n      d7 += h2 * r5;\n      d7 += h3 * r4;\n      d7 += h4 * r3;\n      c = d7 >>> 13;\n      d7 &= 0x1fff;\n      d7 += h5 * r2;\n      d7 += h6 * r1;\n      d7 += h7 * r0;\n      d7 += h8 * (5 * r9);\n      d7 += h9 * (5 * r8);\n      c += d7 >>> 13;\n      d7 &= 0x1fff;\n      d8 = c;\n      d8 += h0 * r8;\n      d8 += h1 * r7;\n      d8 += h2 * r6;\n      d8 += h3 * r5;\n      d8 += h4 * r4;\n      c = d8 >>> 13;\n      d8 &= 0x1fff;\n      d8 += h5 * r3;\n      d8 += h6 * r2;\n      d8 += h7 * r1;\n      d8 += h8 * r0;\n      d8 += h9 * (5 * r9);\n      c += d8 >>> 13;\n      d8 &= 0x1fff;\n      d9 = c;\n      d9 += h0 * r9;\n      d9 += h1 * r8;\n      d9 += h2 * r7;\n      d9 += h3 * r6;\n      d9 += h4 * r5;\n      c = d9 >>> 13;\n      d9 &= 0x1fff;\n      d9 += h5 * r4;\n      d9 += h6 * r3;\n      d9 += h7 * r2;\n      d9 += h8 * r1;\n      d9 += h9 * r0;\n      c += d9 >>> 13;\n      d9 &= 0x1fff;\n      c = (c << 2) + c | 0;\n      c = c + d0 | 0;\n      d0 = c & 0x1fff;\n      c = c >>> 13;\n      d1 += c;\n      h0 = d0;\n      h1 = d1;\n      h2 = d2;\n      h3 = d3;\n      h4 = d4;\n      h5 = d5;\n      h6 = d6;\n      h7 = d7;\n      h8 = d8;\n      h9 = d9;\n      mpos += 16;\n      bytes -= 16;\n    }\n    this.h[0] = h0;\n    this.h[1] = h1;\n    this.h[2] = h2;\n    this.h[3] = h3;\n    this.h[4] = h4;\n    this.h[5] = h5;\n    this.h[6] = h6;\n    this.h[7] = h7;\n    this.h[8] = h8;\n    this.h[9] = h9;\n  };\n  poly1305.prototype.finish = function (mac, macpos) {\n    var g = new Uint16Array(10);\n    var c, mask, f, i;\n    if (this.leftover) {\n      i = this.leftover;\n      this.buffer[i++] = 1;\n      for (; i < 16; i++) this.buffer[i] = 0;\n      this.fin = 1;\n      this.blocks(this.buffer, 0, 16);\n    }\n    c = this.h[1] >>> 13;\n    this.h[1] &= 0x1fff;\n    for (i = 2; i < 10; i++) {\n      this.h[i] += c;\n      c = this.h[i] >>> 13;\n      this.h[i] &= 0x1fff;\n    }\n    this.h[0] += c * 5;\n    c = this.h[0] >>> 13;\n    this.h[0] &= 0x1fff;\n    this.h[1] += c;\n    c = this.h[1] >>> 13;\n    this.h[1] &= 0x1fff;\n    this.h[2] += c;\n    g[0] = this.h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (i = 1; i < 10; i++) {\n      g[i] = this.h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n    mask = (c ^ 1) - 1;\n    for (i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];\n    this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;\n    this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;\n    this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;\n    this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;\n    this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;\n    this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;\n    this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;\n    this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;\n    f = this.h[0] + this.pad[0];\n    this.h[0] = f & 0xffff;\n    for (i = 1; i < 8; i++) {\n      f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;\n      this.h[i] = f & 0xffff;\n    }\n    mac[macpos + 0] = this.h[0] >>> 0 & 0xff;\n    mac[macpos + 1] = this.h[0] >>> 8 & 0xff;\n    mac[macpos + 2] = this.h[1] >>> 0 & 0xff;\n    mac[macpos + 3] = this.h[1] >>> 8 & 0xff;\n    mac[macpos + 4] = this.h[2] >>> 0 & 0xff;\n    mac[macpos + 5] = this.h[2] >>> 8 & 0xff;\n    mac[macpos + 6] = this.h[3] >>> 0 & 0xff;\n    mac[macpos + 7] = this.h[3] >>> 8 & 0xff;\n    mac[macpos + 8] = this.h[4] >>> 0 & 0xff;\n    mac[macpos + 9] = this.h[4] >>> 8 & 0xff;\n    mac[macpos + 10] = this.h[5] >>> 0 & 0xff;\n    mac[macpos + 11] = this.h[5] >>> 8 & 0xff;\n    mac[macpos + 12] = this.h[6] >>> 0 & 0xff;\n    mac[macpos + 13] = this.h[6] >>> 8 & 0xff;\n    mac[macpos + 14] = this.h[7] >>> 0 & 0xff;\n    mac[macpos + 15] = this.h[7] >>> 8 & 0xff;\n  };\n  poly1305.prototype.update = function (m, mpos, bytes) {\n    var i, want;\n    if (this.leftover) {\n      want = 16 - this.leftover;\n      if (want > bytes) want = bytes;\n      for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];\n      bytes -= want;\n      mpos += want;\n      this.leftover += want;\n      if (this.leftover < 16) return;\n      this.blocks(this.buffer, 0, 16);\n      this.leftover = 0;\n    }\n    if (bytes >= 16) {\n      want = bytes - bytes % 16;\n      this.blocks(m, mpos, want);\n      mpos += want;\n      bytes -= want;\n    }\n    if (bytes) {\n      for (i = 0; i < bytes; i++) this.buffer[this.leftover + i] = m[mpos + i];\n      this.leftover += bytes;\n    }\n  };\n  function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n    var s = new poly1305(k);\n    s.update(m, mpos, n);\n    s.finish(out, outpos);\n    return 0;\n  }\n  function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n    var x = new Uint8Array(16);\n    crypto_onetimeauth(x, 0, m, mpos, n, k);\n    return crypto_verify_16(h, hpos, x, 0);\n  }\n  function crypto_secretbox(c, m, d, n, k) {\n    var i;\n    if (d < 32) return -1;\n    crypto_stream_xor(c, 0, m, 0, d, n, k);\n    crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n    for (i = 0; i < 16; i++) c[i] = 0;\n    return 0;\n  }\n  function crypto_secretbox_open(m, c, d, n, k) {\n    var i;\n    var x = new Uint8Array(32);\n    if (d < 32) return -1;\n    crypto_stream(x, 0, 32, n, k);\n    if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n    crypto_stream_xor(m, 0, c, 0, d, n, k);\n    for (i = 0; i < 32; i++) m[i] = 0;\n    return 0;\n  }\n  function set25519(r, a) {\n    var i;\n    for (i = 0; i < 16; i++) r[i] = a[i] | 0;\n  }\n  function car25519(o) {\n    var i,\n      v,\n      c = 1;\n    for (i = 0; i < 16; i++) {\n      v = o[i] + c + 65535;\n      c = Math.floor(v / 65536);\n      o[i] = v - c * 65536;\n    }\n    o[0] += c - 1 + 37 * (c - 1);\n  }\n  function sel25519(p, q, b) {\n    var t,\n      c = ~(b - 1);\n    for (var i = 0; i < 16; i++) {\n      t = c & (p[i] ^ q[i]);\n      p[i] ^= t;\n      q[i] ^= t;\n    }\n  }\n  function pack25519(o, n) {\n    var i, j, b;\n    var m = gf(),\n      t = gf();\n    for (i = 0; i < 16; i++) t[i] = n[i];\n    car25519(t);\n    car25519(t);\n    car25519(t);\n    for (j = 0; j < 2; j++) {\n      m[0] = t[0] - 0xffed;\n      for (i = 1; i < 15; i++) {\n        m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n        m[i - 1] &= 0xffff;\n      }\n      m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n      b = m[15] >> 16 & 1;\n      m[14] &= 0xffff;\n      sel25519(t, m, 1 - b);\n    }\n    for (i = 0; i < 16; i++) {\n      o[2 * i] = t[i] & 0xff;\n      o[2 * i + 1] = t[i] >> 8;\n    }\n  }\n  function neq25519(a, b) {\n    var c = new Uint8Array(32),\n      d = new Uint8Array(32);\n    pack25519(c, a);\n    pack25519(d, b);\n    return crypto_verify_32(c, 0, d, 0);\n  }\n  function par25519(a) {\n    var d = new Uint8Array(32);\n    pack25519(d, a);\n    return d[0] & 1;\n  }\n  function unpack25519(o, n) {\n    var i;\n    for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n    o[15] &= 0x7fff;\n  }\n  function A(o, a, b) {\n    for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n  }\n  function Z(o, a, b) {\n    for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n  }\n  function M(o, a, b) {\n    var v,\n      c,\n      t0 = 0,\n      t1 = 0,\n      t2 = 0,\n      t3 = 0,\n      t4 = 0,\n      t5 = 0,\n      t6 = 0,\n      t7 = 0,\n      t8 = 0,\n      t9 = 0,\n      t10 = 0,\n      t11 = 0,\n      t12 = 0,\n      t13 = 0,\n      t14 = 0,\n      t15 = 0,\n      t16 = 0,\n      t17 = 0,\n      t18 = 0,\n      t19 = 0,\n      t20 = 0,\n      t21 = 0,\n      t22 = 0,\n      t23 = 0,\n      t24 = 0,\n      t25 = 0,\n      t26 = 0,\n      t27 = 0,\n      t28 = 0,\n      t29 = 0,\n      t30 = 0,\n      b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11],\n      b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n    v = a[0];\n    t0 += v * b0;\n    t1 += v * b1;\n    t2 += v * b2;\n    t3 += v * b3;\n    t4 += v * b4;\n    t5 += v * b5;\n    t6 += v * b6;\n    t7 += v * b7;\n    t8 += v * b8;\n    t9 += v * b9;\n    t10 += v * b10;\n    t11 += v * b11;\n    t12 += v * b12;\n    t13 += v * b13;\n    t14 += v * b14;\n    t15 += v * b15;\n    v = a[1];\n    t1 += v * b0;\n    t2 += v * b1;\n    t3 += v * b2;\n    t4 += v * b3;\n    t5 += v * b4;\n    t6 += v * b5;\n    t7 += v * b6;\n    t8 += v * b7;\n    t9 += v * b8;\n    t10 += v * b9;\n    t11 += v * b10;\n    t12 += v * b11;\n    t13 += v * b12;\n    t14 += v * b13;\n    t15 += v * b14;\n    t16 += v * b15;\n    v = a[2];\n    t2 += v * b0;\n    t3 += v * b1;\n    t4 += v * b2;\n    t5 += v * b3;\n    t6 += v * b4;\n    t7 += v * b5;\n    t8 += v * b6;\n    t9 += v * b7;\n    t10 += v * b8;\n    t11 += v * b9;\n    t12 += v * b10;\n    t13 += v * b11;\n    t14 += v * b12;\n    t15 += v * b13;\n    t16 += v * b14;\n    t17 += v * b15;\n    v = a[3];\n    t3 += v * b0;\n    t4 += v * b1;\n    t5 += v * b2;\n    t6 += v * b3;\n    t7 += v * b4;\n    t8 += v * b5;\n    t9 += v * b6;\n    t10 += v * b7;\n    t11 += v * b8;\n    t12 += v * b9;\n    t13 += v * b10;\n    t14 += v * b11;\n    t15 += v * b12;\n    t16 += v * b13;\n    t17 += v * b14;\n    t18 += v * b15;\n    v = a[4];\n    t4 += v * b0;\n    t5 += v * b1;\n    t6 += v * b2;\n    t7 += v * b3;\n    t8 += v * b4;\n    t9 += v * b5;\n    t10 += v * b6;\n    t11 += v * b7;\n    t12 += v * b8;\n    t13 += v * b9;\n    t14 += v * b10;\n    t15 += v * b11;\n    t16 += v * b12;\n    t17 += v * b13;\n    t18 += v * b14;\n    t19 += v * b15;\n    v = a[5];\n    t5 += v * b0;\n    t6 += v * b1;\n    t7 += v * b2;\n    t8 += v * b3;\n    t9 += v * b4;\n    t10 += v * b5;\n    t11 += v * b6;\n    t12 += v * b7;\n    t13 += v * b8;\n    t14 += v * b9;\n    t15 += v * b10;\n    t16 += v * b11;\n    t17 += v * b12;\n    t18 += v * b13;\n    t19 += v * b14;\n    t20 += v * b15;\n    v = a[6];\n    t6 += v * b0;\n    t7 += v * b1;\n    t8 += v * b2;\n    t9 += v * b3;\n    t10 += v * b4;\n    t11 += v * b5;\n    t12 += v * b6;\n    t13 += v * b7;\n    t14 += v * b8;\n    t15 += v * b9;\n    t16 += v * b10;\n    t17 += v * b11;\n    t18 += v * b12;\n    t19 += v * b13;\n    t20 += v * b14;\n    t21 += v * b15;\n    v = a[7];\n    t7 += v * b0;\n    t8 += v * b1;\n    t9 += v * b2;\n    t10 += v * b3;\n    t11 += v * b4;\n    t12 += v * b5;\n    t13 += v * b6;\n    t14 += v * b7;\n    t15 += v * b8;\n    t16 += v * b9;\n    t17 += v * b10;\n    t18 += v * b11;\n    t19 += v * b12;\n    t20 += v * b13;\n    t21 += v * b14;\n    t22 += v * b15;\n    v = a[8];\n    t8 += v * b0;\n    t9 += v * b1;\n    t10 += v * b2;\n    t11 += v * b3;\n    t12 += v * b4;\n    t13 += v * b5;\n    t14 += v * b6;\n    t15 += v * b7;\n    t16 += v * b8;\n    t17 += v * b9;\n    t18 += v * b10;\n    t19 += v * b11;\n    t20 += v * b12;\n    t21 += v * b13;\n    t22 += v * b14;\n    t23 += v * b15;\n    v = a[9];\n    t9 += v * b0;\n    t10 += v * b1;\n    t11 += v * b2;\n    t12 += v * b3;\n    t13 += v * b4;\n    t14 += v * b5;\n    t15 += v * b6;\n    t16 += v * b7;\n    t17 += v * b8;\n    t18 += v * b9;\n    t19 += v * b10;\n    t20 += v * b11;\n    t21 += v * b12;\n    t22 += v * b13;\n    t23 += v * b14;\n    t24 += v * b15;\n    v = a[10];\n    t10 += v * b0;\n    t11 += v * b1;\n    t12 += v * b2;\n    t13 += v * b3;\n    t14 += v * b4;\n    t15 += v * b5;\n    t16 += v * b6;\n    t17 += v * b7;\n    t18 += v * b8;\n    t19 += v * b9;\n    t20 += v * b10;\n    t21 += v * b11;\n    t22 += v * b12;\n    t23 += v * b13;\n    t24 += v * b14;\n    t25 += v * b15;\n    v = a[11];\n    t11 += v * b0;\n    t12 += v * b1;\n    t13 += v * b2;\n    t14 += v * b3;\n    t15 += v * b4;\n    t16 += v * b5;\n    t17 += v * b6;\n    t18 += v * b7;\n    t19 += v * b8;\n    t20 += v * b9;\n    t21 += v * b10;\n    t22 += v * b11;\n    t23 += v * b12;\n    t24 += v * b13;\n    t25 += v * b14;\n    t26 += v * b15;\n    v = a[12];\n    t12 += v * b0;\n    t13 += v * b1;\n    t14 += v * b2;\n    t15 += v * b3;\n    t16 += v * b4;\n    t17 += v * b5;\n    t18 += v * b6;\n    t19 += v * b7;\n    t20 += v * b8;\n    t21 += v * b9;\n    t22 += v * b10;\n    t23 += v * b11;\n    t24 += v * b12;\n    t25 += v * b13;\n    t26 += v * b14;\n    t27 += v * b15;\n    v = a[13];\n    t13 += v * b0;\n    t14 += v * b1;\n    t15 += v * b2;\n    t16 += v * b3;\n    t17 += v * b4;\n    t18 += v * b5;\n    t19 += v * b6;\n    t20 += v * b7;\n    t21 += v * b8;\n    t22 += v * b9;\n    t23 += v * b10;\n    t24 += v * b11;\n    t25 += v * b12;\n    t26 += v * b13;\n    t27 += v * b14;\n    t28 += v * b15;\n    v = a[14];\n    t14 += v * b0;\n    t15 += v * b1;\n    t16 += v * b2;\n    t17 += v * b3;\n    t18 += v * b4;\n    t19 += v * b5;\n    t20 += v * b6;\n    t21 += v * b7;\n    t22 += v * b8;\n    t23 += v * b9;\n    t24 += v * b10;\n    t25 += v * b11;\n    t26 += v * b12;\n    t27 += v * b13;\n    t28 += v * b14;\n    t29 += v * b15;\n    v = a[15];\n    t15 += v * b0;\n    t16 += v * b1;\n    t17 += v * b2;\n    t18 += v * b3;\n    t19 += v * b4;\n    t20 += v * b5;\n    t21 += v * b6;\n    t22 += v * b7;\n    t23 += v * b8;\n    t24 += v * b9;\n    t25 += v * b10;\n    t26 += v * b11;\n    t27 += v * b12;\n    t28 += v * b13;\n    t29 += v * b14;\n    t30 += v * b15;\n    t0 += 38 * t16;\n    t1 += 38 * t17;\n    t2 += 38 * t18;\n    t3 += 38 * t19;\n    t4 += 38 * t20;\n    t5 += 38 * t21;\n    t6 += 38 * t22;\n    t7 += 38 * t23;\n    t8 += 38 * t24;\n    t9 += 38 * t25;\n    t10 += 38 * t26;\n    t11 += 38 * t27;\n    t12 += 38 * t28;\n    t13 += 38 * t29;\n    t14 += 38 * t30;\n    // t15 left as is\n\n    // first car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n\n    // second car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    o[0] = t0;\n    o[1] = t1;\n    o[2] = t2;\n    o[3] = t3;\n    o[4] = t4;\n    o[5] = t5;\n    o[6] = t6;\n    o[7] = t7;\n    o[8] = t8;\n    o[9] = t9;\n    o[10] = t10;\n    o[11] = t11;\n    o[12] = t12;\n    o[13] = t13;\n    o[14] = t14;\n    o[15] = t15;\n  }\n  function S(o, a) {\n    M(o, a, a);\n  }\n  function inv25519(o, i) {\n    var c = gf();\n    var a;\n    for (a = 0; a < 16; a++) c[a] = i[a];\n    for (a = 253; a >= 0; a--) {\n      S(c, c);\n      if (a !== 2 && a !== 4) M(c, c, i);\n    }\n    for (a = 0; a < 16; a++) o[a] = c[a];\n  }\n  function pow2523(o, i) {\n    var c = gf();\n    var a;\n    for (a = 0; a < 16; a++) c[a] = i[a];\n    for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if (a !== 1) M(c, c, i);\n    }\n    for (a = 0; a < 16; a++) o[a] = c[a];\n  }\n  function crypto_scalarmult(q, n, p) {\n    var z = new Uint8Array(32);\n    var x = new Float64Array(80),\n      r,\n      i;\n    var a = gf(),\n      b = gf(),\n      c = gf(),\n      d = gf(),\n      e = gf(),\n      f = gf();\n    for (i = 0; i < 31; i++) z[i] = n[i];\n    z[31] = n[31] & 127 | 64;\n    z[0] &= 248;\n    unpack25519(x, p);\n    for (i = 0; i < 16; i++) {\n      b[i] = x[i];\n      d[i] = a[i] = c[i] = 0;\n    }\n    a[0] = d[0] = 1;\n    for (i = 254; i >= 0; --i) {\n      r = z[i >>> 3] >>> (i & 7) & 1;\n      sel25519(a, b, r);\n      sel25519(c, d, r);\n      A(e, a, c);\n      Z(a, a, c);\n      A(c, b, d);\n      Z(b, b, d);\n      S(d, e);\n      S(f, a);\n      M(a, c, a);\n      M(c, b, e);\n      A(e, a, c);\n      Z(a, a, c);\n      S(b, a);\n      Z(c, d, f);\n      M(a, c, _121665);\n      A(a, a, d);\n      M(c, c, a);\n      M(a, d, f);\n      M(d, b, x);\n      S(b, e);\n      sel25519(a, b, r);\n      sel25519(c, d, r);\n    }\n    for (i = 0; i < 16; i++) {\n      x[i + 16] = a[i];\n      x[i + 32] = c[i];\n      x[i + 48] = b[i];\n      x[i + 64] = d[i];\n    }\n    var x32 = x.subarray(32);\n    var x16 = x.subarray(16);\n    inv25519(x32, x32);\n    M(x16, x16, x32);\n    pack25519(q, x16);\n    return 0;\n  }\n  function crypto_scalarmult_base(q, n) {\n    return crypto_scalarmult(q, n, _9);\n  }\n  function crypto_box_keypair(y, x) {\n    randombytes(x, 32);\n    return crypto_scalarmult_base(y, x);\n  }\n  function crypto_box_beforenm(k, y, x) {\n    var s = new Uint8Array(32);\n    crypto_scalarmult(s, x, y);\n    return crypto_core_hsalsa20(k, _0, s, sigma);\n  }\n  var crypto_box_afternm = crypto_secretbox;\n  var crypto_box_open_afternm = crypto_secretbox_open;\n  function crypto_box(c, m, d, n, y, x) {\n    var k = new Uint8Array(32);\n    crypto_box_beforenm(k, y, x);\n    return crypto_box_afternm(c, m, d, n, k);\n  }\n  function crypto_box_open(m, c, d, n, y, x) {\n    var k = new Uint8Array(32);\n    crypto_box_beforenm(k, y, x);\n    return crypto_box_open_afternm(m, c, d, n, k);\n  }\n  var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];\n  function crypto_hashblocks_hl(hh, hl, m, n) {\n    var wh = new Int32Array(16),\n      wl = new Int32Array(16),\n      bh0,\n      bh1,\n      bh2,\n      bh3,\n      bh4,\n      bh5,\n      bh6,\n      bh7,\n      bl0,\n      bl1,\n      bl2,\n      bl3,\n      bl4,\n      bl5,\n      bl6,\n      bl7,\n      th,\n      tl,\n      i,\n      j,\n      h,\n      l,\n      a,\n      b,\n      c,\n      d;\n    var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n    var pos = 0;\n    while (n >= 128) {\n      for (i = 0; i < 16; i++) {\n        j = 8 * i + pos;\n        wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];\n        wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];\n      }\n      for (i = 0; i < 80; i++) {\n        bh0 = ah0;\n        bh1 = ah1;\n        bh2 = ah2;\n        bh3 = ah3;\n        bh4 = ah4;\n        bh5 = ah5;\n        bh6 = ah6;\n        bh7 = ah7;\n        bl0 = al0;\n        bl1 = al1;\n        bl2 = al2;\n        bl3 = al3;\n        bl4 = al4;\n        bl5 = al5;\n        bl6 = al6;\n        bl7 = al7;\n\n        // add\n        h = ah7;\n        l = al7;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n\n        // Sigma1\n        h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));\n        l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n\n        // Ch\n        h = ah4 & ah5 ^ ~ah4 & ah6;\n        l = al4 & al5 ^ ~al4 & al6;\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n\n        // K\n        h = K[i * 2];\n        l = K[i * 2 + 1];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n\n        // w\n        h = wh[i % 16];\n        l = wl[i % 16];\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        th = c & 0xffff | d << 16;\n        tl = a & 0xffff | b << 16;\n\n        // add\n        h = th;\n        l = tl;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n\n        // Sigma0\n        h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));\n        l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n\n        // Maj\n        h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;\n        l = al0 & al1 ^ al0 & al2 ^ al1 & al2;\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        bh7 = c & 0xffff | d << 16;\n        bl7 = a & 0xffff | b << 16;\n\n        // add\n        h = bh3;\n        l = bl3;\n        a = l & 0xffff;\n        b = l >>> 16;\n        c = h & 0xffff;\n        d = h >>> 16;\n        h = th;\n        l = tl;\n        a += l & 0xffff;\n        b += l >>> 16;\n        c += h & 0xffff;\n        d += h >>> 16;\n        b += a >>> 16;\n        c += b >>> 16;\n        d += c >>> 16;\n        bh3 = c & 0xffff | d << 16;\n        bl3 = a & 0xffff | b << 16;\n        ah1 = bh0;\n        ah2 = bh1;\n        ah3 = bh2;\n        ah4 = bh3;\n        ah5 = bh4;\n        ah6 = bh5;\n        ah7 = bh6;\n        ah0 = bh7;\n        al1 = bl0;\n        al2 = bl1;\n        al3 = bl2;\n        al4 = bl3;\n        al5 = bl4;\n        al6 = bl5;\n        al7 = bl6;\n        al0 = bl7;\n        if (i % 16 === 15) {\n          for (j = 0; j < 16; j++) {\n            // add\n            h = wh[j];\n            l = wl[j];\n            a = l & 0xffff;\n            b = l >>> 16;\n            c = h & 0xffff;\n            d = h >>> 16;\n            h = wh[(j + 9) % 16];\n            l = wl[(j + 9) % 16];\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n\n            // sigma0\n            th = wh[(j + 1) % 16];\n            tl = wl[(j + 1) % 16];\n            h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;\n            l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n\n            // sigma1\n            th = wh[(j + 14) % 16];\n            tl = wl[(j + 14) % 16];\n            h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;\n            l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);\n            a += l & 0xffff;\n            b += l >>> 16;\n            c += h & 0xffff;\n            d += h >>> 16;\n            b += a >>> 16;\n            c += b >>> 16;\n            d += c >>> 16;\n            wh[j] = c & 0xffff | d << 16;\n            wl[j] = a & 0xffff | b << 16;\n          }\n        }\n      }\n\n      // add\n      h = ah0;\n      l = al0;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[0];\n      l = hl[0];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[0] = ah0 = c & 0xffff | d << 16;\n      hl[0] = al0 = a & 0xffff | b << 16;\n      h = ah1;\n      l = al1;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[1];\n      l = hl[1];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[1] = ah1 = c & 0xffff | d << 16;\n      hl[1] = al1 = a & 0xffff | b << 16;\n      h = ah2;\n      l = al2;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[2];\n      l = hl[2];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[2] = ah2 = c & 0xffff | d << 16;\n      hl[2] = al2 = a & 0xffff | b << 16;\n      h = ah3;\n      l = al3;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[3];\n      l = hl[3];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[3] = ah3 = c & 0xffff | d << 16;\n      hl[3] = al3 = a & 0xffff | b << 16;\n      h = ah4;\n      l = al4;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[4];\n      l = hl[4];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[4] = ah4 = c & 0xffff | d << 16;\n      hl[4] = al4 = a & 0xffff | b << 16;\n      h = ah5;\n      l = al5;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[5];\n      l = hl[5];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[5] = ah5 = c & 0xffff | d << 16;\n      hl[5] = al5 = a & 0xffff | b << 16;\n      h = ah6;\n      l = al6;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[6];\n      l = hl[6];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[6] = ah6 = c & 0xffff | d << 16;\n      hl[6] = al6 = a & 0xffff | b << 16;\n      h = ah7;\n      l = al7;\n      a = l & 0xffff;\n      b = l >>> 16;\n      c = h & 0xffff;\n      d = h >>> 16;\n      h = hh[7];\n      l = hl[7];\n      a += l & 0xffff;\n      b += l >>> 16;\n      c += h & 0xffff;\n      d += h >>> 16;\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n      hh[7] = ah7 = c & 0xffff | d << 16;\n      hl[7] = al7 = a & 0xffff | b << 16;\n      pos += 128;\n      n -= 128;\n    }\n    return n;\n  }\n  function crypto_hash(out, m, n) {\n    var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i,\n      b = n;\n    hh[0] = 0x6a09e667;\n    hh[1] = 0xbb67ae85;\n    hh[2] = 0x3c6ef372;\n    hh[3] = 0xa54ff53a;\n    hh[4] = 0x510e527f;\n    hh[5] = 0x9b05688c;\n    hh[6] = 0x1f83d9ab;\n    hh[7] = 0x5be0cd19;\n    hl[0] = 0xf3bcc908;\n    hl[1] = 0x84caa73b;\n    hl[2] = 0xfe94f82b;\n    hl[3] = 0x5f1d36f1;\n    hl[4] = 0xade682d1;\n    hl[5] = 0x2b3e6c1f;\n    hl[6] = 0xfb41bd6b;\n    hl[7] = 0x137e2179;\n    crypto_hashblocks_hl(hh, hl, m, n);\n    n %= 128;\n    for (i = 0; i < n; i++) x[i] = m[b - n + i];\n    x[n] = 128;\n    n = 256 - 128 * (n < 112 ? 1 : 0);\n    x[n - 9] = 0;\n    ts64(x, n - 8, b / 0x20000000 | 0, b << 3);\n    crypto_hashblocks_hl(hh, hl, x, n);\n    for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);\n    return 0;\n  }\n  function add(p, q) {\n    var a = gf(),\n      b = gf(),\n      c = gf(),\n      d = gf(),\n      e = gf(),\n      f = gf(),\n      g = gf(),\n      h = gf(),\n      t = gf();\n    Z(a, p[1], p[0]);\n    Z(t, q[1], q[0]);\n    M(a, a, t);\n    A(b, p[0], p[1]);\n    A(t, q[0], q[1]);\n    M(b, b, t);\n    M(c, p[3], q[3]);\n    M(c, c, D2);\n    M(d, p[2], q[2]);\n    A(d, d, d);\n    Z(e, b, a);\n    Z(f, d, c);\n    A(g, d, c);\n    A(h, b, a);\n    M(p[0], e, f);\n    M(p[1], h, g);\n    M(p[2], g, f);\n    M(p[3], e, h);\n  }\n  function cswap(p, q, b) {\n    var i;\n    for (i = 0; i < 4; i++) {\n      sel25519(p[i], q[i], b);\n    }\n  }\n  function pack(r, p) {\n    var tx = gf(),\n      ty = gf(),\n      zi = gf();\n    inv25519(zi, p[2]);\n    M(tx, p[0], zi);\n    M(ty, p[1], zi);\n    pack25519(r, ty);\n    r[31] ^= par25519(tx) << 7;\n  }\n  function scalarmult(p, q, s) {\n    var b, i;\n    set25519(p[0], gf0);\n    set25519(p[1], gf1);\n    set25519(p[2], gf1);\n    set25519(p[3], gf0);\n    for (i = 255; i >= 0; --i) {\n      b = s[i / 8 | 0] >> (i & 7) & 1;\n      cswap(p, q, b);\n      add(q, p);\n      add(p, p);\n      cswap(p, q, b);\n    }\n  }\n  function scalarbase(p, s) {\n    var q = [gf(), gf(), gf(), gf()];\n    set25519(q[0], X);\n    set25519(q[1], Y);\n    set25519(q[2], gf1);\n    M(q[3], X, Y);\n    scalarmult(p, q, s);\n  }\n  function crypto_sign_keypair(pk, sk, seeded) {\n    var d = new Uint8Array(64);\n    var p = [gf(), gf(), gf(), gf()];\n    var i;\n    if (!seeded) randombytes(sk, 32);\n    crypto_hash(d, sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    scalarbase(p, d);\n    pack(pk, p);\n    for (i = 0; i < 32; i++) sk[i + 32] = pk[i];\n    return 0;\n  }\n  var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n  function modL(r, x) {\n    var carry, i, j, k;\n    for (i = 63; i >= 32; --i) {\n      carry = 0;\n      for (j = i - 32, k = i - 12; j < k; ++j) {\n        x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n        carry = x[j] + 128 >> 8;\n        x[j] -= carry * 256;\n      }\n      x[j] += carry;\n      x[i] = 0;\n    }\n    carry = 0;\n    for (j = 0; j < 32; j++) {\n      x[j] += carry - (x[31] >> 4) * L[j];\n      carry = x[j] >> 8;\n      x[j] &= 255;\n    }\n    for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n    for (i = 0; i < 32; i++) {\n      x[i + 1] += x[i] >> 8;\n      r[i] = x[i] & 255;\n    }\n  }\n  function reduce(r) {\n    var x = new Float64Array(64),\n      i;\n    for (i = 0; i < 64; i++) x[i] = r[i];\n    for (i = 0; i < 64; i++) r[i] = 0;\n    modL(r, x);\n  }\n\n  // Note: difference from C - smlen returned, not passed as argument.\n  function crypto_sign(sm, m, n, sk) {\n    var d = new Uint8Array(64),\n      h = new Uint8Array(64),\n      r = new Uint8Array(64);\n    var i,\n      j,\n      x = new Float64Array(64);\n    var p = [gf(), gf(), gf(), gf()];\n    crypto_hash(d, sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    var smlen = n + 64;\n    for (i = 0; i < n; i++) sm[64 + i] = m[i];\n    for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n    crypto_hash(r, sm.subarray(32), n + 32);\n    reduce(r);\n    scalarbase(p, r);\n    pack(sm, p);\n    for (i = 32; i < 64; i++) sm[i] = sk[i];\n    crypto_hash(h, sm, n + 64);\n    reduce(h);\n    for (i = 0; i < 64; i++) x[i] = 0;\n    for (i = 0; i < 32; i++) x[i] = r[i];\n    for (i = 0; i < 32; i++) {\n      for (j = 0; j < 32; j++) {\n        x[i + j] += h[i] * d[j];\n      }\n    }\n    modL(sm.subarray(32), x);\n    return smlen;\n  }\n  function unpackneg(r, p) {\n    var t = gf(),\n      chk = gf(),\n      num = gf(),\n      den = gf(),\n      den2 = gf(),\n      den4 = gf(),\n      den6 = gf();\n    set25519(r[2], gf1);\n    unpack25519(r[1], p);\n    S(num, r[1]);\n    M(den, num, D);\n    Z(num, num, r[2]);\n    A(den, r[2], den);\n    S(den2, den);\n    S(den4, den2);\n    M(den6, den4, den2);\n    M(t, den6, num);\n    M(t, t, den);\n    pow2523(t, t);\n    M(t, t, num);\n    M(t, t, den);\n    M(t, t, den);\n    M(r[0], t, den);\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) M(r[0], r[0], I);\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) return -1;\n    if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n    M(r[3], r[0], r[1]);\n    return 0;\n  }\n  function crypto_sign_open(m, sm, n, pk) {\n    var i, mlen;\n    var t = new Uint8Array(32),\n      h = new Uint8Array(64);\n    var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n    mlen = -1;\n    if (n < 64) return -1;\n    if (unpackneg(q, pk)) return -1;\n    for (i = 0; i < n; i++) m[i] = sm[i];\n    for (i = 0; i < 32; i++) m[i + 32] = pk[i];\n    crypto_hash(h, m, n);\n    reduce(h);\n    scalarmult(p, q, h);\n    scalarbase(q, sm.subarray(32));\n    add(p, q);\n    pack(t, p);\n    n -= 64;\n    if (crypto_verify_32(sm, 0, t, 0)) {\n      for (i = 0; i < n; i++) m[i] = 0;\n      return -1;\n    }\n    for (i = 0; i < n; i++) m[i] = sm[i + 64];\n    mlen = n;\n    return mlen;\n  }\n  var crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n  nacl.lowlevel = {\n    crypto_core_hsalsa20: crypto_core_hsalsa20,\n    crypto_stream_xor: crypto_stream_xor,\n    crypto_stream: crypto_stream,\n    crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n    crypto_stream_salsa20: crypto_stream_salsa20,\n    crypto_onetimeauth: crypto_onetimeauth,\n    crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n    crypto_verify_16: crypto_verify_16,\n    crypto_verify_32: crypto_verify_32,\n    crypto_secretbox: crypto_secretbox,\n    crypto_secretbox_open: crypto_secretbox_open,\n    crypto_scalarmult: crypto_scalarmult,\n    crypto_scalarmult_base: crypto_scalarmult_base,\n    crypto_box_beforenm: crypto_box_beforenm,\n    crypto_box_afternm: crypto_box_afternm,\n    crypto_box: crypto_box,\n    crypto_box_open: crypto_box_open,\n    crypto_box_keypair: crypto_box_keypair,\n    crypto_hash: crypto_hash,\n    crypto_sign: crypto_sign,\n    crypto_sign_keypair: crypto_sign_keypair,\n    crypto_sign_open: crypto_sign_open,\n    crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n    crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n    crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n    crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n    crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n    crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n    crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n    crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n    crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n    crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n    crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n    crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n    crypto_sign_BYTES: crypto_sign_BYTES,\n    crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n    crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n    crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n    crypto_hash_BYTES: crypto_hash_BYTES\n  };\n\n  /* High-level API */\n\n  function checkLengths(k, n) {\n    if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n    if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n  }\n  function checkBoxLengths(pk, sk) {\n    if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n    if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n  }\n  function checkArrayTypes() {\n    var t, i;\n    for (i = 0; i < arguments.length; i++) {\n      if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]') throw new TypeError('unexpected type ' + t + ', use Uint8Array');\n    }\n  }\n  function cleanup(arr) {\n    for (var i = 0; i < arr.length; i++) arr[i] = 0;\n  }\n\n  // TODO: Completely remove this in v0.15.\n  if (!nacl.util) {\n    nacl.util = {};\n    nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function () {\n      throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');\n    };\n  }\n  nacl.randomBytes = function (n) {\n    var b = new Uint8Array(n);\n    randombytes(b, n);\n    return b;\n  };\n  nacl.secretbox = function (msg, nonce, key) {\n    checkArrayTypes(msg, nonce, key);\n    checkLengths(key, nonce);\n    var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n    var c = new Uint8Array(m.length);\n    for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n    crypto_secretbox(c, m, m.length, nonce, key);\n    return c.subarray(crypto_secretbox_BOXZEROBYTES);\n  };\n  nacl.secretbox.open = function (box, nonce, key) {\n    checkArrayTypes(box, nonce, key);\n    checkLengths(key, nonce);\n    var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n    var m = new Uint8Array(c.length);\n    for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n    if (c.length < 32) return false;\n    if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;\n    return m.subarray(crypto_secretbox_ZEROBYTES);\n  };\n  nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n  nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n  nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n  nacl.scalarMult = function (n, p) {\n    checkArrayTypes(n, p);\n    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n    if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n    var q = new Uint8Array(crypto_scalarmult_BYTES);\n    crypto_scalarmult(q, n, p);\n    return q;\n  };\n  nacl.scalarMult.base = function (n) {\n    checkArrayTypes(n);\n    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n    var q = new Uint8Array(crypto_scalarmult_BYTES);\n    crypto_scalarmult_base(q, n);\n    return q;\n  };\n  nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n  nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n  nacl.box = function (msg, nonce, publicKey, secretKey) {\n    var k = nacl.box.before(publicKey, secretKey);\n    return nacl.secretbox(msg, nonce, k);\n  };\n  nacl.box.before = function (publicKey, secretKey) {\n    checkArrayTypes(publicKey, secretKey);\n    checkBoxLengths(publicKey, secretKey);\n    var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n    crypto_box_beforenm(k, publicKey, secretKey);\n    return k;\n  };\n  nacl.box.after = nacl.secretbox;\n  nacl.box.open = function (msg, nonce, publicKey, secretKey) {\n    var k = nacl.box.before(publicKey, secretKey);\n    return nacl.secretbox.open(msg, nonce, k);\n  };\n  nacl.box.open.after = nacl.secretbox.open;\n  nacl.box.keyPair = function () {\n    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n    var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n    crypto_box_keypair(pk, sk);\n    return {\n      publicKey: pk,\n      secretKey: sk\n    };\n  };\n  nacl.box.keyPair.fromSecretKey = function (secretKey) {\n    checkArrayTypes(secretKey);\n    if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n    crypto_scalarmult_base(pk, secretKey);\n    return {\n      publicKey: pk,\n      secretKey: new Uint8Array(secretKey)\n    };\n  };\n  nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n  nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n  nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n  nacl.box.nonceLength = crypto_box_NONCEBYTES;\n  nacl.box.overheadLength = nacl.secretbox.overheadLength;\n  nacl.sign = function (msg, secretKey) {\n    checkArrayTypes(msg, secretKey);\n    if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n    var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n    crypto_sign(signedMsg, msg, msg.length, secretKey);\n    return signedMsg;\n  };\n  nacl.sign.open = function (signedMsg, publicKey) {\n    if (arguments.length !== 2) throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');\n    checkArrayTypes(signedMsg, publicKey);\n    if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n    var tmp = new Uint8Array(signedMsg.length);\n    var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n    if (mlen < 0) return null;\n    var m = new Uint8Array(mlen);\n    for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n    return m;\n  };\n  nacl.sign.detached = function (msg, secretKey) {\n    var signedMsg = nacl.sign(msg, secretKey);\n    var sig = new Uint8Array(crypto_sign_BYTES);\n    for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n    return sig;\n  };\n  nacl.sign.detached.verify = function (msg, sig, publicKey) {\n    checkArrayTypes(msg, sig, publicKey);\n    if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');\n    if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');\n    var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n    var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n    var i;\n    for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n    for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];\n    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n  };\n  nacl.sign.keyPair = function () {\n    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n    crypto_sign_keypair(pk, sk);\n    return {\n      publicKey: pk,\n      secretKey: sk\n    };\n  };\n  nacl.sign.keyPair.fromSecretKey = function (secretKey) {\n    checkArrayTypes(secretKey);\n    if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');\n    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n    for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];\n    return {\n      publicKey: pk,\n      secretKey: new Uint8Array(secretKey)\n    };\n  };\n  nacl.sign.keyPair.fromSeed = function (seed) {\n    checkArrayTypes(seed);\n    if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');\n    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n    for (var i = 0; i < 32; i++) sk[i] = seed[i];\n    crypto_sign_keypair(pk, sk, true);\n    return {\n      publicKey: pk,\n      secretKey: sk\n    };\n  };\n  nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n  nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n  nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n  nacl.sign.signatureLength = crypto_sign_BYTES;\n  nacl.hash = function (msg) {\n    checkArrayTypes(msg);\n    var h = new Uint8Array(crypto_hash_BYTES);\n    crypto_hash(h, msg, msg.length);\n    return h;\n  };\n  nacl.hash.hashLength = crypto_hash_BYTES;\n  nacl.verify = function (x, y) {\n    checkArrayTypes(x, y);\n    // Zero length arguments are considered not equal.\n    if (x.length === 0 || y.length === 0) return false;\n    if (x.length !== y.length) return false;\n    return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n  };\n  nacl.setPRNG = function (fn) {\n    randombytes = fn;\n  };\n  (function () {\n    // Initialize PRNG if environment provides CSPRNG.\n    // If not, methods calling randombytes will throw.\n    var crypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;\n    if (crypto && crypto.getRandomValues) {\n      // Browsers.\n      var QUOTA = 65536;\n      nacl.setPRNG(function (x, n) {\n        var i,\n          v = new Uint8Array(n);\n        for (i = 0; i < n; i += QUOTA) {\n          crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n        }\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    } else if (typeof require !== 'undefined') {\n      // Node.js.\n      crypto = require('crypto');\n      if (crypto && crypto.randomBytes) {\n        nacl.setPRNG(function (x, n) {\n          var i,\n            v = crypto.randomBytes(n);\n          for (i = 0; i < n; i++) x[i] = v[i];\n          cleanup(v);\n        });\n      }\n    }\n  })();\n})(typeof module !== 'undefined' && module.exports ? module.exports : self.nacl = self.nacl || {});","var undefined = void 0; // Paranoia\n\n// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n// create, and consume so much memory, that the browser appears frozen.\nvar MAX_ARRAY_LENGTH = 1e5;\n\n// Approximations of internal ECMAScript conversion functions\nvar ECMAScript = function () {\n  // Stash a copy in case other scripts modify these\n  var opts = Object.prototype.toString,\n    ophop = Object.prototype.hasOwnProperty;\n  return {\n    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n    Class: function (v) {\n      return opts.call(v).replace(/^\\[object *|\\]$/g, '');\n    },\n    HasProperty: function (o, p) {\n      return p in o;\n    },\n    HasOwnProperty: function (o, p) {\n      return ophop.call(o, p);\n    },\n    IsCallable: function (o) {\n      return typeof o === 'function';\n    },\n    ToInt32: function (v) {\n      return v >> 0;\n    },\n    ToUint32: function (v) {\n      return v >>> 0;\n    }\n  };\n}();\n\n// Snapshot intrinsics\nvar LN2 = Math.LN2,\n  abs = Math.abs,\n  floor = Math.floor,\n  log = Math.log,\n  min = Math.min,\n  pow = Math.pow,\n  round = Math.round;\n\n// ES5: lock down object properties\nfunction configureProperties(obj) {\n  if (getOwnPropNames && defineProp) {\n    var props = getOwnPropNames(obj),\n      i;\n    for (i = 0; i < props.length; i += 1) {\n      defineProp(obj, props[i], {\n        value: obj[props[i]],\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n}\n\n// emulate ES5 getter/setter API using legacy APIs\n// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\nvar defineProp;\nif (Object.defineProperty && function () {\n  try {\n    Object.defineProperty({}, 'x', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n}()) {\n  defineProp = Object.defineProperty;\n} else {\n  defineProp = function (o, p, desc) {\n    if (!o === Object(o)) throw new TypeError(\"Object.defineProperty called on non-object\");\n    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) {\n      Object.prototype.__defineGetter__.call(o, p, desc.get);\n    }\n    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) {\n      Object.prototype.__defineSetter__.call(o, p, desc.set);\n    }\n    if (ECMAScript.HasProperty(desc, 'value')) {\n      o[p] = desc.value;\n    }\n    return o;\n  };\n}\nvar getOwnPropNames = Object.getOwnPropertyNames || function (o) {\n  if (o !== Object(o)) throw new TypeError(\"Object.getOwnPropertyNames called on non-object\");\n  var props = [],\n    p;\n  for (p in o) {\n    if (ECMAScript.HasOwnProperty(o, p)) {\n      props.push(p);\n    }\n  }\n  return props;\n};\n\n// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n// for index in 0 ... obj.length\nfunction makeArrayAccessors(obj) {\n  if (!defineProp) {\n    return;\n  }\n  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError(\"Array too large for polyfill\");\n  function makeArrayAccessor(index) {\n    defineProp(obj, index, {\n      'get': function () {\n        return obj._getter(index);\n      },\n      'set': function (v) {\n        obj._setter(index, v);\n      },\n      enumerable: true,\n      configurable: false\n    });\n  }\n  var i;\n  for (i = 0; i < obj.length; i += 1) {\n    makeArrayAccessor(i);\n  }\n}\n\n// Internal conversion functions:\n//    pack<Type>()   - take a number (interpreted as Type), output a byte array\n//    unpack<Type>() - take a byte array, output a Type-like number\n\nfunction as_signed(value, bits) {\n  var s = 32 - bits;\n  return value << s >> s;\n}\nfunction as_unsigned(value, bits) {\n  var s = 32 - bits;\n  return value << s >>> s;\n}\nfunction packI8(n) {\n  return [n & 0xff];\n}\nfunction unpackI8(bytes) {\n  return as_signed(bytes[0], 8);\n}\nfunction packU8(n) {\n  return [n & 0xff];\n}\nfunction unpackU8(bytes) {\n  return as_unsigned(bytes[0], 8);\n}\nfunction packU8Clamped(n) {\n  n = round(Number(n));\n  return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff];\n}\nfunction packI16(n) {\n  return [n >> 8 & 0xff, n & 0xff];\n}\nfunction unpackI16(bytes) {\n  return as_signed(bytes[0] << 8 | bytes[1], 16);\n}\nfunction packU16(n) {\n  return [n >> 8 & 0xff, n & 0xff];\n}\nfunction unpackU16(bytes) {\n  return as_unsigned(bytes[0] << 8 | bytes[1], 16);\n}\nfunction packI32(n) {\n  return [n >> 24 & 0xff, n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff];\n}\nfunction unpackI32(bytes) {\n  return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);\n}\nfunction packU32(n) {\n  return [n >> 24 & 0xff, n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff];\n}\nfunction unpackU32(bytes) {\n  return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);\n}\nfunction packIEEE754(v, ebits, fbits) {\n  var bias = (1 << ebits - 1) - 1,\n    s,\n    e,\n    f,\n    ln,\n    i,\n    bits,\n    str,\n    bytes;\n  function roundToEven(n) {\n    var w = floor(n),\n      f = n - w;\n    if (f < 0.5) return w;\n    if (f > 0.5) return w + 1;\n    return w % 2 ? w + 1 : w;\n  }\n\n  // Compute sign, exponent, fraction\n  if (v !== v) {\n    // NaN\n    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n    e = (1 << ebits) - 1;\n    f = pow(2, fbits - 1);\n    s = 0;\n  } else if (v === Infinity || v === -Infinity) {\n    e = (1 << ebits) - 1;\n    f = 0;\n    s = v < 0 ? 1 : 0;\n  } else if (v === 0) {\n    e = 0;\n    f = 0;\n    s = 1 / v === -Infinity ? 1 : 0;\n  } else {\n    s = v < 0;\n    v = abs(v);\n    if (v >= pow(2, 1 - bias)) {\n      e = min(floor(log(v) / LN2), 1023);\n      f = roundToEven(v / pow(2, e) * pow(2, fbits));\n      if (f / pow(2, fbits) >= 2) {\n        e = e + 1;\n        f = 1;\n      }\n      if (e > bias) {\n        // Overflow\n        e = (1 << ebits) - 1;\n        f = 0;\n      } else {\n        // Normalized\n        e = e + bias;\n        f = f - pow(2, fbits);\n      }\n    } else {\n      // Denormalized\n      e = 0;\n      f = roundToEven(v / pow(2, 1 - bias - fbits));\n    }\n  }\n\n  // Pack sign, exponent, fraction\n  bits = [];\n  for (i = fbits; i; i -= 1) {\n    bits.push(f % 2 ? 1 : 0);\n    f = floor(f / 2);\n  }\n  for (i = ebits; i; i -= 1) {\n    bits.push(e % 2 ? 1 : 0);\n    e = floor(e / 2);\n  }\n  bits.push(s ? 1 : 0);\n  bits.reverse();\n  str = bits.join('');\n\n  // Bits to bytes\n  bytes = [];\n  while (str.length) {\n    bytes.push(parseInt(str.substring(0, 8), 2));\n    str = str.substring(8);\n  }\n  return bytes;\n}\nfunction unpackIEEE754(bytes, ebits, fbits) {\n  // Bytes to bits\n  var bits = [],\n    i,\n    j,\n    b,\n    str,\n    bias,\n    s,\n    e,\n    f;\n  for (i = bytes.length; i; i -= 1) {\n    b = bytes[i - 1];\n    for (j = 8; j; j -= 1) {\n      bits.push(b % 2 ? 1 : 0);\n      b = b >> 1;\n    }\n  }\n  bits.reverse();\n  str = bits.join('');\n\n  // Unpack sign, exponent, fraction\n  bias = (1 << ebits - 1) - 1;\n  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n  e = parseInt(str.substring(1, 1 + ebits), 2);\n  f = parseInt(str.substring(1 + ebits), 2);\n\n  // Produce number\n  if (e === (1 << ebits) - 1) {\n    return f !== 0 ? NaN : s * Infinity;\n  } else if (e > 0) {\n    // Normalized\n    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n  } else if (f !== 0) {\n    // Denormalized\n    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n  } else {\n    return s < 0 ? -0 : 0;\n  }\n}\nfunction unpackF64(b) {\n  return unpackIEEE754(b, 11, 52);\n}\nfunction packF64(v) {\n  return packIEEE754(v, 11, 52);\n}\nfunction unpackF32(b) {\n  return unpackIEEE754(b, 8, 23);\n}\nfunction packF32(v) {\n  return packIEEE754(v, 8, 23);\n}\n\n//\n// 3 The ArrayBuffer Type\n//\n\n(function () {\n  /** @constructor */\n  var ArrayBuffer = function ArrayBuffer(length) {\n    length = ECMAScript.ToInt32(length);\n    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');\n    this.byteLength = length;\n    this._bytes = [];\n    this._bytes.length = length;\n    var i;\n    for (i = 0; i < this.byteLength; i += 1) {\n      this._bytes[i] = 0;\n    }\n    configureProperties(this);\n  };\n  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;\n\n  //\n  // 4 The ArrayBufferView Type\n  //\n\n  // NOTE: this constructor is not exported\n  /** @constructor */\n  var ArrayBufferView = function ArrayBufferView() {\n    //this.buffer = null;\n    //this.byteOffset = 0;\n    //this.byteLength = 0;\n  };\n\n  //\n  // 5 The Typed Array View Types\n  //\n\n  function makeConstructor(bytesPerElement, pack, unpack) {\n    // Each TypedArray type requires a distinct constructor instance with\n    // identical logic, which this produces.\n\n    var ctor;\n    ctor = function (buffer, byteOffset, length) {\n      var array, sequence, i, s;\n      if (!arguments.length || typeof arguments[0] === 'number') {\n        // Constructor(unsigned long length)\n        this.length = ECMAScript.ToInt32(arguments[0]);\n        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {\n        // Constructor(TypedArray array)\n        array = arguments[0];\n        this.length = array.length;\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n        for (i = 0; i < this.length; i += 1) {\n          this._setter(i, array._getter(i));\n        }\n      } else if (typeof arguments[0] === 'object' && !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(sequence<type> array)\n        sequence = arguments[0];\n        this.length = ECMAScript.ToUint32(sequence.length);\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n        for (i = 0; i < this.length; i += 1) {\n          s = sequence[i];\n          this._setter(i, Number(s));\n        }\n      } else if (typeof arguments[0] === 'object' && (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(ArrayBuffer buffer,\n        //             optional unsigned long byteOffset, optional unsigned long length)\n        this.buffer = buffer;\n        this.byteOffset = ECMAScript.ToUint32(byteOffset);\n        if (this.byteOffset > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset out of range\");\n        }\n        if (this.byteOffset % this.BYTES_PER_ELEMENT) {\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          throw new RangeError(\"ArrayBuffer length minus the byteOffset is not a multiple of the element size.\");\n        }\n        if (arguments.length < 3) {\n          this.byteLength = this.buffer.byteLength - this.byteOffset;\n          if (this.byteLength % this.BYTES_PER_ELEMENT) {\n            throw new RangeError(\"length of buffer minus byteOffset not a multiple of the element size\");\n          }\n          this.length = this.byteLength / this.BYTES_PER_ELEMENT;\n        } else {\n          this.length = ECMAScript.ToUint32(length);\n          this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        }\n        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n      this.constructor = ctor;\n      configureProperties(this);\n      makeArrayAccessors(this);\n    };\n    ctor.prototype = new ArrayBufferView();\n    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;\n    ctor.prototype._pack = pack;\n    ctor.prototype._unpack = unpack;\n    ctor.BYTES_PER_ELEMENT = bytesPerElement;\n\n    // getter type (unsigned long index);\n    ctor.prototype._getter = function (index) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n      var bytes = [],\n        i,\n        o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    };\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    ctor.prototype.get = ctor.prototype._getter;\n\n    // setter void (unsigned long index, type value);\n    ctor.prototype._setter = function (index, value) {\n      if (arguments.length < 2) throw new SyntaxError(\"Not enough arguments\");\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n      var bytes = this._pack(value),\n        i,\n        o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    };\n\n    // void set(TypedArray array, optional unsigned long offset);\n    // void set(sequence<type> array, optional unsigned long offset);\n    ctor.prototype.set = function (index, value) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n      var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;\n      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ECMAScript.ToUint32(arguments[1]);\n        if (offset + array.length > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ECMAScript.ToUint32(sequence.length);\n        offset = ECMAScript.ToUint32(arguments[1]);\n        if (offset + len > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n    };\n\n    // TypedArray subarray(long begin, optional long end);\n    ctor.prototype.subarray = function (start, end) {\n      function clamp(v, min, max) {\n        return v < min ? min : v > max ? max : v;\n      }\n      start = ECMAScript.ToInt32(start);\n      end = ECMAScript.ToInt32(end);\n      if (arguments.length < 1) {\n        start = 0;\n      }\n      if (arguments.length < 2) {\n        end = this.length;\n      }\n      if (start < 0) {\n        start = this.length + start;\n      }\n      if (end < 0) {\n        end = this.length + end;\n      }\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n      return new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    };\n    return ctor;\n  }\n  var Int8Array = makeConstructor(1, packI8, unpackI8);\n  var Uint8Array = makeConstructor(1, packU8, unpackU8);\n  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);\n  var Int16Array = makeConstructor(2, packI16, unpackI16);\n  var Uint16Array = makeConstructor(2, packU16, unpackU16);\n  var Int32Array = makeConstructor(4, packI32, unpackI32);\n  var Uint32Array = makeConstructor(4, packU32, unpackU32);\n  var Float32Array = makeConstructor(4, packF32, unpackF32);\n  var Float64Array = makeConstructor(8, packF64, unpackF64);\n  exports.Int8Array = exports.Int8Array || Int8Array;\n  exports.Uint8Array = exports.Uint8Array || Uint8Array;\n  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;\n  exports.Int16Array = exports.Int16Array || Int16Array;\n  exports.Uint16Array = exports.Uint16Array || Uint16Array;\n  exports.Int32Array = exports.Int32Array || Int32Array;\n  exports.Uint32Array = exports.Uint32Array || Uint32Array;\n  exports.Float32Array = exports.Float32Array || Float32Array;\n  exports.Float64Array = exports.Float64Array || Float64Array;\n})();\n\n//\n// 6 The DataView View Type\n//\n\n(function () {\n  function r(array, index) {\n    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];\n  }\n  var IS_BIG_ENDIAN = function () {\n    var u16array = new exports.Uint16Array([0x1234]),\n      u8array = new exports.Uint8Array(u16array.buffer);\n    return r(u8array, 0) === 0x12;\n  }();\n\n  // Constructor(ArrayBuffer buffer,\n  //             optional unsigned long byteOffset,\n  //             optional unsigned long byteLength)\n  /** @constructor */\n  var DataView = function DataView(buffer, byteOffset, byteLength) {\n    if (arguments.length === 0) {\n      buffer = new exports.ArrayBuffer(0);\n    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {\n      throw new TypeError(\"TypeError\");\n    }\n    this.buffer = buffer || new exports.ArrayBuffer(0);\n    this.byteOffset = ECMAScript.ToUint32(byteOffset);\n    if (this.byteOffset > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset out of range\");\n    }\n    if (arguments.length < 3) {\n      this.byteLength = this.buffer.byteLength - this.byteOffset;\n    } else {\n      this.byteLength = ECMAScript.ToUint32(byteLength);\n    }\n    if (this.byteOffset + this.byteLength > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n    }\n    configureProperties(this);\n  };\n  function makeGetter(arrayType) {\n    return function (byteOffset, littleEndian) {\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n      byteOffset += this.byteOffset;\n      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n        bytes = [],\n        i;\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(uint8Array, i));\n      }\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);\n    };\n  }\n  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);\n  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);\n  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);\n  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);\n  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);\n  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);\n  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);\n  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);\n  function makeSetter(arrayType) {\n    return function (byteOffset, value, littleEndian) {\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n\n      // Get bytes\n      var typeArray = new arrayType([value]),\n        byteArray = new exports.Uint8Array(typeArray.buffer),\n        bytes = [],\n        i,\n        byteView;\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(byteArray, i));\n      }\n\n      // Flip if necessary\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      // Write them\n      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n      byteView.set(bytes);\n    };\n  }\n  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);\n  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);\n  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);\n  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);\n  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);\n  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);\n  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);\n  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);\n  exports.DataView = exports.DataView || DataView;\n})();","/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = require('util').deprecate;","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"node:fs\");","module.exports = require(\"node:path\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"util\");","module.exports = require(\"worker_threads\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const { app, BrowserWindow, ipcMain, shell, dialog, clipboard } = require('electron');\nconst path = require('path');\nconst fs = require('fs');\nconst { spawn } = require('child_process');\nconst crypto = require('crypto');\nconst os = require('os');\nconst pty = require('node-pty');\nconst { Client } = require('ssh2');\nconst SftpClient = require('ssh2-sftp-client');\nconst { Worker } = require('worker_threads');\n\n// 日志记录功能\nconst logFile = path.join(__dirname, '..', 'logs', 'app.log');\nconst logToFile = (message, type = 'INFO') => {\n  try {\n    const timestamp = new Date().toISOString();\n    const logEntry = `[${timestamp}] [${type}] ${message}\\n`;\n    fs.appendFileSync(logFile, logEntry);\n  } catch (error) {\n    console.error('Failed to write to log file:', error);\n  }\n};\n\n// 确保日志目录存在\ntry {\n  const logDir = path.join(__dirname, '..', 'logs');\n  if (!fs.existsSync(logDir)) {\n    fs.mkdirSync(logDir, { recursive: true });\n  }\n} catch (error) {\n  console.error('Failed to create log directory:', error);\n}\n\n// 加密配置\nconst ENCRYPTION_KEY = 'simple-shell-encryption-key-12345'; // 在生产环境中应该更安全地存储\nconst ENCRYPTION_ALGORITHM = 'aes-256-cbc';\nconst IV_LENGTH = 16; // 对于 aes-256-cbc，IV长度是16字节\n\n// 全局变量用于存储AI worker实例\nlet aiWorker = null;\nlet aiRequestMap = new Map();\nlet nextRequestId = 1;\n\n// 全局变量\nconst childProcesses = new Map(); // 存储所有子进程\nconst sshClients = new Map(); // 存储SSH客户端\nconst terminalProcesses = new Map(); // 存储终端进程ID映射\nlet nextProcessId = 1;\n\n// 存储活动的文件传输\nconst activeTransfers = new Map();\n\n// 获取worker文件路径\nfunction getWorkerPath() {\n  // 先尝试相对于__dirname的路径\n  let workerPath = path.join(__dirname, 'workers', 'ai-worker.js');\n  \n  // 检查文件是否存在\n  if (fs.existsSync(workerPath)) {\n    return workerPath;\n  }\n  \n  // 如果文件不存在，可能是在开发环境，尝试使用源代码路径\n  workerPath = path.join(__dirname, '..', 'src', 'workers', 'ai-worker.js');\n  if (fs.existsSync(workerPath)) {\n    return workerPath;\n  }\n  \n  // 如果都找不到，记录错误并返回null\n  console.error('无法找到AI worker文件。已尝试以下路径:');\n  console.error(path.join(__dirname, 'workers', 'ai-worker.js'));\n  console.error(path.join(__dirname, '..', 'src', 'workers', 'ai-worker.js'));\n  throw new Error('找不到AI worker文件');\n}\n\n// 创建AI Worker线程\nfunction createAIWorker() {\n  if (aiWorker) {\n    try {\n      aiWorker.terminate();\n    } catch (error) {\n      console.error('Error terminating existing AI worker:', error);\n    }\n  }\n\n  try {\n    const workerPath = getWorkerPath();\n    console.log(`创建AI worker，使用路径: ${workerPath}`);\n    \n    // 创建worker实例\n    aiWorker = new Worker(workerPath);\n    \n    // 监听worker线程的消息\n    aiWorker.on('message', (message) => {\n      const { id, result, error } = message;\n      // 查找对应的请求处理函数\n      const callback = aiRequestMap.get(id);\n      if (callback) {\n        if (error) {\n          callback.reject(error);\n        } else {\n          callback.resolve(result);\n        }\n        // 处理完成后从Map中移除\n        aiRequestMap.delete(id);\n      }\n    });\n    \n    // 处理worker错误\n    aiWorker.on('error', (error) => {\n      console.error('AI Worker error:', error);\n      // 向所有待处理的请求返回错误\n      for (const [id, callback] of aiRequestMap.entries()) {\n        callback.reject(new Error('AI Worker encountered an error: ' + error.message));\n        aiRequestMap.delete(id);\n      }\n    });\n    \n    // 处理worker退出\n    aiWorker.on('exit', (code) => {\n      console.log(`AI Worker exited with code ${code}`);\n      // 如果退出码不是正常退出(0)，尝试重启worker\n      if (code !== 0) {\n        console.log('Attempting to restart AI worker...');\n        setTimeout(() => {\n          createAIWorker();\n        }, 1000);\n      }\n      \n      // 向所有待处理的请求返回错误\n      for (const [id, callback] of aiRequestMap.entries()) {\n        callback.reject(new Error(`AI Worker stopped unexpectedly with code ${code}`));\n        aiRequestMap.delete(id);\n      }\n    });\n    \n    return aiWorker;\n  } catch (error) {\n    console.error(`无法创建AI worker:`, error);\n    return null;\n  }\n}\n\n// 加密函数\nfunction encryptText(text) {\n  if (!text) return text;\n  try {\n    // 创建随机的初始化向量\n    const iv = crypto.randomBytes(IV_LENGTH);\n    // 从加密密钥创建密钥（使用SHA-256哈希以得到正确长度的密钥）\n    const key = crypto.createHash('sha256').update(ENCRYPTION_KEY).digest();\n    // 创建加密器\n    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, key, iv);\n    // 加密文本\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    // 返回IV和加密文本的组合（使用冒号分隔）\n    return `${iv.toString('hex')}:${encrypted}`;\n  } catch (error) {\n    console.error('Encryption error:', error);\n    return text;\n  }\n}\n\n// 解密函数\nfunction decryptText(text) {\n  if (!text || !text.includes(':')) return text;\n  try {\n    // 分离IV和加密文本\n    const [ivHex, encryptedText] = text.split(':');\n    const iv = Buffer.from(ivHex, 'hex');\n    // 从加密密钥创建密钥\n    const key = crypto.createHash('sha256').update(ENCRYPTION_KEY).digest();\n    // 创建解密器\n    const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, key, iv);\n    // 解密文本\n    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n  } catch (error) {\n    console.error('Decryption error:', error);\n    return text;\n  }\n}\n\n// 递归处理连接项，加密敏感字段\nfunction processConnectionsForSave(items) {\n  return items.map(item => {\n    const result = { ...item };\n    \n    if (item.type === 'connection') {\n      // 加密敏感信息\n      if (item.password) {\n        result.password = encryptText(item.password);\n      }\n      if (item.privateKeyPath) {\n        result.privateKeyPath = encryptText(item.privateKeyPath);\n      }\n    } else if (item.type === 'group' && Array.isArray(item.items)) {\n      // 递归处理组内的项\n      result.items = processConnectionsForSave(item.items);\n    }\n    \n    return result;\n  });\n}\n\n// 递归处理连接项，解密敏感字段\nfunction processConnectionsForLoad(items) {\n  return items.map(item => {\n    const result = { ...item };\n    \n    if (item.type === 'connection') {\n      // 解密敏感信息\n      if (item.password) {\n        result.password = decryptText(item.password);\n      }\n      if (item.privateKeyPath) {\n        result.privateKeyPath = decryptText(item.privateKeyPath);\n      }\n    } else if (item.type === 'group' && Array.isArray(item.items)) {\n      // 递归处理组内的项\n      result.items = processConnectionsForLoad(item.items);\n    }\n    \n    return result;\n  });\n}\n\n// 存储进程和对应的处理函数\n// 已在文件顶部声明 childProcesses 和 nextProcessId\n\n// 处理生产和开发环境中的路径差异\nif (require('electron-squirrel-startup')) {\n  app.quit();\n}\n\n// 获取配置文件路径\nconst getConfigPath = () => {\n  // 判断是开发环境还是生产环境\n  const isDev = process.env.NODE_ENV === 'development';\n  \n  if (isDev) {\n    // 开发环境：保存到项目根目录\n    return path.join(process.cwd(), 'config.json');\n  } else {\n    // 生产环境：保存到exe同级目录\n    return path.join(path.dirname(app.getPath('exe')), 'config.json');\n  }\n};\n\n// 加载连接配置\nconst loadConnectionsConfig = () => {\n  const configPath = getConfigPath();\n  \n  try {\n    if (fs.existsSync(configPath)) {\n      const data = fs.readFileSync(configPath, 'utf8');\n      const config = JSON.parse(data);\n      \n      // 检查是否有connections字段\n      if (config.connections && Array.isArray(config.connections)) {\n        return processConnectionsForLoad(config.connections);\n      }\n    }\n  } catch (error) {\n    console.error('Failed to load connections config:', error);\n  }\n  \n  return [];\n};\n\n// 保存连接配置\nconst saveConnectionsConfig = (connections) => {\n  const configPath = getConfigPath();\n  \n  try {\n    // 加载当前配置，以保留其他设置（如AI设置）\n    let config = {};\n    if (fs.existsSync(configPath)) {\n      const data = fs.readFileSync(configPath, 'utf8');\n      config = JSON.parse(data);\n    }\n    \n    // 处理连接项以加密敏感信息\n    const processedConnections = processConnectionsForSave(connections);\n    \n    // 更新connections部分而不影响其他设置\n    config.connections = processedConnections;\n    \n    // 写回配置文件\n    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');\n    return true;\n  } catch (error) {\n    console.error('Failed to save connections config:', error);\n    return false;\n  }\n};\n\n// 选择密钥文件\nconst selectKeyFile = async () => {\n  const result = await dialog.showOpenDialog({\n    properties: ['openFile'],\n    filters: [\n      { name: '私钥文件', extensions: ['pem', 'ppk', 'key'] },\n      { name: '所有文件', extensions: ['*'] }\n    ],\n    title: '选择SSH私钥文件'\n  });\n  \n  if (result.canceled) {\n    return null;\n  }\n  \n  return result.filePaths[0];\n};\n\nconst createWindow = () => {\n  // 根据环境确定图标路径\n  let iconPath;\n  if (process.env.NODE_ENV === 'development') {\n    // 开发环境使用绝对路径\n    iconPath = path.join(process.cwd(), 'src', 'assets', 'logo.ico');\n  } else {\n    // 生产环境使用相对于__dirname的路径\n    iconPath = path.join(__dirname, 'assets', 'logo.ico');\n  }\n\n  // 创建浏览器窗口\n  const mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,\n      contextIsolation: true,\n      nodeIntegration: false,\n    },\n    icon: iconPath // 使用环境相关的图标路径\n  });\n\n  // 隐藏菜单栏\n  mainWindow.setMenuBarVisibility(false);\n\n  // 加载应用 URL\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\n\n  // 开发工具自动打开\n  if (process.env.NODE_ENV === 'development') {\n    mainWindow.webContents.openDevTools();\n  }\n\n  // 注册IPC通信\n  setupIPC(mainWindow);\n};\n\n// 初始化应用配置\nconst initializeConfig = () => {\n  const configPath = getConfigPath();\n  \n  // 检查配置文件是否存在\n  if (!fs.existsSync(configPath)) {\n    // 创建初始配置\n    const initialConfig = {\n      connections: [],\n      aiSettings: {\n        configs: [],\n        current: {\n          apiUrl: '',\n          apiKey: '',\n          model: '',\n          streamEnabled: true\n        }\n      }\n    };\n    \n    try {\n      // 写入初始配置\n      fs.writeFileSync(configPath, JSON.stringify(initialConfig, null, 2), 'utf8');\n      console.log('Created initial config file:', configPath);\n    } catch (error) {\n      console.error('Failed to create initial config file:', error);\n    }\n  } else {\n    try {\n      // 检查现有配置，确保结构完整\n      const data = fs.readFileSync(configPath, 'utf8');\n      let config = JSON.parse(data);\n      let configUpdated = false;\n      \n      // 确保connections存在\n      if (!config.connections) {\n        config.connections = [];\n        configUpdated = true;\n      }\n      \n      // 确保aiSettings存在并具有正确的结构\n      if (!config.aiSettings) {\n        config.aiSettings = {\n          configs: [],\n          current: {\n            apiUrl: '',\n            apiKey: '',\n            model: '',\n            streamEnabled: true\n          }\n        };\n        configUpdated = true;\n      } else {\n        // 检查并更新旧版本的AI设置\n        const aiSettings = config.aiSettings;\n        \n        // 兼容旧版配置格式，将单一配置迁移到多配置结构\n        if (!aiSettings.configs) {\n          aiSettings.configs = [];\n          \n          // 如果旧版本有配置数据，将其作为当前配置添加到configs中\n          if (aiSettings.apiUrl || aiSettings.apiKey || aiSettings.model) {\n            const oldConfig = {\n              id: Date.now().toString(),\n              name: \"默认配置\",\n              apiUrl: aiSettings.apiUrl || '',\n              apiKey: aiSettings.apiKey || '',\n              model: aiSettings.model || '',\n              streamEnabled: aiSettings.streamEnabled !== undefined ? aiSettings.streamEnabled : true\n            };\n            \n            aiSettings.configs.push(oldConfig);\n            \n            // 保留当前配置\n            aiSettings.current = { ...oldConfig };\n          }\n          \n          // 删除旧的顶层属性\n          ['apiUrl', 'apiKey', 'model', 'streamEnabled'].forEach(key => {\n            if (key in aiSettings && key !== 'configs' && key !== 'current') {\n              delete aiSettings[key];\n            }\n          });\n          \n          configUpdated = true;\n        }\n        \n        // 确保current存在\n        if (!aiSettings.current) {\n          aiSettings.current = {\n            apiUrl: '',\n            apiKey: '',\n            model: '',\n            streamEnabled: true\n          };\n          configUpdated = true;\n        }\n        \n        // 确保current中的所有必要字段都存在\n        const currentFields = ['apiUrl', 'apiKey', 'model', 'streamEnabled'];\n        currentFields.forEach(field => {\n          if (aiSettings.current[field] === undefined) {\n            if (field === 'streamEnabled') {\n              aiSettings.current[field] = true;\n            } else {\n              aiSettings.current[field] = '';\n            }\n            configUpdated = true;\n          }\n        });\n      }\n      \n      // 如果需要，更新配置文件\n      if (configUpdated) {\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');\n        console.log('Updated config file structure:', configPath);\n      }\n    } catch (error) {\n      console.error('Error checking config file structure:', error);\n      \n      // 如果解析失败（例如文件为空或格式错误），创建新的配置文件\n      try {\n        const initialConfig = {\n          connections: [],\n          aiSettings: {\n            configs: [],\n            current: {\n              apiUrl: '',\n              apiKey: '',\n              model: '',\n              streamEnabled: true\n            }\n          }\n        };\n        \n        fs.writeFileSync(configPath, JSON.stringify(initialConfig, null, 2), 'utf8');\n        console.log('Recreated config file due to parsing error:', configPath);\n      } catch (writeError) {\n        console.error('Failed to recreate config file:', writeError);\n      }\n    }\n  }\n};\n\n// 在应用准备好时创建窗口并初始化配置\napp.on('ready', () => {\n  // 初始化配置\n  initializeConfig();\n  \n  // 创建窗口\n  createWindow();\n  \n  // 创建AI Worker\n  createAIWorker();\n});\n\n// 在应用退出前清理资源\napp.on('before-quit', () => {\n  // 移除所有事件监听器和子进程\n  for (const [id, proc] of childProcesses.entries()) {\n    try {\n      if (proc.process) {\n        // 移除所有事件监听器\n        if (proc.process.stdout) {\n          proc.process.stdout.removeAllListeners();\n        }\n        if (proc.process.stderr) {\n          proc.process.stderr.removeAllListeners();\n        }\n        \n        // 终止进程\n        try {\n          if (typeof proc.process.kill === 'function') {\n            // 正常终止进程\n            proc.process.kill();\n          }\n        } catch (error) {\n          console.error(`Error killing process ${id}:`, error);\n        }\n      }\n    } catch (error) {\n      console.error(`Error cleaning up process ${id}:`, error);\n    }\n  }\n  // 清空进程映射\n  childProcesses.clear();\n});\n\n// 关闭所有窗口时退出应用（macOS除外）\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    // 关闭应用前终止worker线程\n    if (aiWorker) {\n      aiWorker.terminate().catch(err => console.error('Error terminating AI worker:', err));\n    }\n    app.quit();\n  }\n});\n\napp.on('activate', () => {\n  if (BrowserWindow.getAllWindows().length === 0) {\n    createWindow();\n  }\n});\n\n// 设置IPC通信\nfunction setupIPC(mainWindow) {\n  // 启动PowerShell进程\n  ipcMain.handle('terminal:startPowerShell', async () => {\n    const processId = nextProcessId++;\n    \n    // 获取PowerShell路径\n    const powershellPath = process.platform === 'win32' \n      ? 'powershell.exe' \n      : 'pwsh';\n    \n    try {\n      // 启动PowerShell进程\n      const ps = spawn(powershellPath, ['-NoLogo'], {\n        env: process.env,\n        cwd: process.env.USERPROFILE || process.env.HOME\n      });\n      \n      // 存储进程信息\n      childProcesses.set(processId, {\n        process: ps,\n        listeners: new Set()\n      });\n      \n      // 处理PowerShell输出\n      ps.stdout.on('data', (data) => {\n        try {\n          // 检查主窗口是否还存在且未被销毁\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            const output = data.toString();\n            mainWindow.webContents.send(`process:output:${processId}`, output);\n          }\n        } catch (error) {\n          console.error('Error handling stdout data:', error);\n        }\n      });\n      \n      ps.stderr.on('data', (data) => {\n        try {\n          // 检查主窗口是否还存在且未被销毁\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            const output = data.toString();\n            mainWindow.webContents.send(`process:output:${processId}`, output);\n          }\n        } catch (error) {\n          console.error('Error handling stderr data:', error);\n        }\n      });\n      \n      // 处理进程退出\n      ps.on('exit', (code) => {\n        try {\n          // 检查主窗口是否还存在且未被销毁\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(`process:output:${processId}`, `\\r\\nProcess exited with code ${code || 0}\\r\\n`);\n          }\n          childProcesses.delete(processId);\n        } catch (error) {\n          console.error('Error handling process exit:', error);\n        }\n      });\n      \n      // 处理进程错误\n      ps.on('error', (err) => {\n        try {\n          // 检查主窗口是否还存在且未被销毁\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(\n              `process:output:${processId}`,\n              `\\r\\nProcess error: ${err.message}\\r\\n`\n            );\n          }\n          childProcesses.delete(processId);\n        } catch (error) {\n          console.error('Error handling process error:', error);\n        }\n      });\n      \n      return processId;\n    } catch (error) {\n      console.error('Failed to start PowerShell:', error);\n      throw error;\n    }\n  });\n  \n  // 启动SSH连接\n  ipcMain.handle('terminal:startSSH', async (event, sshConfig) => {\n    const processId = nextProcessId++;\n    \n    if (!sshConfig || !sshConfig.host) {\n      console.error('Invalid SSH configuration');\n      throw new Error('Invalid SSH configuration');\n    }\n    \n    return new Promise((resolve, reject) => {\n      try {\n        // 创建SSH2客户端连接\n        const ssh = new Client();\n        \n        // 存储进程信息 - 这里保存ssh客户端实例\n        childProcesses.set(processId, {\n          process: ssh,\n          listeners: new Set(),\n          config: sshConfig,\n          type: 'ssh2'\n        });\n        \n        // 存储相同的SSH客户端，使用tabId（通常是形如'ssh-timestamp'的标识符）\n        if (sshConfig.tabId) {\n          console.log(`Setting up SSH client for tabId: ${sshConfig.tabId}`);\n          childProcesses.set(sshConfig.tabId, {\n            process: ssh,\n            listeners: new Set(),\n            config: sshConfig,\n            type: 'ssh2'\n          });\n        }\n        \n        // 设置连接超时定时器\n        const connectionTimeout = setTimeout(() => {\n          console.error('SSH connection timed out after 15 seconds');\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(\n              `process:output:${processId}`,\n              `\\r\\n连接超时，请检查网络和服务器状态\\r\\n`\n            );\n          }\n          // 不主动断开连接，让用户决定是否关闭\n        }, 15000);\n        \n        // 监听就绪事件\n        ssh.on('ready', () => {\n          // 清除超时定时器\n          clearTimeout(connectionTimeout);\n          \n          if (mainWindow && !mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(\n              `process:output:${processId}`,\n              `\\r\\n*** ${sshConfig.host} SSH连接已建立 ***\\r\\n`\n            );\n          }\n          \n          // 创建Shell会话\n          ssh.shell({ \n            term: 'xterm-256color',  // 使用更高级的终端类型\n            cols: 120,               // 设置更宽的初始终端列数\n            rows: 30                 // 设置初始终端行数\n          }, (err, stream) => {\n            if (err) {\n              console.error('Failed to create shell:', err);\n              if (mainWindow && !mainWindow.isDestroyed()) {\n                mainWindow.webContents.send(\n                  `process:output:${processId}`,\n                  `\\r\\n*** 创建Shell会话失败: ${err.message} ***\\r\\n`\n                );\n              }\n              ssh.end();\n              return;\n            }\n            \n            // 存储流对象到进程信息中，用于后续写入数据\n            const procInfo = childProcesses.get(processId);\n            if (procInfo) {\n              procInfo.stream = stream;\n            }\n            \n            // 监听数据事件 - 使用Buffer拼接确保UTF-8字符完整\n            let buffer = Buffer.from([]);\n            \n            stream.on('data', (data) => {\n              try {\n                // 拼接数据到缓冲区\n                buffer = Buffer.concat([buffer, data]);\n                \n                // 尝试将缓冲区转换为UTF-8字符串\n                let output;\n                try {\n                  output = buffer.toString('utf8');\n                  // 转换成功，清空缓冲区\n                  buffer = Buffer.from([]);\n                } catch (e) {\n                  // 如果转换失败（可能是UTF-8字符不完整），等待下一个数据包\n                  return;\n                }\n                \n                if (mainWindow && !mainWindow.isDestroyed()) {\n                  mainWindow.webContents.send(`process:output:${processId}`, output);\n                }\n              } catch (error) {\n                console.error('Error handling stream data:', error);\n              }\n            });\n            \n            // 监听扩展数据（通常是错误消息）\n            stream.on('extended data', (data, type) => {\n              try {\n                // type为1时表示stderr数据\n                if (mainWindow && !mainWindow.isDestroyed()) {\n                  mainWindow.webContents.send(\n                    `process:output:${processId}`,\n                    `\\x1b[31m${data.toString('utf8')}\\x1b[0m`\n                  );\n                }\n              } catch (error) {\n                console.error('Error handling extended data:', error);\n              }\n            });\n            \n            // 监听关闭事件\n            stream.on('close', () => {\n              try {\n                console.log('SSH stream closed');\n                if (mainWindow && !mainWindow.isDestroyed()) {\n                  mainWindow.webContents.send(\n                    `process:output:${processId}`,\n                    `\\r\\n*** SSH会话已关闭 ***\\r\\n`\n                  );\n                }\n                ssh.end();\n              } catch (error) {\n                console.error('Error handling stream close:', error);\n              }\n            });\n          });\n        });\n        \n        // 监听错误事件\n        ssh.on('error', (err) => {\n          clearTimeout(connectionTimeout);\n          \n          console.error('SSH connection error:', err);\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(\n              `process:output:${processId}`,\n              `\\r\\n\\x1b[31m*** SSH连接错误: ${err.message} ***\\x1b[0m\\r\\n`\n            );\n          }\n          \n          childProcesses.delete(processId);\n          reject(err);\n        });\n        \n        // 监听关闭事件\n        ssh.on('close', () => {\n          console.log('SSH connection closed');\n          if (mainWindow && !mainWindow.isDestroyed()) {\n            mainWindow.webContents.send(\n              `process:output:${processId}`,\n              `\\r\\n*** SSH连接已关闭 ***\\r\\n`\n            );\n          }\n          \n          childProcesses.delete(processId);\n        });\n        \n        // 监听键盘交互事件（用于处理密码认证）\n        ssh.on('keyboard-interactive', (name, instructions, lang, prompts, finish) => {\n          if (prompts.length > 0 && prompts[0].prompt.toLowerCase().includes('password')) {\n            finish([sshConfig.password || '']);\n          } else {\n            finish([]);\n          }\n        });\n        \n        // 开始连接\n        const connectConfig = {\n          host: sshConfig.host,\n          port: sshConfig.port || 22,\n          username: sshConfig.username,\n          readyTimeout: 10000, // 10秒连接超时\n          keepaliveInterval: 30000, // 30秒发送一次心跳保持连接\n        };\n        \n        // 根据是否有密码和私钥设置不同的认证方式\n        if (sshConfig.privateKeyPath) {\n          try {\n            // 读取私钥文件\n            const privateKey = fs.readFileSync(sshConfig.privateKeyPath, 'utf8');\n            connectConfig.privateKey = privateKey;\n            \n            // 如果私钥有密码保护\n            if (sshConfig.password) {\n              connectConfig.passphrase = sshConfig.password;\n            }\n          } catch (error) {\n            console.error('Error reading private key file:', error);\n            if (mainWindow && !mainWindow.isDestroyed()) {\n              mainWindow.webContents.send(\n                `process:output:${processId}`,\n                `\\r\\n\\x1b[31m*** 读取私钥文件错误: ${error.message} ***\\x1b[0m\\r\\n`\n              );\n            }\n            reject(error);\n            return;\n          }\n        } else if (sshConfig.password) {\n          // 使用密码认证\n          connectConfig.password = sshConfig.password;\n          // 同时启用键盘交互认证，某些服务器可能需要\n          connectConfig.tryKeyboard = true;\n        }\n        \n        // 连接到SSH服务器\n        ssh.connect(connectConfig);\n        \n        // 返回进程ID\n        resolve(processId);\n      } catch (error) {\n        console.error('Failed to start SSH connection:', error);\n        reject(error);\n      }\n    });\n  });\n  \n  // 发送数据到进程\n  ipcMain.handle('terminal:sendToProcess', async (event, processId, data) => {\n    const procInfo = childProcesses.get(processId);\n    if (!procInfo || !procInfo.process) {\n      console.error(`Process ${processId} not found or invalid`);\n      return false;\n    }\n    \n    try {\n      // 确保退格键字符正确转换\n      let processedData = data;\n      // 对特殊情况的处理（如果需要）\n      \n      // 根据进程类型选择不同的写入方式\n      if (procInfo.type === 'ssh2') {\n        // SSH2连接使用保存的流对象写入数据\n        if (procInfo.stream) {\n          procInfo.stream.write(processedData);\n          return true;\n        } else {\n          console.error('SSH2 stream not available');\n          return false;\n        }\n      } else if (typeof procInfo.process.write === 'function') {\n        // node-pty进程直接调用write方法\n        procInfo.process.write(processedData);\n        return true;\n      } else if (procInfo.process.stdin) {\n        // 标准子进程使用stdin\n        procInfo.process.stdin.write(processedData);\n        return true;\n      } else {\n        console.error('Process has no valid write method');\n        return false;\n      }\n    } catch (error) {\n      console.error('Failed to send data to process:', error);\n      return false;\n    }\n  });\n  \n  // 终止进程\n  ipcMain.handle('terminal:killProcess', async (event, processId) => {\n    const procInfo = childProcesses.get(processId);\n    if (!procInfo || !procInfo.process) {\n      return false;\n    }\n    \n    try {\n      if (procInfo.type === 'ssh2') {\n        // SSH2连接使用end方法关闭\n        procInfo.process.end();\n      } else if (typeof procInfo.process.kill === 'function') {\n        // 直接用kill方法（适用于node-pty和child_process）\n        procInfo.process.kill();\n      } else {\n        console.error('Process has no valid kill method');\n      }\n      \n      childProcesses.delete(processId);\n      return true;\n    } catch (error) {\n      console.error('Failed to kill process:', error);\n      return false;\n    }\n  });\n  \n  // 加载连接配置\n  ipcMain.handle('terminal:loadConnections', async () => {\n    return loadConnectionsConfig();\n  });\n  \n  // 保存连接配置\n  ipcMain.handle('terminal:saveConnections', async (event, connections) => {\n    return saveConnectionsConfig(connections);\n  });\n  \n  // 选择密钥文件\n  ipcMain.handle('terminal:selectKeyFile', async () => {\n    return selectKeyFile();\n  });\n  \n  // 获取应用版本号\n  ipcMain.handle('app:getVersion', () => {\n    return app.getVersion();\n  });\n  \n  // 关闭应用\n  ipcMain.handle('app:close', () => {\n    app.quit();\n  });\n  \n  // 检查更新\n  ipcMain.handle('app:checkForUpdate', async () => {\n    try {\n      const https = require('https');\n      \n      // 创建一个Promise来处理HTTPS请求\n      const fetchGitHubRelease = () => {\n        return new Promise((resolve, reject) => {\n          const options = {\n            hostname: 'api.github.com',\n            path: '/repos/funkpopo/simpleshell/releases/latest',\n            method: 'GET',\n            headers: {\n              'User-Agent': 'SimpleShell-App'\n            }\n          };\n          \n          const req = https.request(options, (res) => {\n            if (res.statusCode !== 200) {\n              reject(new Error(`GitHub API返回错误状态码: ${res.statusCode}`));\n              return;\n            }\n            \n            let data = '';\n            res.on('data', (chunk) => {\n              data += chunk;\n            });\n            \n            res.on('end', () => {\n              try {\n                const releaseData = JSON.parse(data);\n                resolve(releaseData);\n              } catch (error) {\n                reject(new Error(`解析GitHub API响应失败: ${error.message}`));\n              }\n            });\n          });\n          \n          req.on('error', (error) => {\n            reject(new Error(`请求GitHub API失败: ${error.message}`));\n          });\n          \n          req.end();\n        });\n      };\n      \n      const releaseData = await fetchGitHubRelease();\n      return {\n        success: true,\n        data: releaseData\n      };\n    } catch (error) {\n      console.error('检查更新失败:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  });\n  \n  // 在外部浏览器中打开URL\n  ipcMain.handle('app:openExternal', async (event, url) => {\n    try {\n      await shell.openExternal(url);\n      return true;\n    } catch (error) {\n      console.error('打开外部链接失败:', error);\n      return false;\n    }\n  });\n  \n  // 处理简单的命令\n  ipcMain.handle('terminal:command', async (event, command) => {\n    try {\n      // 简单内部命令处理\n      if (command === 'date') {\n        return { output: new Date().toString() };\n      } else if (command.startsWith('echo ')) {\n        return { output: command.substring(5) };\n      } else {\n        return { output: `Command not recognized: ${command}` };\n      }\n    } catch (error) {\n      console.error('Command error:', error);\n      return { error: error.message };\n    }\n  });\n  \n  // 添加调整终端大小的处理\n  ipcMain.handle('terminal:resize', async (event, processId, cols, rows) => {\n    const procInfo = childProcesses.get(processId);\n    if (!procInfo) {\n      console.error(`Process ${processId} not found`);\n      return false;\n    }\n    \n    try {\n      // 针对不同类型的进程进行不同的处理\n      if (procInfo.type === 'ssh2' && procInfo.stream) {\n        // SSH2连接使用stream.setWindow方法调整大小\n        if (typeof procInfo.stream.setWindow === 'function') {\n          procInfo.stream.setWindow(rows, cols);\n          return true;\n        }\n      } else if (typeof procInfo.process.resize === 'function') {\n        // node-pty进程使用resize方法\n        procInfo.process.resize(cols, rows);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Failed to resize terminal:', error);\n      return false;\n    }\n  });\n  \n  // 获取系统资源信息\n  ipcMain.handle('terminal:getSystemInfo', async (event, processId) => {\n    try {\n      if (!processId || !childProcesses.has(processId)) {\n        return getLocalSystemInfo();\n      } else {\n        // SSH远程系统信息\n        const processObj = childProcesses.get(processId);\n        \n        // 支持多种SSH客户端类型\n        if ((processObj.type === 'ssh2' || processObj.type === 'ssh') && \n            (processObj.process || processObj.client || processObj.channel)) {\n          const sshClient = processObj.client || processObj.process || processObj.channel;\n          return getRemoteSystemInfo(sshClient);\n        } else {\n          return getLocalSystemInfo();\n        }\n      }\n    } catch (error) {\n      console.error('Failed to get system info:', error);\n      return {\n        error: '获取系统信息失败',\n        message: error.message\n      };\n    }\n  });\n\n  // AI设置相关IPC处理\n  ipcMain.handle('ai:loadSettings', async () => {\n    return loadAISettings();\n  });\n  \n  ipcMain.handle('ai:saveSettings', async (event, settings) => {\n    return saveAISettings(settings);\n  });\n  \n  // 新增: 处理API配置的IPC方法\n  ipcMain.handle('ai:saveApiConfig', async (event, config) => {\n    try {\n      logToFile(`Saving API config: ${JSON.stringify({\n        id: config.id,\n        name: config.name,\n        model: config.model\n      })}`);\n      \n      // 加载当前设置\n      const settings = loadAISettings();\n      \n      // 确保configs存在\n      if (!settings.configs) {\n        settings.configs = [];\n        logToFile('No configs array in loaded settings, initializing empty array', 'WARN');\n      }\n      \n      // 为新配置生成ID (如果没有)\n      if (!config.id) {\n        config.id = Date.now().toString();\n        logToFile(`Generated new ID for config: ${config.id}`);\n      }\n      \n      // 查找是否存在相同ID的配置\n      const existingIndex = settings.configs.findIndex(c => c.id === config.id);\n      logToFile(`Existing config index: ${existingIndex}`);\n      \n      if (existingIndex >= 0) {\n        // 更新现有配置\n        logToFile(`Updating existing config at index ${existingIndex}`);\n        settings.configs[existingIndex] = config;\n      } else {\n        // 添加新配置\n        logToFile(`Adding new config with ID ${config.id}`);\n        settings.configs.push(config);\n      }\n      \n      logToFile(`Total configs after update: ${settings.configs.length}`);\n      \n      // 保存设置\n      const result = await saveAISettings(settings);\n      logToFile(`Save result: ${result}`);\n      return result;\n    } catch (error) {\n      logToFile(`Failed to save API config: ${error.message}`, 'ERROR');\n      console.error('Failed to save API config:', error);\n      return false;\n    }\n  });\n  \n  ipcMain.handle('ai:deleteApiConfig', async (event, configId) => {\n    try {\n      // 加载当前设置\n      const settings = loadAISettings();\n      \n      // 确保configs存在\n      if (!settings.configs) {\n        settings.configs = [];\n        return saveAISettings(settings);\n      }\n      \n      // 查找配置并删除\n      const originalLength = settings.configs.length;\n      settings.configs = settings.configs.filter(c => c.id !== configId);\n      \n      // 如果当前选中的配置被删除，重置current\n      if (settings.current && settings.current.id === configId) {\n        if (settings.configs.length > 0) {\n          // 如果还有其他配置，选择第一个\n          settings.current = { ...settings.configs[0] };\n        } else {\n          // 如果没有配置了，重置为空配置\n          settings.current = {\n            apiUrl: '',\n            apiKey: '',\n            model: '',\n            streamEnabled: true\n          };\n        }\n      }\n      \n      // 如果确实删除了配置，保存设置\n      if (settings.configs.length !== originalLength) {\n        return saveAISettings(settings);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to delete API config:', error);\n      return false;\n    }\n  });\n  \n  ipcMain.handle('ai:setCurrentApiConfig', async (event, configId) => {\n    try {\n      logToFile(`Setting current API config with ID: ${configId}`);\n      \n      // 加载当前设置\n      const settings = loadAISettings();\n      \n      // 确保configs存在\n      if (!settings.configs) {\n        settings.configs = [];\n        logToFile('No configs array in loaded settings, initializing empty array', 'WARN');\n      }\n      \n      logToFile(`Found ${settings.configs.length} configs in settings`);\n      \n      // 查找指定ID的配置\n      const selectedConfig = settings.configs.find(c => c.id === configId);\n      \n      if (selectedConfig) {\n        logToFile(`Found config with ID ${configId}, updating current config`);\n        // 更新当前配置\n        settings.current = { ...selectedConfig };\n        \n        // 保存设置\n        const saveResult = saveAISettings(settings);\n        logToFile(`Save result: ${saveResult}`);\n        return saveResult;\n      } else {\n        logToFile(`No config found with ID ${configId}`, 'ERROR');\n        return false;\n      }\n    } catch (error) {\n      logToFile(`Failed to set current API config: ${error.message}`, 'ERROR');\n      console.error('Failed to set current API config:', error);\n      return false;\n    }\n  });\n  \n  ipcMain.handle('ai:sendPrompt', async (event, prompt, settings) => {\n    try {\n      return await sendAIPrompt(prompt, settings);\n    } catch (error) {\n      console.error('Error sending AI prompt:', error);\n      return { error: error.message || '发送请求时出错' };\n    }\n  });\n\n  // 直接处理API请求，绕过CORS限制\n  ipcMain.handle('ai:sendAPIRequest', async (event, requestData, isStream) => {\n    try {\n      // 验证请求数据\n      if (!requestData.url || !requestData.apiKey || !requestData.model || !requestData.messages) {\n        throw new Error('请求数据无效，缺少必要参数');\n      }\n\n      console.log(`发送${isStream ? '流式' : '标准'}API请求到: ${requestData.url}`);\n\n      if (isStream) {\n        // 处理流式请求\n        const https = require('https');\n        const http = require('http');\n        const url = new URL(requestData.url);\n        \n        const requestModule = url.protocol === 'https:' ? https : http;\n        \n        const options = {\n          method: 'POST',\n          hostname: url.hostname,\n          path: url.pathname + url.search,\n          port: url.port || (url.protocol === 'https:' ? 443 : 80),\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${requestData.apiKey}`\n          }\n        };\n        \n        const req = requestModule.request(options, (res) => {\n          if (res.statusCode !== 200) {\n            event.sender.send('stream-error', `API请求失败: ${res.statusCode} ${res.statusMessage}`);\n            return;\n          }\n          \n          res.on('data', (chunk) => {\n            try {\n              const data = chunk.toString('utf-8');\n              const lines = data.split('\\n');\n              \n              for (const line of lines) {\n                if (line.startsWith('data: ') && line !== 'data: [DONE]') {\n                  try {\n                    const jsonData = JSON.parse(line.substring(6));\n                    if (jsonData.choices && jsonData.choices[0] && jsonData.choices[0].delta && jsonData.choices[0].delta.content) {\n                      event.sender.send('stream-chunk', jsonData.choices[0].delta.content);\n                    }\n                  } catch (e) {\n                    // 这可能只是部分数据，不是完整的JSON\n                    console.log('非JSON数据片段:', line);\n                  }\n                }\n              }\n            } catch (error) {\n              console.error('处理流数据时出错:', error);\n            }\n          });\n          \n          res.on('end', () => {\n            event.sender.send('stream-end', '');\n          });\n        });\n        \n        req.on('error', (error) => {\n          console.error('请求出错:', error);\n          event.sender.send('stream-error', error.message);\n        });\n        \n        // 发送请求数据\n        req.write(JSON.stringify({\n          model: requestData.model,\n          messages: requestData.messages,\n          stream: true\n        }));\n        \n        req.end();\n        \n        return { success: true, message: '流式请求已开始' };\n      } else {\n        // 处理标准请求\n        return new Promise((resolve, reject) => {\n          try {\n            const https = require('https');\n            const http = require('http');\n            const url = new URL(requestData.url);\n            \n            const requestModule = url.protocol === 'https:' ? https : http;\n            \n            const options = {\n              method: 'POST',\n              hostname: url.hostname,\n              path: url.pathname + url.search,\n              port: url.port || (url.protocol === 'https:' ? 443 : 80),\n              headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${requestData.apiKey}`\n              }\n            };\n            \n            const req = requestModule.request(options, (res) => {\n              let responseData = '';\n              \n              // 处理状态码非200的情况\n              if (res.statusCode !== 200) {\n                resolve({ \n                  success: false, \n                  error: `API请求失败: ${res.statusCode} ${res.statusMessage}`\n                });\n                return;\n              }\n              \n              res.on('data', (chunk) => {\n                responseData += chunk.toString('utf-8');\n              });\n              \n              res.on('end', () => {\n                try {\n                  // 解析JSON响应\n                  const data = JSON.parse(responseData);\n                  if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {\n                    resolve({ \n                      success: true, \n                      content: data.choices[0].message.content \n                    });\n                  } else {\n                    resolve({\n                      success: false,\n                      error: '无法解析API响应',\n                      rawResponse: responseData\n                    });\n                  }\n                } catch (error) {\n                  console.error('解析API响应时出错:', error);\n                  resolve({ \n                    success: false, \n                    error: `解析响应失败: ${error.message}`,\n                    rawResponse: responseData.substring(0, 200) + '...'\n                  });\n                }\n              });\n            });\n            \n            req.on('error', (error) => {\n              console.error('请求出错:', error);\n              resolve({ \n                success: false, \n                error: `请求失败: ${error.message}` \n              });\n            });\n            \n            // 发送请求数据\n            req.write(JSON.stringify({\n              model: requestData.model,\n              messages: requestData.messages,\n              stream: false\n            }));\n            \n            req.end();\n          } catch (error) {\n            console.error('创建请求时出错:', error);\n            resolve({ \n              success: false, \n              error: `创建请求失败: ${error.message}` \n            });\n          }\n        });\n      }\n    } catch (error) {\n      console.error('发送API请求时出错:', error);\n      return { \n        success: false, \n        error: error.message \n      };\n    }\n  });\n\n  // 文件管理相关API\n  ipcMain.handle('listFiles', async (event, tabId, path) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      \n      return new Promise((resolve, reject) => {\n        sshClient.sftp((err, sftp) => {\n          if (err) {\n            logToFile(`SFTP error for session ${tabId}: ${err.message}`, 'ERROR');\n            return resolve({ success: false, error: `SFTP错误: ${err.message}` });\n          }\n          \n          sftp.readdir(path || '.', (err, list) => {\n            if (err) {\n              logToFile(`Failed to list directory for session ${tabId}: ${err.message}`, 'ERROR');\n              return resolve({ success: false, error: `无法列出目录: ${err.message}` });\n            }\n            \n            const files = list.map(item => ({\n              name: item.filename,\n              size: item.attrs.size,\n              isDirectory: item.attrs.isDirectory(),\n              modifyTime: new Date(item.attrs.mtime * 1000).toISOString(),\n              permissions: item.attrs.mode\n            }));\n            \n            resolve({ success: true, data: files });\n          });\n        });\n      });\n    } catch (error) {\n      logToFile(`List files error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `列出文件失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('copyFile', async (event, tabId, sourcePath, targetPath) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      \n      return new Promise((resolve, reject) => {\n        sshClient.sftp((err, sftp) => {\n          if (err) {\n            logToFile(`SFTP error for session ${tabId}: ${err.message}`, 'ERROR');\n            return resolve({ success: false, error: `SFTP错误: ${err.message}` });\n          }\n          \n          // 在远程服务器上执行复制命令\n          sshClient.exec(`cp -r \"${sourcePath}\" \"${targetPath}\"`, (err, stream) => {\n            if (err) {\n              logToFile(`Failed to copy file for session ${tabId}: ${err.message}`, 'ERROR');\n              return resolve({ success: false, error: `复制文件失败: ${err.message}` });\n            }\n            \n            let errorOutput = '';\n            \n            stream.on('data', (data) => {\n              // 通常cp命令执行成功不会有输出\n            });\n            \n            stream.stderr.on('data', (data) => {\n              errorOutput += data.toString();\n            });\n            \n            stream.on('close', (code) => {\n              if (code === 0) {\n                resolve({ success: true });\n              } else {\n                logToFile(`File copy failed with code ${code} for session ${tabId}: ${errorOutput}`, 'ERROR');\n                resolve({ success: false, error: errorOutput || `复制文件失败，错误代码: ${code}` });\n              }\n            });\n          });\n        });\n      });\n    } catch (error) {\n      logToFile(`Copy file error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `复制文件失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('moveFile', async (event, tabId, sourcePath, targetPath) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      \n      return new Promise((resolve, reject) => {\n        sshClient.sftp((err, sftp) => {\n          if (err) {\n            logToFile(`SFTP error for session ${tabId}: ${err.message}`, 'ERROR');\n            return resolve({ success: false, error: `SFTP错误: ${err.message}` });\n          }\n          \n          // 在远程服务器上执行移动命令\n          sshClient.exec(`mv \"${sourcePath}\" \"${targetPath}\"`, (err, stream) => {\n            if (err) {\n              logToFile(`Failed to move file for session ${tabId}: ${err.message}`, 'ERROR');\n              return resolve({ success: false, error: `移动文件失败: ${err.message}` });\n            }\n            \n            let errorOutput = '';\n            \n            stream.on('data', (data) => {\n              // 通常mv命令执行成功不会有输出\n            });\n            \n            stream.stderr.on('data', (data) => {\n              errorOutput += data.toString();\n            });\n            \n            stream.on('close', (code) => {\n              if (code === 0) {\n                resolve({ success: true });\n              } else {\n                logToFile(`File move failed with code ${code} for session ${tabId}: ${errorOutput}`, 'ERROR');\n                resolve({ success: false, error: errorOutput || `移动文件失败，错误代码: ${code}` });\n              }\n            });\n          });\n        });\n      });\n    } catch (error) {\n      logToFile(`Move file error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `移动文件失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('deleteFile', async (event, tabId, filePath, isDirectory) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      \n      return new Promise((resolve, reject) => {\n        sshClient.sftp((err, sftp) => {\n          if (err) {\n            logToFile(`SFTP error for session ${tabId}: ${err.message}`, 'ERROR');\n            return resolve({ success: false, error: `SFTP错误: ${err.message}` });\n          }\n          \n          // 根据是否为目录选择不同的删除命令\n          const command = isDirectory ? `rm -rf \"${filePath}\"` : `rm \"${filePath}\"`;\n          \n          sshClient.exec(command, (err, stream) => {\n            if (err) {\n              logToFile(`Failed to delete file for session ${tabId}: ${err.message}`, 'ERROR');\n              return resolve({ success: false, error: `删除文件失败: ${err.message}` });\n            }\n            \n            let errorOutput = '';\n            \n            stream.on('data', (data) => {\n              // 通常rm命令执行成功不会有输出\n            });\n            \n            stream.stderr.on('data', (data) => {\n              errorOutput += data.toString();\n            });\n            \n            stream.on('close', (code) => {\n              if (code === 0) {\n                resolve({ success: true });\n              } else {\n                logToFile(`File deletion failed with code ${code} for session ${tabId}: ${errorOutput}`, 'ERROR');\n                resolve({ success: false, error: errorOutput || `删除文件失败，错误代码: ${code}` });\n              }\n            });\n          });\n        });\n      });\n    } catch (error) {\n      logToFile(`Delete file error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `删除文件失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('downloadFile', async (event, tabId, remotePath) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      const sshConfig = processInfo.config; // 获取SSH配置\n      \n      // 获取文件名\n      const fileName = path.basename(remotePath);\n      \n      // 打开保存对话框\n      const { canceled, filePath } = await dialog.showSaveDialog(mainWindow, {\n        title: '保存文件',\n        defaultPath: path.join(app.getPath('downloads'), fileName),\n        buttonLabel: '下载'\n      });\n      \n      if (canceled || !filePath) {\n        return { success: false, error: '用户取消下载' };\n      }\n      \n      // 创建SFTP客户端\n      const sftp = new SftpClient();\n      \n      // 创建传输对象并存储到活动传输中\n      const transferKey = `${tabId}-download`;\n      \n      return new Promise(async (resolve, reject) => {\n        try {\n          // 存储resolve和reject函数，以便在取消时调用\n          activeTransfers.set(transferKey, { \n            sftp,\n            tempFilePath: filePath + '.part',\n            resolve,\n            reject\n          });\n          \n          // 使用SSH2客户端的连接配置\n          await sftp.connect({\n            host: sshConfig.host,\n            port: sshConfig.port || 22,\n            username: sshConfig.username,\n            password: sshConfig.password,\n            privateKey: sshConfig.privateKeyPath ? fs.readFileSync(sshConfig.privateKeyPath, 'utf8') : undefined,\n            passphrase: sshConfig.privateKeyPath && sshConfig.password ? sshConfig.password : undefined\n          });\n          \n          // 获取文件状态以获取文件大小\n          const stats = await sftp.stat(remotePath);\n          const totalBytes = stats.size;\n          \n          // 设置进度监控\n          let transferredBytes = 0;\n          let lastProgressUpdate = 0;\n          let lastTransferredBytes = 0;\n          let lastUpdateTime = Date.now();\n          let transferSpeed = 0;\n          const progressReportInterval = 100;\n          \n          // 定义进度回调函数\n          const progressCallback = (transferred) => {\n            transferredBytes = transferred;\n            \n            // 计算进度百分比\n            const progress = Math.floor((transferredBytes / totalBytes) * 100);\n            \n            // 限制进度更新频率，避免频繁通知导致UI卡顿\n            const now = Date.now();\n            if (now - lastProgressUpdate >= progressReportInterval) {\n              // 计算传输速度 (字节/秒)\n              const elapsedSinceLastUpdate = (now - lastUpdateTime) / 1000; // 时间间隔(秒)\n              \n              if (elapsedSinceLastUpdate > 0) {\n                const bytesTransferredSinceLastUpdate = transferredBytes - lastTransferredBytes;\n                if (bytesTransferredSinceLastUpdate > 0) {\n                  transferSpeed = bytesTransferredSinceLastUpdate / elapsedSinceLastUpdate;\n                }\n              }\n              \n              // 存储当前值供下次计算\n              lastTransferredBytes = transferredBytes;\n              lastUpdateTime = now;\n              \n              // 发送进度更新到渲染进程\n              event.sender.send('download-progress', {\n                tabId,\n                progress,\n                fileName,\n                transferredBytes,\n                totalBytes,\n                transferSpeed,\n                remainingTime: transferSpeed > 0 ? (totalBytes - transferredBytes) / transferSpeed : 0\n              });\n              \n              lastProgressUpdate = now;\n            }\n          };\n          \n          // 使用临时文件下载\n          const tempFilePath = filePath + '.part';\n          \n          // 使用fastGet下载文件，并监控进度\n          await sftp.fastGet(remotePath, tempFilePath, {\n            step: (transferred, chunk, total) => {\n              progressCallback(transferred);\n            }\n          });\n          \n          // 重命名临时文件为最终文件\n          fs.renameSync(tempFilePath, filePath);\n          \n          // 确保发送100%进度\n          event.sender.send('download-progress', {\n            tabId,\n            progress: 100,\n            fileName,\n            transferredBytes: totalBytes,\n            totalBytes,\n            transferSpeed,\n            remainingTime: 0\n          });\n          \n          // 成功下载\n          await sftp.end();\n          \n          // 从活动传输列表中移除\n          activeTransfers.delete(transferKey);\n          \n          resolve({ success: true, filePath });\n          \n          // 在资源管理器中显示文件（可选）\n          shell.showItemInFolder(filePath);\n        } catch (error) {\n          logToFile(`Download file error for session ${tabId}: ${error.message}`, 'ERROR');\n          await sftp.end().catch(() => {}); // 忽略关闭连接可能的错误\n          \n          // 从活动传输列表中移除\n          activeTransfers.delete(transferKey);\n          \n          // 如果是用户取消导致的错误，提供友好的消息\n          if (error.message.includes('aborted') || error.message.includes('cancel')) {\n            resolve({ success: false, cancelled: true, error: '下载已取消' });\n          } else {\n            resolve({ success: false, error: `下载文件失败: ${error.message}` });\n          }\n          \n          // 清理临时文件\n          try {\n            if (fs.existsSync(tempFilePath)) {\n              fs.unlinkSync(tempFilePath);\n            }\n          } catch (e) {\n            logToFile(`Failed to delete temp file: ${e.message}`, 'ERROR');\n          }\n        }\n      });\n    } catch (error) {\n      logToFile(`Download file error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `下载文件失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('uploadFile', async (event, tabId, targetFolder) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      const sshConfig = processInfo.config; // 获取SSH配置\n      \n      // 打开文件选择对话框\n      const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {\n        title: '选择要上传的文件',\n        properties: ['openFile'],\n        buttonLabel: '上传'\n      });\n      \n      if (canceled || filePaths.length === 0) {\n        return { success: false, error: '用户取消上传' };\n      }\n      \n      const localFilePath = filePaths[0];\n      const fileName = path.basename(localFilePath);\n      \n      // 获取本地文件大小\n      const stats = fs.statSync(localFilePath);\n      const totalBytes = stats.size;\n      \n      // 确保路径格式正确（使用posix风格的路径）\n      // 处理空路径和特殊路径\n      let normalizedTargetFolder = targetFolder;\n      if (targetFolder === '~') {\n        normalizedTargetFolder = '.'; // 在SFTP中~不会自动扩展为主目录\n      }\n      // 确保路径格式正确\n      const remoteFilePath = normalizedTargetFolder ? \n        path.posix.join(normalizedTargetFolder, fileName).replace(/\\\\/g, '/') : \n        fileName;\n      \n      logToFile(`Uploading file \"${localFilePath}\" to \"${remoteFilePath}\" for session ${tabId}`, 'INFO');\n      \n      // 创建SFTP客户端\n      const sftp = new SftpClient();\n      \n      // 创建传输对象并存储到活动传输中\n      const transferKey = `${tabId}-upload`;\n      \n      return new Promise(async (resolve, reject) => {\n        try {\n          // 存储resolve和reject函数，以便在取消时调用\n          activeTransfers.set(transferKey, { \n            sftp,\n            resolve,\n            reject\n          });\n          \n          // 使用SSH2客户端的连接配置\n          await sftp.connect({\n            host: sshConfig.host,\n            port: sshConfig.port || 22,\n            username: sshConfig.username,\n            password: sshConfig.password,\n            privateKey: sshConfig.privateKeyPath ? fs.readFileSync(sshConfig.privateKeyPath, 'utf8') : undefined,\n            passphrase: sshConfig.privateKeyPath && sshConfig.password ? sshConfig.password : undefined\n          });\n          \n          // 先检查目标文件夹是否存在\n          try {\n            const folderStat = await sftp.stat(normalizedTargetFolder);\n            if (!folderStat.isDirectory) {\n              await sftp.end();\n              activeTransfers.delete(transferKey);\n              return resolve({ success: false, error: `目标${normalizedTargetFolder}不是文件夹` });\n            }\n          } catch (statErr) {\n            logToFile(`Target folder check failed for session ${tabId}: ${statErr.message}`, 'ERROR');\n            await sftp.end();\n            activeTransfers.delete(transferKey);\n            return resolve({ success: false, error: `目标文件夹不可访问: ${statErr.message}` });\n          }\n          \n          // 设置进度监控\n          let lastProgressUpdate = 0;\n          let lastTransferredBytes = 0;\n          let lastUpdateTime = Date.now();\n          let transferSpeed = 0;\n          const progressReportInterval = 100; // 每隔100ms报告进度\n          \n          // 使用fastPut上传文件，并监控进度\n          await sftp.fastPut(localFilePath, remoteFilePath, {\n            step: (transferred, chunk, total) => {\n              // 计算进度百分比\n              const progress = Math.floor((transferred / totalBytes) * 100);\n              \n              // 限制进度更新频率，避免频繁通知导致UI卡顿\n              const now = Date.now();\n              if (now - lastProgressUpdate >= progressReportInterval) {\n                // 计算传输速度 (字节/秒)\n                const elapsedSinceLastUpdate = (now - lastUpdateTime) / 1000; // 时间间隔(秒)\n                \n                if (elapsedSinceLastUpdate > 0) {\n                  const bytesTransferredSinceLastUpdate = transferred - lastTransferredBytes;\n                  if (bytesTransferredSinceLastUpdate > 0) {\n                    transferSpeed = bytesTransferredSinceLastUpdate / elapsedSinceLastUpdate;\n                  }\n                }\n                \n                // 存储当前值供下次计算\n                lastTransferredBytes = transferred;\n                lastUpdateTime = now;\n                \n                // 发送进度更新到渲染进程\n                event.sender.send('upload-progress', {\n                  tabId,\n                  progress,\n                  fileName,\n                  transferredBytes: transferred,\n                  totalBytes,\n                  transferSpeed,\n                  remainingTime: transferSpeed > 0 ? (totalBytes - transferred) / transferSpeed : 0\n                });\n                \n                lastProgressUpdate = now;\n              }\n            }\n          });\n          \n          // 确保发送100%进度\n          event.sender.send('upload-progress', {\n            tabId,\n            progress: 100,\n            fileName,\n            transferredBytes: totalBytes,\n            totalBytes,\n            transferSpeed,\n            remainingTime: 0\n          });\n          \n          // 成功上传\n          await sftp.end();\n          \n          // 从活动传输列表中移除\n          activeTransfers.delete(transferKey);\n          \n          logToFile(`Successfully uploaded file \"${localFilePath}\" to \"${remoteFilePath}\" for session ${tabId}`, 'INFO');\n          resolve({ success: true, fileName });\n          \n        } catch (error) {\n          logToFile(`Upload file error for session ${tabId}: ${error.message}`, 'ERROR');\n          await sftp.end().catch(() => {}); // 忽略关闭连接可能的错误\n          \n          // 从活动传输列表中移除\n          activeTransfers.delete(transferKey);\n          \n          // 如果是用户取消导致的错误，提供友好的消息\n          if (error.message.includes('aborted') || error.message.includes('cancel')) {\n            resolve({ success: false, cancelled: true, error: '上传已取消' });\n          } else {\n            resolve({ success: false, error: `上传文件失败: ${error.message}` });\n          }\n        }\n      });\n    } catch (error) {\n      logToFile(`Upload file error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `上传文件失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('renameFile', async (event, tabId, oldPath, newName) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      \n      // 获取目录路径和新的完整路径\n      const dirPath = path.dirname(oldPath);\n      const newPath = path.join(dirPath, newName).replace(/\\\\/g, '/'); // 确保使用Unix风格的路径分隔符\n      \n      return new Promise((resolve, reject) => {\n        sshClient.sftp((err, sftp) => {\n          if (err) {\n            logToFile(`SFTP error for session ${tabId}: ${err.message}`, 'ERROR');\n            return resolve({ success: false, error: `SFTP错误: ${err.message}` });\n          }\n          \n          // 使用SFTP重命名文件/文件夹\n          sftp.rename(oldPath, newPath, (err) => {\n            if (err) {\n              logToFile(`Failed to rename file for session ${tabId}: ${err.message}`, 'ERROR');\n              return resolve({ success: false, error: `重命名失败: ${err.message}` });\n            }\n            \n            // 成功重命名\n            resolve({ success: true });\n          });\n        });\n      });\n    } catch (error) {\n      logToFile(`Rename file error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `重命名失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('getAbsolutePath', async (event, tabId, relativePath) => {\n    try {\n      // 查找对应的SSH客户端\n      const processInfo = childProcesses.get(tabId);\n      if (!processInfo || !processInfo.process || processInfo.type !== 'ssh2') {\n        return { success: false, error: '无效的SSH连接' };\n      }\n      \n      const sshClient = processInfo.process;\n      \n      return new Promise((resolve, reject) => {\n        // 使用pwd命令获取当前工作目录\n        sshClient.exec(`cd \"${path.dirname(relativePath) || '.'}\" && pwd && cd - > /dev/null`, (err, stream) => {\n          if (err) {\n            logToFile(`Failed to get absolute path for session ${tabId}: ${err.message}`, 'ERROR');\n            return resolve({ success: false, error: `获取绝对路径失败: ${err.message}` });\n          }\n          \n          let output = '';\n          let errorOutput = '';\n          \n          stream.on('data', (data) => {\n            output += data.toString();\n          });\n          \n          stream.stderr.on('data', (data) => {\n            errorOutput += data.toString();\n          });\n          \n          stream.on('close', (code) => {\n            if (code === 0) {\n              // 获取成功，合成绝对路径\n              const basePath = output.trim().split('\\n')[0];\n              const fileName = path.basename(relativePath);\n              const absolutePath = path.posix.join(basePath, fileName);\n              \n              // 返回绝对路径给渲染进程处理\n              resolve({ success: true, path: absolutePath });\n            } else {\n              logToFile(`Get absolute path failed with code ${code} for session ${tabId}: ${errorOutput}`, 'ERROR');\n              resolve({ success: false, error: errorOutput || `获取绝对路径失败，错误代码: ${code}` });\n            }\n          });\n        });\n      });\n    } catch (error) {\n      logToFile(`Get absolute path error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `获取绝对路径失败: ${error.message}` };\n    }\n  });\n  \n  ipcMain.handle('cancelTransfer', async (event, tabId, type) => {\n    try {\n      const transferKey = `${tabId}-${type}`;\n      const transfer = activeTransfers.get(transferKey);\n      \n      if (!transfer) {\n        console.log(`No active transfer found for ${transferKey}`);\n        return { success: false, error: '没有找到活动的传输任务' };\n      }\n      \n      console.log(`Cancelling transfer for ${transferKey}`);\n      \n      // 中断传输\n      if (transfer.sftp) {\n        try {\n          // 如果有resolve方法（表示有未完成的IPC请求），尝试调用它\n          if (transfer.resolve) {\n            try {\n              console.log(`Resolving pending ${type} request for ${tabId}`);\n              transfer.resolve({ success: false, cancelled: true, error: '用户取消了传输' });\n            } catch (resolveError) {\n              console.error(`Error resolving pending request: ${resolveError.message}`);\n            }\n          }\n          \n          // 尝试中断操作并关闭连接\n          await transfer.sftp.end();\n          logToFile(`Transfer cancelled for session ${tabId}`, 'INFO');\n          \n          // 如果有临时文件需要删除\n          if (transfer.tempFilePath && fs.existsSync(transfer.tempFilePath)) {\n            fs.unlinkSync(transfer.tempFilePath);\n          }\n          \n          // 从活动传输中移除\n          activeTransfers.delete(transferKey);\n          \n          return { success: true };\n        } catch (error) {\n          logToFile(`Error cancelling transfer for session ${tabId}: ${error.message}`, 'ERROR');\n          return { success: false, error: `取消传输失败: ${error.message}` };\n        }\n      } else {\n        return { success: false, error: '传输任务无法取消' };\n      }\n    } catch (error) {\n      logToFile(`Cancel transfer error for session ${tabId}: ${error.message}`, 'ERROR');\n      return { success: false, error: `取消传输失败: ${error.message}` };\n    }\n  });\n}\n\n// 获取本地系统信息\nfunction getLocalSystemInfo() {\n  const osInfo = {\n    type: os.type(),\n    platform: os.platform(),\n    release: os.release(),\n    hostname: os.hostname(),\n    distro: '未知',\n    version: '未知'\n  };\n\n  // 根据平台添加额外信息\n  if (osInfo.platform === 'win32') {\n    // Windows平台\n    const windowsVersions = {\n      '10.0': 'Windows 10/11',\n      '6.3': 'Windows 8.1',\n      '6.2': 'Windows 8',\n      '6.1': 'Windows 7',\n      '6.0': 'Windows Vista',\n      '5.2': 'Windows XP 64-Bit Edition/Windows Server 2003',\n      '5.1': 'Windows XP',\n      '5.0': 'Windows 2000'\n    };\n\n    // 尝试获取Windows版本\n    const releaseVersion = osInfo.release.split('.');\n    if (releaseVersion.length >= 2) {\n      const majorMinor = `${releaseVersion[0]}.${releaseVersion[1]}`;\n      osInfo.distro = windowsVersions[majorMinor] || 'Windows';\n    } else {\n      osInfo.distro = 'Windows';\n    }\n    \n    // 获取更具体的Windows版本信息\n    try {\n      if (osInfo.release.startsWith('10.0')) {\n        // 获取Windows 10/11的具体版本号(如20H2, 21H1等)\n        const buildNumber = parseInt(osInfo.release.split('.')[2], 10);\n        \n        // 根据构建号识别主要Windows版本\n        if (buildNumber >= 22000) {\n          osInfo.distro = 'Windows 11';\n          if (buildNumber >= 22621) {\n            osInfo.version = '23H2';\n          } else if (buildNumber >= 22000) {\n            osInfo.version = '21H2';\n          }\n        } else {\n          osInfo.distro = 'Windows 10';\n          if (buildNumber >= 19045) {\n            osInfo.version = '22H2';\n          } else if (buildNumber >= 19044) {\n            osInfo.version = '21H2';\n          } else if (buildNumber >= 19043) {\n            osInfo.version = '21H1';\n          } else if (buildNumber >= 19042) {\n            osInfo.version = '20H2';\n          } else if (buildNumber >= 19041) {\n            osInfo.version = '2004';\n          } else if (buildNumber >= 18363) {\n            osInfo.version = '1909';\n          } else if (buildNumber >= 18362) {\n            osInfo.version = '1903';\n          }\n        }\n      }\n    } catch (e) {\n      console.error('Error determining Windows version:', e);\n    }\n    \n    // 添加架构信息\n    try {\n      const arch = os.arch();\n      osInfo.release = `${osInfo.distro} ${osInfo.release} (${arch})`;\n    } catch (e) {\n      console.error('Error getting architecture info:', e);\n    }\n  } else if (osInfo.platform === 'darwin') {\n    // macOS平台\n    const macVersions = {\n      '22': 'Ventura',\n      '21': 'Monterey',\n      '20': 'Big Sur',\n      '19': 'Catalina',\n      '18': 'Mojave',\n      '17': 'High Sierra',\n      '16': 'Sierra',\n      '15': 'El Capitan',\n      '14': 'Yosemite',\n      '13': 'Mavericks',\n      '12': 'Mountain Lion',\n      '11': 'Lion',\n      '10': 'Snow Leopard'\n    };\n\n    // 尝试获取macOS版本\n    osInfo.distro = 'macOS';\n    const darwinVersion = osInfo.release.split('.')[0];\n    if (macVersions[darwinVersion]) {\n      osInfo.version = macVersions[darwinVersion];\n      osInfo.release = `macOS ${osInfo.version} (${osInfo.release})`;\n    } else {\n      // 尝试通过Darwin版本推断macOS版本\n      if (parseInt(darwinVersion, 10) >= 23) {\n        osInfo.version = 'Sonoma+';\n      }\n      osInfo.release = `macOS ${osInfo.version || osInfo.release}`;\n    }\n  } else if (osInfo.platform === 'linux') {\n    // Linux平台，但Electron环境中能获取的信息有限\n    osInfo.distro = 'Linux';\n    // 在Electron中我们无法轻松运行命令获取发行版信息\n    // 所以这里只提供基本信息\n    osInfo.release = `Linux ${osInfo.release}`;\n  }\n\n  return {\n    isLocal: true,\n    os: osInfo,\n    cpu: {\n      model: os.cpus()[0].model,\n      cores: os.cpus().length,\n      speed: os.cpus()[0].speed,\n      usage: getCpuUsage()\n    },\n    memory: {\n      total: os.totalmem(),\n      free: os.freemem(),\n      used: os.totalmem() - os.freemem(),\n      usagePercent: Math.round(((os.totalmem() - os.freemem()) / os.totalmem()) * 100)\n    }\n  };\n}\n\n// 计算CPU使用率\nfunction getCpuUsage() {\n  const cpus = os.cpus();\n  let totalIdle = 0;\n  let totalTick = 0;\n  \n  for (const cpu of cpus) {\n    for (const type in cpu.times) {\n      totalTick += cpu.times[type];\n    }\n    totalIdle += cpu.times.idle;\n  }\n  \n  const usage = 100 - Math.round((totalIdle / totalTick) * 100);\n  return usage;\n}\n\n// 获取远程系统信息\nasync function getRemoteSystemInfo(sshClient) {\n  return new Promise((resolve, reject) => {\n    const result = {\n      isLocal: false,\n      os: { type: '未知', platform: '未知', release: '未知', hostname: '未知', distro: '未知', version: '未知' },\n      cpu: { model: '未知', cores: 0, usage: 0 },\n      memory: { total: 0, free: 0, used: 0, usagePercent: 0 }\n    };\n    \n    // 获取基本操作系统信息\n    sshClient.exec('uname -a', (err, stream) => {\n      if (err) {\n        console.error('SSH exec error (uname):', err);\n        resolve(result);\n        return;\n      }\n      \n      let output = '';\n      stream.on('data', (data) => {\n        output += data.toString();\n      });\n      \n      stream.on('close', () => {\n        // 解析基本操作系统信息\n        const osInfo = output.trim();\n        \n        // 检测操作系统类型\n        if (osInfo.includes('Linux')) {\n          result.os.type = 'Linux';\n          result.os.platform = 'linux';\n          \n          // 获取详细的Linux发行版信息\n          getLinuxDistro();\n        } else if (osInfo.includes('Darwin')) {\n          result.os.type = 'macOS';\n          result.os.platform = 'darwin';\n          \n          // 获取macOS版本\n          getMacOSVersion();\n        } else if (osInfo.includes('FreeBSD')) {\n          result.os.type = 'FreeBSD';\n          result.os.platform = 'freebsd';\n          getHostname();\n        } else if (osInfo.includes('Windows')) {\n          result.os.type = 'Windows';\n          result.os.platform = 'win32';\n          getWindowsVersion();\n        } else {\n          // 未识别的系统，直接保存uname信息\n          result.os.release = osInfo;\n          getHostname();\n        }\n        \n        // 获取Linux发行版信息\n        function getLinuxDistro() {\n          // 尝试多种方法获取Linux发行版信息\n          const distroCommands = [\n            'cat /etc/os-release | grep -E \"^(NAME|VERSION)=\"',\n            'lsb_release -a 2>/dev/null',\n            'cat /etc/redhat-release 2>/dev/null',\n            'cat /etc/debian_version 2>/dev/null'\n          ];\n          \n          let commandIndex = 0;\n          tryNextCommand();\n          \n          function tryNextCommand() {\n            if (commandIndex >= distroCommands.length) {\n              // 所有命令都尝试过了，保存现有信息然后继续\n              result.os.release = osInfo;\n              getHostname();\n              return;\n            }\n            \n            const command = distroCommands[commandIndex++];\n            sshClient.exec(command, (err, stream) => {\n              if (err) {\n                console.error(`SSH exec error (distro command ${commandIndex}):`, err);\n                tryNextCommand();\n                return;\n              }\n              \n              let distroOutput = '';\n              stream.on('data', (data) => {\n                distroOutput += data.toString();\n              });\n              \n              stream.on('close', () => {\n                const output = distroOutput.trim();\n                if (output) {                  \n                  // 解析不同格式的输出\n                  if (command.includes('/etc/os-release')) {\n                    // 解析os-release格式\n                    const nameMatch = output.match(/NAME=\"([^\"]+)\"/);\n                    const versionMatch = output.match(/VERSION=\"([^\"]+)\"/);\n                    \n                    if (nameMatch) {\n                      result.os.distro = nameMatch[1];\n                    }\n                    if (versionMatch) {\n                      result.os.version = versionMatch[1];\n                    }\n                    \n                    result.os.release = `${result.os.distro || 'Linux'} ${result.os.version || ''}`.trim();\n                    getHostname();\n                  } else if (command.includes('lsb_release')) {\n                    // 解析lsb_release格式\n                    const distroMatch = output.match(/Distributor ID:\\s+(.+)/);\n                    const versionMatch = output.match(/Release:\\s+(.+)/);\n                    \n                    if (distroMatch) {\n                      result.os.distro = distroMatch[1].trim();\n                    }\n                    if (versionMatch) {\n                      result.os.version = versionMatch[1].trim();\n                    }\n                    \n                    result.os.release = `${result.os.distro || 'Linux'} ${result.os.version || ''}`.trim();\n                    getHostname();\n                  } else if (command.includes('/etc/redhat-release') || command.includes('/etc/debian_version')) {\n                    // 直接使用文件内容\n                    result.os.release = output;\n                    result.os.distro = output.split(' ')[0] || 'Linux';\n                    \n                    // 尝试提取版本号\n                    const versionMatch = output.match(/(\\d+(\\.\\d+)+)/);\n                    if (versionMatch) {\n                      result.os.version = versionMatch[1];\n                    }\n                    \n                    getHostname();\n                  } else {\n                    tryNextCommand();\n                  }\n                } else {\n                  tryNextCommand();\n                }\n              });\n            });\n          }\n        }\n        \n        // 获取macOS版本\n        function getMacOSVersion() {\n          sshClient.exec('sw_vers', (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (sw_vers):', err);\n              getHostname();\n              return;\n            }\n            \n            let macOutput = '';\n            stream.on('data', (data) => {\n              macOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              const productMatch = macOutput.match(/ProductName:\\s+(.+)/);\n              const versionMatch = macOutput.match(/ProductVersion:\\s+(.+)/);\n              \n              if (productMatch) {\n                result.os.distro = productMatch[1].trim();\n              }\n              if (versionMatch) {\n                result.os.version = versionMatch[1].trim();\n              }\n              \n              result.os.release = `${result.os.distro || 'macOS'} ${result.os.version || ''}`.trim();\n              getHostname();\n            });\n          });\n        }\n        \n        // 获取Windows版本\n        function getWindowsVersion() {\n          sshClient.exec('wmic os get Caption,Version,OSArchitecture /value', (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (wmic os):', err);\n              getHostname();\n              return;\n            }\n            \n            let winOutput = '';\n            stream.on('data', (data) => {\n              winOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              const captionMatch = winOutput.match(/Caption=(.+)/);\n              const versionMatch = winOutput.match(/Version=(.+)/);\n              const archMatch = winOutput.match(/OSArchitecture=(.+)/);\n              \n              if (captionMatch) {\n                result.os.distro = captionMatch[1].trim();\n              }\n              if (versionMatch) {\n                result.os.version = versionMatch[1].trim();\n              }\n              \n              let archInfo = '';\n              if (archMatch) {\n                archInfo = ` (${archMatch[1].trim()})`;\n              }\n              \n              result.os.release = `${result.os.distro || 'Windows'} ${result.os.version || ''}${archInfo}`.trim();\n              getHostname();\n            });\n          });\n        }\n        \n        // 获取主机名\n        function getHostname() {\n          sshClient.exec('hostname', (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (hostname):', err);\n              getMemoryInfo();\n              return;\n            }\n            \n            let hostnameOutput = '';\n            stream.on('data', (data) => {\n              hostnameOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              result.os.hostname = hostnameOutput.trim();\n              getMemoryInfo();\n            });\n          });\n        }\n        \n        function getMemoryInfo() {\n          // 根据平台决定获取内存命令\n          const memCommand = result.os.platform === 'win32' \n            ? 'wmic OS get FreePhysicalMemory,TotalVisibleMemorySize /Value' \n            : 'free -b';\n          \n          sshClient.exec(memCommand, (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (memory):', err);\n              getCpuInfo();\n              return;\n            }\n            \n            let memOutput = '';\n            stream.on('data', (data) => {\n              memOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              try {\n                if (result.os.platform === 'win32') {\n                  // 解析Windows内存信息\n                  const freeMatch = memOutput.match(/FreePhysicalMemory=(\\d+)/);\n                  const totalMatch = memOutput.match(/TotalVisibleMemorySize=(\\d+)/);\n                  \n                  if (freeMatch && totalMatch) {\n                    // Windows返回的是KB，需要转换为字节\n                    const free = parseInt(freeMatch[1], 10) * 1024;\n                    const total = parseInt(totalMatch[1], 10) * 1024;\n                    const used = total - free;\n                    \n                    result.memory.total = total;\n                    result.memory.free = free;\n                    result.memory.used = used;\n                    result.memory.usagePercent = Math.round((used / total) * 100);\n                  }\n                } else {\n                  // 解析Linux内存信息\n                  const memLines = memOutput.split('\\n');\n                  if (memLines.length > 1) {\n                    const memInfo = memLines[1].split(/\\s+/);\n                    if (memInfo.length >= 4) {\n                      result.memory.total = parseInt(memInfo[1], 10);\n                      result.memory.used = parseInt(memInfo[2], 10);\n                      result.memory.free = parseInt(memInfo[3], 10);\n                      result.memory.usagePercent = Math.round((result.memory.used / result.memory.total) * 100);\n                    }\n                  }\n                }\n              } catch (error) {\n                console.error('Error parsing memory info:', error);\n              }\n              \n              getCpuInfo();\n            });\n          });\n        }\n        \n        function getCpuInfo() {\n          // 根据平台选择不同命令\n          const cpuCommand = result.os.platform === 'win32'\n            ? 'wmic cpu get NumberOfCores,Name'\n            : 'cat /proc/cpuinfo | grep -E \"model name|processor\" | wc -l';\n          \n          sshClient.exec(cpuCommand, (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (cpuinfo):', err);\n              getCpuModel();\n              return;\n            }\n            \n            let cpuOutput = '';\n            stream.on('data', (data) => {\n              cpuOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              try {\n                if (result.os.platform === 'win32') {\n                  // 解析Windows CPU核心数\n                  const lines = cpuOutput.trim().split('\\n');\n                  if (lines.length >= 2) {\n                    const coresLine = lines[1].trim();\n                    result.cpu.cores = parseInt(coresLine, 10) || 1;\n                  }\n                } else {\n                  // 解析Linux CPU核心数\n                  result.cpu.cores = parseInt(cpuOutput.trim(), 10) / 2; // 除以2因为每个处理器有两行信息\n                }\n              } catch (error) {\n                console.error('Error parsing CPU count:', error);\n              }\n              \n              getCpuModel();\n            });\n          });\n        }\n        \n        function getCpuModel() {\n          const modelCommand = result.os.platform === 'win32'\n            ? 'wmic cpu get Name'\n            : 'cat /proc/cpuinfo | grep \"model name\" | head -1';\n          \n          sshClient.exec(modelCommand, (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (cpuinfo model):', err);\n              getCpuUsage();\n              return;\n            }\n            \n            let modelOutput = '';\n            stream.on('data', (data) => {\n              modelOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              try {\n                if (result.os.platform === 'win32') {\n                  // 解析Windows CPU型号\n                  const lines = modelOutput.trim().split('\\n');\n                  if (lines.length >= 2) {\n                    result.cpu.model = lines[1].trim();\n                  }\n                } else {\n                  // 解析Linux CPU型号\n                  const match = modelOutput.match(/model name\\s*:\\s*(.*)/);\n                  if (match && match[1]) {\n                    result.cpu.model = match[1].trim();\n                  }\n                }\n              } catch (error) {\n                console.error('Error parsing CPU model:', error);\n              }\n              \n              getCpuUsage();\n            });\n          });\n        }\n        \n        function getCpuUsage() {\n          const usageCommand = result.os.platform === 'win32'\n            ? 'wmic cpu get LoadPercentage'\n            : 'top -bn1 | grep \"Cpu(s)\" | sed \"s/.*, *\\\\([0-9.]*\\\\)%* id.*/\\\\1/\" | awk \\'{print 100 - $1}\\'';\n          \n          sshClient.exec(usageCommand, (err, stream) => {\n            if (err) {\n              console.error('SSH exec error (cpu usage):', err);\n              finalize();\n              return;\n            }\n            \n            let usageOutput = '';\n            stream.on('data', (data) => {\n              usageOutput += data.toString();\n            });\n            \n            stream.on('close', () => {\n              try {\n                if (result.os.platform === 'win32') {\n                  // 解析Windows CPU使用率\n                  const lines = usageOutput.trim().split('\\n');\n                  if (lines.length >= 2) {\n                    result.cpu.usage = parseInt(lines[1].trim(), 10);\n                  }\n                } else {\n                  // 解析Linux CPU使用率\n                  result.cpu.usage = parseFloat(usageOutput.trim());\n                }\n              } catch (error) {\n                console.error('Error parsing CPU usage:', error);\n              }\n              \n              finalize();\n            });\n          });\n        }\n        \n        function finalize() {\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// 加载AI设置，使用统一的config.json\nconst loadAISettings = () => {\n  const configPath = getConfigPath();\n  logToFile(`Loading AI settings from ${configPath}`);\n  \n  try {\n    if (fs.existsSync(configPath)) {\n      const data = fs.readFileSync(configPath, 'utf8');\n      const config = JSON.parse(data);\n      \n      // 从config对象中读取AI设置\n      if (config.aiSettings) {\n        const settings = { ...config.aiSettings };\n        logToFile(`Loaded settings: ${JSON.stringify({\n          hasConfigs: Array.isArray(settings.configs),\n          configsCount: Array.isArray(settings.configs) ? settings.configs.length : 0,\n          hasCurrent: !!settings.current\n        })}`);\n        \n        // 确保必要的属性存在\n        if (!settings.configs) {\n          settings.configs = [];\n          logToFile('No configs array found, initializing empty array', 'WARN');\n        }\n        \n        // 解密所有配置中的API密钥\n        if (settings.configs && Array.isArray(settings.configs)) {\n          settings.configs = settings.configs.map(cfg => {\n            if (cfg.apiKey) {\n              try {\n                return { ...cfg, apiKey: decrypt(cfg.apiKey) };\n              } catch (err) {\n                logToFile(`Failed to decrypt API key for config ${cfg.id}: ${err.message}`, 'ERROR');\n                return cfg;\n              }\n            }\n            return cfg;\n          });\n        }\n        \n        // 解密当前设置的API密钥\n        if (settings.current && settings.current.apiKey) {\n          try {\n            settings.current.apiKey = decrypt(settings.current.apiKey);\n          } catch (err) {\n            logToFile(`Failed to decrypt current API key: ${err.message}`, 'ERROR');\n          }\n        }\n        \n        // 确保当前设置存在所有字段\n        if (!settings.current) {\n          settings.current = {\n            apiUrl: '',\n            apiKey: '',\n            model: '',\n            streamEnabled: true\n          };\n          logToFile('No current settings found, initializing with defaults', 'WARN');\n        }\n        \n        return settings;\n      } else {\n        logToFile('No aiSettings found in config', 'WARN');\n      }\n    } else {\n      logToFile(`Config file does not exist: ${configPath}`, 'WARN');\n    }\n  } catch (error) {\n    logToFile(`Failed to load AI settings: ${error.message}`, 'ERROR');\n    console.error('Failed to load AI settings:', error);\n  }\n  \n  // 默认设置\n  logToFile('Returning default settings');\n  return {\n    configs: [],\n    current: {\n      apiUrl: '',\n      apiKey: '',\n      model: '',\n      streamEnabled: true\n    }\n  };\n};\n\n// 保存AI设置，使用统一的config.json\nconst saveAISettings = (settings) => {\n  const configPath = getConfigPath();\n  logToFile(`Saving AI settings to ${configPath}`);\n  logToFile(`Settings to save: ${JSON.stringify({\n    hasConfigs: Array.isArray(settings.configs),\n    configsCount: Array.isArray(settings.configs) ? settings.configs.length : 0,\n    hasCurrent: !!settings.current\n  })}`);\n  \n  try {\n    // 加载当前配置\n    let config = {};\n    if (fs.existsSync(configPath)) {\n      const data = fs.readFileSync(configPath, 'utf8');\n      config = JSON.parse(data);\n      logToFile('Loaded existing config');\n    } else {\n      logToFile('No existing config, creating new one');\n    }\n    \n    // 创建设置副本以避免修改原始对象\n    const settingsToSave = JSON.parse(JSON.stringify(settings));\n    \n    // 确保configs是数组\n    if (!settingsToSave.configs) {\n      settingsToSave.configs = [];\n      logToFile('No configs array in settings to save, initializing empty array', 'WARN');\n    }\n    \n    // 加密所有配置的API密钥\n    if (settingsToSave.configs && Array.isArray(settingsToSave.configs)) {\n      logToFile(`Encrypting ${settingsToSave.configs.length} configs`);\n      settingsToSave.configs = settingsToSave.configs.map(cfg => {\n        const configCopy = { ...cfg };\n        if (configCopy.apiKey) {\n          try {\n            configCopy.apiKey = encrypt(configCopy.apiKey);\n          } catch (err) {\n            logToFile(`Failed to encrypt API key for config ${cfg.id}: ${err.message}`, 'ERROR');\n          }\n        }\n        return configCopy;\n      });\n    }\n    \n    // 加密当前设置的API密钥\n    if (settingsToSave.current && settingsToSave.current.apiKey) {\n      try {\n        settingsToSave.current.apiKey = encrypt(settingsToSave.current.apiKey);\n        logToFile('Encrypted current API key');\n      } catch (err) {\n        logToFile(`Failed to encrypt current API key: ${err.message}`, 'ERROR');\n      }\n    }\n    \n    // 更新AI设置部分\n    config.aiSettings = settingsToSave;\n    \n    // 写回配置文件\n    const configJson = JSON.stringify(config, null, 2);\n    logToFile(`Config to write: ${configJson.substring(0, 100)}...`);\n    fs.writeFileSync(configPath, configJson, 'utf8');\n    logToFile('Successfully saved AI settings');\n    return true;\n  } catch (error) {\n    logToFile(`Failed to save AI settings: ${error.message}`, 'ERROR');\n    console.error('Failed to save AI settings:', error);\n    return false;\n  }\n};\n\n// 向Worker线程发送AI请求\nconst sendAIPrompt = async (prompt, settings) => {\n  try {\n    // 确保worker线程已经创建\n    if (!aiWorker) {\n      aiWorker = createAIWorker();\n    }\n    \n    // 如果worker创建失败，则使用内联处理\n    if (!aiWorker) {\n      console.log('Worker not available, using inline processing');\n      return processAIPromptInline(prompt, settings);\n    }\n    \n    // 生成唯一请求ID\n    const requestId = nextRequestId++;\n    \n    // 创建Promise，将其解析函数存储在Map中\n    const responsePromise = new Promise((resolve, reject) => {\n      // 设置5秒超时，避免永久阻塞\n      const timeoutId = setTimeout(() => {\n        aiRequestMap.delete(requestId);\n        reject(new Error('请求超时，AI处理时间过长'));\n      }, 5000);\n      \n      aiRequestMap.set(requestId, { \n        resolve: (result) => {\n          clearTimeout(timeoutId);\n          resolve(result);\n        }, \n        reject: (error) => {\n          clearTimeout(timeoutId);\n          reject(error);\n        } \n      });\n    });\n    \n    // 向worker发送请求\n    aiWorker.postMessage({\n      id: requestId,\n      type: 'prompt',\n      prompt,\n      settings\n    });\n    \n    // 等待结果\n    return await responsePromise;\n  } catch (error) {\n    console.error('Error sending AI prompt to worker:', error);\n    // 如果与worker通信失败，回退到内联处理\n    return processAIPromptInline(prompt, settings);\n  }\n};\n\n// 内联处理AI请求（作为worker不可用时的备选）\nconst processAIPromptInline = async (prompt, settings) => {\n  try {\n    // 检查设置是否有效\n    if (!settings || !settings.apiKey) {\n      return { error: 'API设置不完整，请在设置中配置API密钥' };\n    }\n    \n    if (!settings.apiUrl) {\n      return { error: 'API URL不可用，请在设置中配置API URL' };\n    }\n    \n    if (!settings.model) {\n      return { error: '模型名称未指定，请在设置中配置模型名称' };\n    }\n    \n    console.log('Processing AI prompt inline:', prompt.substring(0, 30) + '...');\n    \n    // 使用简单的响应模拟\n    return { \n      response: `这是对\"${prompt}\"的模拟响应(内联处理)。在实际应用中，这里将连接到AI API。您当前的设置是使用模型: ${settings.model}`, \n    };\n  } catch (error) {\n    console.error('Error processing AI prompt inline:', error);\n    return { error: `处理请求时出错: ${error.message}` };\n  }\n};\n\n// In this file you can include the rest of your app's specific main process\n// code. You can also put them in separate files and import them here.\n"],"names":["app","BrowserWindow","ipcMain","shell","dialog","clipboard","require","path","fs","spawn","crypto","os","pty","Client","SftpClient","Worker","logFile","join","__dirname","logToFile","message","type","timestamp","Date","toISOString","logEntry","appendFileSync","error","console","logDir","existsSync","mkdirSync","recursive","ENCRYPTION_KEY","ENCRYPTION_ALGORITHM","IV_LENGTH","aiWorker","aiRequestMap","Map","nextRequestId","childProcesses","sshClients","terminalProcesses","nextProcessId","activeTransfers","getWorkerPath","workerPath","Error","createAIWorker","terminate","log","on","id","result","callback","get","reject","resolve","delete","entries","code","setTimeout","encryptText","text","iv","randomBytes","key","createHash","update","digest","cipher","createCipheriv","encrypted","final","toString","decryptText","includes","ivHex","encryptedText","split","Buffer","from","decipher","createDecipheriv","decrypted","processConnectionsForSave","items","map","item","password","privateKeyPath","Array","isArray","processConnectionsForLoad","quit","getConfigPath","isDev","process","env","NODE_ENV","cwd","dirname","getPath","loadConnectionsConfig","configPath","data","readFileSync","config","JSON","parse","connections","saveConnectionsConfig","processedConnections","writeFileSync","stringify","selectKeyFile","showOpenDialog","properties","filters","name","extensions","title","canceled","filePaths","createWindow","iconPath","mainWindow","width","height","webPreferences","preload","MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY","contextIsolation","nodeIntegration","icon","setMenuBarVisibility","loadURL","MAIN_WINDOW_WEBPACK_ENTRY","webContents","openDevTools","setupIPC","initializeConfig","initialConfig","aiSettings","configs","current","apiUrl","apiKey","model","streamEnabled","configUpdated","oldConfig","now","undefined","push","forEach","currentFields","field","writeError","proc","stdout","removeAllListeners","stderr","kill","clear","platform","catch","err","getAllWindows","length","handle","processId","powershellPath","ps","USERPROFILE","HOME","set","listeners","Set","isDestroyed","output","send","event","sshConfig","host","Promise","ssh","tabId","connectionTimeout","clearTimeout","term","cols","rows","stream","end","procInfo","buffer","concat","e","instructions","lang","prompts","finish","prompt","toLowerCase","connectConfig","port","username","readyTimeout","keepaliveInterval","privateKey","passphrase","tryKeyboard","connect","processedData","write","stdin","getVersion","https","fetchGitHubRelease","options","hostname","method","headers","req","request","res","statusCode","chunk","releaseData","success","url","openExternal","command","startsWith","substring","setWindow","resize","has","getLocalSystemInfo","processObj","client","channel","sshClient","getRemoteSystemInfo","loadAISettings","settings","saveAISettings","existingIndex","findIndex","c","configId","originalLength","filter","selectedConfig","find","saveResult","sendAIPrompt","requestData","isStream","messages","http","URL","requestModule","protocol","pathname","search","sender","statusMessage","lines","line","jsonData","choices","delta","content","responseData","rawResponse","processInfo","sftp","readdir","list","files","filename","size","attrs","isDirectory","modifyTime","mtime","permissions","mode","sourcePath","targetPath","exec","errorOutput","filePath","remotePath","fileName","basename","showSaveDialog","defaultPath","buttonLabel","transferKey","tempFilePath","stats","stat","totalBytes","transferredBytes","lastProgressUpdate","lastTransferredBytes","lastUpdateTime","transferSpeed","progressReportInterval","progressCallback","transferred","progress","Math","floor","elapsedSinceLastUpdate","bytesTransferredSinceLastUpdate","remainingTime","fastGet","step","total","renameSync","showItemInFolder","cancelled","unlinkSync","targetFolder","localFilePath","statSync","normalizedTargetFolder","remoteFilePath","posix","replace","folderStat","statErr","fastPut","oldPath","newName","dirPath","newPath","rename","relativePath","basePath","trim","absolutePath","transfer","resolveError","osInfo","release","distro","version","windowsVersions","releaseVersion","majorMinor","buildNumber","parseInt","arch","macVersions","darwinVersion","isLocal","cpu","cpus","cores","speed","usage","getCpuUsage","memory","totalmem","free","freemem","used","usagePercent","round","totalIdle","totalTick","times","idle","getLinuxDistro","getMacOSVersion","getHostname","getWindowsVersion","distroCommands","commandIndex","tryNextCommand","distroOutput","nameMatch","match","versionMatch","distroMatch","macOutput","productMatch","winOutput","captionMatch","archMatch","archInfo","getMemoryInfo","hostnameOutput","memCommand","getCpuInfo","memOutput","freeMatch","totalMatch","memLines","memInfo","cpuCommand","getCpuModel","cpuOutput","coresLine","modelCommand","modelOutput","usageCommand","finalize","usageOutput","parseFloat","hasConfigs","configsCount","hasCurrent","cfg","decrypt","settingsToSave","configCopy","encrypt","configJson","processAIPromptInline","requestId","responsePromise","timeoutId","postMessage","response"],"sourceRoot":""}